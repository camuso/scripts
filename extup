#!/bin/bash

#
# Text Attributes
#
declare MYDIR=
MYDIR="$(dirname "$(which "$(basename "$0")")")"
declare MYLIB=$MYDIR/lib

source "$MYLIB"/ui.source

declare -i stat
declare rev=""
declare -i optcount=0
declare -a alist		# alternate (upstream) branch list
declare -a blist		# current branch list
declare -i count		# limit the number of commits to parse
declare show_b=true
declare notupstream="---------"
declare cmtline=
declare nomerges=
declare dates="-c -d"	# These will be cleared if the user enters -m option
declare usagestr=

usagestr=$(
cat <<EOF

$(basename "$0") [OPTIONS] commit-expr path

Example
   $(basename "$0") c68432e802b11..HEAD [drivers/char/ipmi]

Description

   Displays the current branch commit followed by the upstream branch
   commit as well as the upstream commit date (NOT the author date).

   The script assumes that the first commit hash it encounters in the
   commit log will be the upstream commit.

   If there is no upstream commit found, then a series of dashes is
   printed to the screen in its place, and the current branch commit
   date is printed, since there is no upstream commit.

Options must have a leading hyphen

   -u - upstream directory
   -r - reverse order
   -b - do not show downstream branch commit
   -n - no-merges
   -m - no-dates
   -h - this help text
   -<decimal integer> - limit the number of commits you want to parse to
                        the decimal integer.
\0
EOF
)

exitme() {
	echo -e "$usagestr"
	exit 0
}

# loop_range()
#
# Loop until user gives a number in the range defined by the args
#
# $1 - minimum
# $2 - maximum
# $3 - the value to be returned
#
loop_range() {
	local -i min=$1
	local -i max=$2
	local -i number
	local cmd
	local pstr=\
"$OFF\0Please enter a number between $BLD$min$OFF and $BLD$max$OFF: "

	[ "$max" -lt 10 ] && cmd=promptgetchar || cmd=getuser
	# echo "cmd: $cmd"

	while true; do
		$cmd "$pstr" number

		if [[ $number =~ ^-?[0-9]+$ ]]  && \
		   [[ $number -ge $min ]]       && \
		   [[ $number -le $max ]]; then
			eval "$3"="$number"
			echo
			return 0
		fi
	done
}

choose_commit() {
	local list="$1"
	local line=
	local index=0
	local ary

	echo "There is more than one commit in the git log"
	list=$(sort -u <<< "$list")

	while read -r line; do
		ary[$index]="$line"
		((++index))
		printf "%d: %s\n" "$index" "$line"
	done <<< "$list"

	loop_range 1 "$index" index

	((--index))
	echo "${ary[$index]}"
}

parseargs() {
	local arg=
	local opt=

	for arg in "$@"; do
	    if [ "${arg:0:1}" == '-' ]; then
		opt="${arg:1}"
		case "$opt" in
			u ) 	updir="$2"
				shift 2
				((optcount+=2))
				;;
			r ) 	rev="--reverse"
				shift 1
				((++optcount))
				;;
			b ) 	show_b=false
				shift 1
				((++optcount))
				;;
			n ) 	nomerges="--no-merges"
				shift 1
				((++optcount))
				;;
			m ) 	dates=
				shift 1
				((++optcount))
				;;
			h ) 	exitme
		esac
		if [[ $opt =~ ^[0-9]+$ ]]; then
			count="$opt"
			shift
			((++optcount))
			continue
		fi
	    fi
	done
}

parseargs "$@"
shift $optcount
commit_expr="$1"
pathspec="$2"

# Create an array of hashes from the current (rhel) branch using the
# options entered by the user.
#
blist=($(git log $nomerges -$count --oneline $rev --pretty=format:%h "$commit_expr" $pathspec))

for ((i=0; i < ${#blist[@]} && i < count; ++i)); do

	# skip over the downstream (RHEL) commit header
	log=$(git log -1 "${blist[$i]}" | tail -n +2)

	# trim all the leading spaces
	log="$(echo "$log" | sed -e 's/^ *//g')"

	# extract the first commit line we encounter
	cmtline=$(echo "$log" | grep -E -m1 '^commit')

	# extract the commit hash from the line
	alist[$i]=$(echo "$cmtline" | grep -E -o "\b[0-9a-f]{40}\b")
	stat=$?

	[ -d "$updir" ] && { cd "$updir" > /dev/null 2>&1 || exit; }

	# if the commit has a valid format, then ...
	if [ $stat -eq 0 ]; then

		# get the pretty commit line with commit date for the hash
		# extracted above.
		astr=$(gitnice $dates -1 "${alist[$i]}" 2> /dev/null)
		stat=$?

		if [ $stat -ne 0 ]; then
			tmp="$(gitnice $dates -1 "${blist[$i]}" | cut -d' ' -f2-)"
			echo -e " ##\n ## Commit ${alist[$i]:0:9} identified in"\
			        "${blist[$i]} cannot be found in any branch."
			astr="$notupstream $tmp"
		fi
	else
		tmp="$(gitnice $dates -1 "${blist[$i]}" | cut -d" " -f2-)"
		astr="$notupstream $tmp"
	fi

	if $show_b; then
		uc=$(echo "$astr" | cut -d' ' -f1)	# upstream cmt hash
		as=$(echo "$astr" | cut -d' ' -f2-)	# upstream cmt date & desc
		printf "%-9.9s %-9.9s %s\n" "${blist[$i]}" "$uc" "$as"
	else
		echo " $astr "
	fi

	[ -d "$updir" ] && { cd - > /dev/null 2>&1 || exit; }
done

