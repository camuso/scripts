#!/bin/bash
#
# gort - Gort is an Omnimodal Revision Tool
#
# Provide some automation for backporting.
#

#######################################
# Default file locations
#######################################
#
# Whatever directory this script and its companions are located in
# must be in the executable path.
#
# export PATH=$PATH:MYDIR
#
# Where MYDIR is the directory in which this script and its companions
# are located.
#
[ "$MYDIR" ] || {
	declare MYDIR=
	MYDIR="$(dirname "$(which "$(basename "$0")")")"
}
[ "$MYLIB" ] || {
	declare MYLIB=
	MYLIB="$MYDIR"/lib
}
declare MYMAN="$MYDIR"/man
declare MYDATA=
MYDATA="$(realpath ./.data)"
declare MYHLP="$MYMAN"/gort.pgman
declare MYNAME=
MYNAME="$(basename "$0")"

#######################################
# External Source Files
#######################################
[ "$ui_loaded" ]            || source "$MYLIB"/ui.source
[ "$configmanager_loaded" ] || source "$MYLIB"/config-manager.source
[ "$ptversion_loaded" ]     || source "$MYLIB"/patchtools-version.source
[ "$keypsupport_loaded" ]   || source "$MYLIB"/keypress-support.source

########################################
# Return and Control Codes
########################################
declare rc_continue=0	# Continue for another pass

declare exit_good=0	# Normal exit
declare exit_conflict=2	# Exit with a conflict
declare exit_reset=3	# Exit after resetting the world
declare exit_bogus=4	# Exit because of bogus commit
declare exit_pending=6	# There are changes pending, so action can't complete
declare exit_nothing=7	# There is nothing to do
declare exit_bad=10	# Exiting from command line call with bad status

declare b_session_inited=false	# boolean to indicate session is inited
declare b_cmdline=false		# boolean indicating a comman line call

#########################################
# Config Variables
#########################################
#** These variables will be initialized by the call to cfg_start
declare configfile=
declare upcmtstartline=		# Line in backportfile to start backport
declare dnorighead=		# original downstream head at session start
declare lastuphash=		# most recently applied upstream commit hash
declare workdir=		# scratch directory for the session
declare backportfile=		# File of upstream commits to apply
declare b_conflict=		# last attempt generated a conflict
declare str_jira=		# Options: JIRA link
declare str_cve=		# Options: CVE
declare str_upstream=		# Options: upstream version, e.g, v6.7
declare str_brew=		# Options: brew link
declare str_test=		# Options: string containing test info
declare stophash=		# stop backporting when this currentuphash
declare tbackground=		# terminal background, light(1) or dark(2)
declare patchdir=		# directory that gets the patches
declare backport_mode=		# user's choice of backport mode
declare conflicthash=		# upstream hash that introduced a conflict
declare updir=			# directory of upstream repo
declare patfil= 		# conflicted commit formatted into a patch
declare gitbranch=		# branch at start of session
declare timestamp=		# timestamp at start of session
#*

#########################################
# Global Variables
#########################################
declare -i menupad=31
declare cmtmsgfile=
declare b_lasthashvalid=false
declare b_new=false		# new session
declare b_single=false		# only perform single backport
declare b_statflag=false	# user asking for status

declare mirror		# bare shared repo of upstream
declare gitbranch	# current downstream branch
declare finaluphash
declare currentuphash	# next hash in the backportfile
declare currentupcommit # oneline gitlog of next hash in the backportfile
declare lastuplog	# oneline gitlog of last committed upstream hash
declare dncurrenthead	# hash of current downstread head
declare patchlog	# file containing the patching errors
declare starterr=	# errors on startup

# Lines in the backport file starting with any of these chars will be
# ignored.
# The '#' indicates a comment, and the '+' indicates already committed.
declare ignore_str="#+"

########################################
# Global Strings
########################################
declare str_herald=
declare str_conflicts=

init_global_strings() {
ui_log "init_global_strings"
str_herald="\n$MNU${UND}patchtools v$version$OFF - \
${CAU}G${INF}ort is an ${CAU}O${INF}mnimodal$CAU R${INF}evision$CAU T${INF}ool$OFF"
str_conflicts="Conflicts:\n"
}

#########################################
# Functions
#########################################

test_sanity() { echo -en "${CAU}SANITY$INF : $1$OFF "; ui_press_any; }

#** print_herald: print the script's herald defined above
#
#     ARGUMENTS:  Implicit global, str_herald
#       RETURNS:  None
#*
print_herald() {
	ui_log "print_herald"
	echo -e "$str_herald"
	echo -e "${CAU}                   Klaatu barada nikto$OFF"
}

#** exit_gort: exit in an orderly manner
#
#     ARGUMENTS:  1 - exit code
#                 2 - optional exit message
#       RETURNS:  None
#*
exit_gort() {
	ui_log "exit_gort 1:$1  2:$2"
	# echo -e "$UND\0exit_gort $1$OFF"
	ui_trunclog
	[ -n "$2" ] && echo -e "\n$2\n"
	# $b_session_inited && save_session
	exit "$1"
}

#** gu_pushd - cd safely to new directory, exit if there is a problem.
#
# Globals
#   none
#
# Arguments
#   1 - directory to cd into
#*
gu_pushd() {
	ui_log "gu_pushd"
	pushd "$1" > /dev/null 2>&1 ||
		exit_gort 1 "${CAU}${1} is not a valid directory!$OFF"
}

#** gu_popd - cd safely out of directory, exit if there is a problem.
#
# Globals
#   none
#
# Arguments
#   none
#*
gu_popd() {
	ui_log "gu_popd"
	popd > /dev/null 2>&1 ||
		exit_gort 1 "${CAU}Directory stack empty!$OFF"
}

#** get_gitbranch: prints the name of the current git branch
#
#     ARGUMENTS:  None
#       RETURNS:  None
#*
get_gitbranch() {
	ui_log "get_gitbranch"
	git branch | grep '\*' | cut -d' ' -f2
}

#** select_gitbranch: list the available branches for the user to choose one
#
#     ARGUMENTS:  None
#       GLOBALS:  workdir
#                 gitbranch
#       RETURNS:  0 if new branch selected, 1 if user did not make a selection
#                 or if the selected branch could not be checked out.
#*
select_gitbranch() {
	ui_log "select_gitbranch"
	local index=1
	local linenumber
	local line
	local outline
	local hilite=
	local branchlistfile="$workdir"/branchlist

	echo
	echo -e "${MNU}Select the Downstrean Branch or press $qstr$INF to leave" \
		"the current "
	echo -e "selection marked with the leading *.$OFF"

	git branch > "$branchlistfile"

	while read -r line; do
		[ "${line:0:1}" = "*" ] && hilite="$MNU" || hilite="$INF"
		outline=$(printf "%s %2d %s $line\n" "$hilite" $index "$OFF")
		echo -e "$outline"
		((++index))
	done < "$branchlistfile"

	# echo -e "$brmsg"
	loop_range 1 $((index - 1)) linenumber
	gitbranch="$(ui_readline "$linenumber" "$branchlistfile" | tr -d [\*" "])"
	echo -e "${MNU}git checkout $STA$gitbranch$OFF"
	clean_status

        git checkout "$gitbranch" || {
		$b_cmdline && exit_gort $exit_pending;
		return 1
	}

	git log --oneline -1
	set_cfg_item gitbranch "$gitbranch"

	get_originhead
	$b_cmdline && exit_gort $exit_good || return 0
}

#** git_set_subjectprefix: Set the subject prefix in .git/config
#
#     ARGUMENTS:  none
#       RETURNS:  none
#*
git_set_subjectprefix() {
	ui_log "git_set_subjectprefix"
	local newpfx
	newpfx="$(git config format.subjectprefix)"

	echo -e "$INF" \
"Just press ${STA}ENTER$INF to leave the current subject prefix unchanged.$OFF"
	getuser "${MNU}New subject prefix: $OFF" newpfx
	[ "$newpfx" ] || return
	git config format.subjectprefix "$newpfx"
}

#** input_dir - set a directory variable and save it in the config file
#
# Arguments
#   $1 - string to be used in the prompt describing the directory
#   $2 - the config file key for the directory variable name
#   $3 - the current value of the directory variable. Will be updated
#        if the user changes the directory name.
#*
input_dir() {
	ui_log "input_dir"
	local dirstr="$1"
	local dircfgkey="$2"
	local dir="${!3}"
	local b_msgshown=false

	[ -n "$dir" ] && {
		echo -e "${INF}Current $STA$dirstr$INF directory : $STA$dir$OFF"
		echo -e "${INF}Type $qstr$INF to leave it as it is.$OFF"
	}

	ui_getnewdir "${INF}New $STA$dirstr$INF directory : $OFF" dir

	dir=$(realpath "$dir")
	set_cfg_item "$dircfgkey" "$dir"
	echo -e "$INF$dirstr directory is $STA$dir$OFF\n"
	eval "$3"="$dir"
}

#** is_valid_gitdir - check that the directory is a valid git directory
#
# Globals
#   none
#
# Arguments
#   1 - directory to test
#
# Returns
#   0 - if valid git directory
#   1 - if not
#*
is_valid_gitdir() {
	ui_log "is_valid_gitdir"
	local gdir="$1"

	# Strip off any tailing slash
	#
	gdir="${gdir%/}"

	[ "$gdir" == "$(git -C $gdir rev-parse --show-toplevel 2>&1)" ] \
		&& return 0 \
		|| return 1
}

#** input_backportfile: user enters file containing commits to backport
#
#     ARGUMENTS:  none
#       GLOBALS:  backportfile - file containing the commits to be backported
#       RETURNS:  status of call to ui_getfilespec()
#*
input_backportfile() {
	ui_log "input_backportfile"
	local stat
	local prstr
	local commitsfilemsg
	local exitmsg
	local currentfile

	prstr=$(
cat <<EOF
${INF}Backports File$OFF
EOF
)
	commitsfilemsg=$(
cat <<EOF
${OFF}You can create a file containing the upstream commits to be backported
using the$INF mkbackportlog$OFF tool.
EOF
)
	exitmsg=$(
cat <<EOF
${INF}
You pressed $qstr$INF without providing a Backports File, so we must exit.$OFF
EOF
)
	currentfile=$(
cat <<EOF
${INF}The current file is $STA$backportfile$INF.
Press $qstr$INF at the prompt to use this file.$OFF
EOF
)
	# echo -e "$UND\0input_backportfile$OFF"

	[ "$backportfile" ] && prstr="$prstr.\n$currentfile"
	ui_getfilespec "$prstr : " backportfile
	stat=$?

	if [ $stat -ne 0 ]; then
		if [ "$backportfile" ]; then
			echo -e "${INF}Keeping: $STA$backportfile$OFF"
		else
			echo -e "$exitmsg"
			exit_gort $exit_nothing "$commitsfilemsg"
		fi
	fi

	backportfile="$(realpath "$backportfile")"
	set_cfg_item "backportfile" "$backportfile"
	return $stat
}

#** pr_nohash_msg: message for hash not among commits in backport file
#
#     ARGUMENTS:  $1 - hash
#       GLOBALS:  backportfile - file of upstream commits to backport
#       RETURNS:  none
#*
pr_nohash_msg () {
	ui_log "pr_nohash_msg"
	local hash="$1"
	local nohash_msg

	nohash_msg=$(
cat <<EOF
$INF
  Cannot find $STA$hash$INF as a commit or valid line number in $STA$backportfile$INF
  Lines having a '$STA\0#$INF' as their first character are not listed or considered.
  Try again or type $qstr$INF to return to main menu.$OFF
EOF
)
	echo -e "$nohash_msg"
}

#** lookup_hash: Find the given hash in the backport commits file
#
#     ARGUMENTS:  $1 - hash
#                 $2 - will return the number of the line in the commits file
#                      that has the hash.
#       GLOBALS:  backportfile - file of upstream commits to backport
#       RETURNS:  nonzero if lookup fails
#*
lookup_hash() {
	ui_log "lookup_hash"
	local hash=$1
	local counter
	local line

	[[ -f "$backportfile" ]] || return 1

	counter=$(grep -m1 -n "^$hash" "$backportfile" | cut -d':' -f1)

	[ -z "$counter" ] && return 1

	eval "$2"="$counter"
	return 0
}

#** set_next_backport: Select the starting commit from the backportfile
#
#     ARGUMENTS:  none
#       GLOBALS:  backportfile - file of upstream commits to backport
#                 upcmtstartline- starting line for backportfile
#                 currentupcommit - global storage for current upstream commit
#                 currentuphash - global storage for current upstream cmt hash
#                 tlines        - number of lines in the terminal window
#                 tcols         - number of columns in the terminal window
#                 qstr          - string with a boldfaced 'q'
#                 ignore_str    - string of comment chars in commits log
#       RETURNS:  none
#*
set_next_backport() {
	ui_log "set_next_backport"
	# echo -e "$UND\0set_next_backport$OFF"

	local counter=0
	local line
	local linary
	local -i idx=0
	local -i stat
	local -i linecount
	local -i numwid=
	local -i cols=
	local selected

	[ -f "$backportfile" ] || return
	linecount=$(wc -l "$backportfile")
	numwid=${#linecount}
	cols=$((tcols - 2 - numwid))
	echo -e "\n${INF}Contents of upstream commits file: $STA$backportfile$OFF"
	echo -e "$MNU\0NOTE:$INF Not showing lines starting with any of these chars:"\
	        "$STA$ignore_str$OFF\n"

	# Dump the contents of the backportfile
	#
	while read -r line; do
		((++counter))
		[ "$(ui_strindex "$ignore_str" "${line:0:1}")" -ge 0 ] && continue
		line=$(printf "%s %${numwid}d %s%s%s" "$MNU" $((idx+1)) "$OFF" "$line")
		echo -e "${line:0:cols}$OFF"
		linary[$idx]=$counter
		((++idx))
	done < "$backportfile"

	echo
	loop_range_q 1 "$idx" selected
	[ "$selected" = "q" ] && return

	upcmtstartline=${linary[$((selected - 1))]}
	currentupcommit="$(ui_readline "$upcmtstartline" "$backportfile")"
	# echo "currentupcommit: $currentupcommit"
	currentuphash=$(echo "$currentupcommit" | cut -d' ' -f1)
	$b_cmdline && exit_gort $exit_good
}

#** validate_last_upstream_hash: assure commit hash is valid
#
#   Validates whether the hash stored in the project file is valid for this
#   instance of gort
#
#     ARGUMENTS:  none
#       GLOBALS:  backportfile - the file containing the hashes of the commits
#                                to be backported.
#                 b_lasthashvalid - boolean indicating last hash was valid
#                 updir - directory of upstream repo
#       RETURNS:  nonzero if the last stored hash is not valid
#*
validate_last_upstream_hash() {
	ui_log "validate_last_upstream_hash"
	local stat=0

	$b_new && b_lasthashvalid=false || b_lasthashvalid=true

	# If we don't have a commits file, show nothing
	[[ -f $backportfile ]] || {
		b_lasthashvalid=false
		return 1
	}

	# If there is no hash saved in the config file, then nothing to do.
	[[ "$lastuphash" ]] || {
		b_lasthashvalid=false
		return 1
	}

	# If the commit stored in the config file is not in the backport file
	# then nothing to do.
	grep -m1 -n "$lastuphash" "$backportfile" >/dev/null 2>&1 || {
		b_lasthashvalid=false
		return 1
	}

	# If we can't get a log of that upstream hash, then it's not valid.
	lastuplog=$(git log -n1 --oneline "$lastuphash") 2>/dev/null || {
		b_lasthashvalid=false
		return 1
	}

	# If we got this far, the lastuphash is valid.
	b_lasthashvalid=true
	return 0
}

#** get_lastuplog: gitnice of most recent, successfully applied upstream commit
#
#  Also inits the lastuphash, if there was one.
#
# Globals:
#   lastuplog
#   lastuphash
#   backportfile
#
# Returns
#   0 - if there was an upstream hash applied
#   1 - if there was no upstream hash applied yet or if there's no backport
#       file
#*
get_lastuplog() {
	ui_log "get_lastuplog"
	local ch="+"
	local stat=

	lastuphash=

	[ -f "$backportfile" ] || stat=1

	lastuphash="$(tac "$backportfile" | \
		grep -m 1 '^+' | sed 's/^\+\s*\([^[:space:]]*\).*/\1/')"

	if [ -n "$lastuphash" ]; then
		lastuplog="$(git log --oneline -1 "$lastuphash")"
		stat=0
	else
		stat=1
	fi

	cfg_set_item "lastuphash" "$lastuphash"
	return "$stat"
}

#** get_finaluphash: find the last commit in the backport commits file
#
# Globals
#   backportfile
#   finaluphash
#*
get_finaluphash() {
	local -a lary=()

	mapfile -t lary < <(grep -v "^[${ignore_str}]" "$backportfile" | grep -v '^$')
	finaluphash="$(cut -d' ' -f1 <<< "${lary[-1]}")"
}

#** git_verify - verifies whether the given hash is a commit
#
# Arguments
#   1 - the hash to verify
#*
git_verify() {
	local cmthash="$1"
	git rev-parse --verify "${cmthash}^{commit}" >/dev/null 2>&1
	return $?
}

#** git_upcmd - execute a git command in the upstream context
#
# The upstream context is hard-coded as either changing into
# the actual upstream directory or using a mirror repo of the
# upstream directory.
#
# Currently using: Mirror Repo
#
# Globals
#   updir   - upstream directory
#   workdir - directory to receive git formatted patches
#
# Arguments
#   1 - cmd    - the git command to execute
#   2 - uphash - the upstream hash for the git command
#*
git_upcmd() {
	ui_log "git_upcmd cmd:$1 uphash:$2"
# set -x
	local cmd="$1"
	local uphash="$2"
	local upstr=

	case "$cmd" in
		"show")	upstr="$(git show "$uphash")"
			;;
		"log")	upstr="$(git log -n1 "$uphash")"
			;;
		"nice")	upstr="$(gitnice -1 "$uphash")"
			;;
		"parse") upstr="$(git rev-parse "$uphash")"
			;;
		"format" ) upstr=$(git format-patch -1 "$uphash" -o "$workdir")
			;;
		"verify" ) git_verify "$uphash" ; return $?
	esac
	echo "$upstr"
	return 0
# set +x
}

#** get_next_backport: gets the next commit in the backport commits file
#
#
#  Ignores lines with leading *, indicating the commit is to be skipped, and
#  leading +, indicating the commit has already been applied to the downstream
#  branch.
#
#     ARGUMENTS:  none
#       GLOBALS:  backportfile
#                 upcmtstartline
#                 currentuphash
#                 currentupcommit
#                 ignore_str
#                 menupad
#       OUTPUTS:  echoes the hash of next upstream commit in the commits file
#       RETURNS:  1 if there are no more cherries to pick, else 0
#*
get_next_backport() {
	# local myname="get_next_backport: "
	# echo -e "\n$UND$myname$OFF start line: $upcmtstartline"

	[[ -f "$backportfile" ]] || return 1

	local idx
	local line
	local -a lary=()
	local sts=0

	# Make sure we have a valid upstream directory, or prompt the user to
	# input one.
	#
	[ -d "$updir" ] || input_dir "Upstream repo directory" "updir" updir

	# Find the first line that does NOT begin with one of the characters in the
	# string of characters indicating the line is to be ignored.
	#
	mapfile -t lary < <(grep -v "^[${ignore_str}]" "$backportfile" | grep -v '^$')
	if ((${#lary} > 0)); then
		currentuphash="$(cut -d' ' -f1 <<< "${lary[0]}")"
		upcmtstartline="$(grep -n "$currentuphash" "$backportfile" | cut -d: -f1)"
		currentupcommit="$(git_upcmd "nice" "$currentuphash")"
		sts=0
	else
		currentuphash=
		upcmtstartline="$(($(wc -l < "$backportfile") + 1))"
		sts=1
	fi

	set_cfg_item "upcmtstartline" "$upcmtstartline"
	return $sts
}

#** get_current_backport: gets the current commit to backport
#
#  Gets the current commit in the commits file indicated by the current
#  upcmtstartline.
#
#  Because get_next_backport always pre-increments the upcmtstartline, this
#  routine will decrement the upcmtstartline before calling get_next_backport.
#
#     ARGUMENTS:  none
#       GLOBALS:  upcmtstartline
#       OUTPUTS:  echoes the hash of next upstream commit in the commits file
#       RETURNS:  status of call to get_next_backport
#*
get_current_backport() {
	# ui_log "get_current_backport upcmtstartline:$upcmtstartline"
	# local myname="get_current_backport:"
	# echo -e "$OFF\n$UND$myname upcmtstartline: $upcmtstartline$OFF"

	((--upcmtstartline))
	# echo "$myname startline: $upcmtstartline"
	get_next_backport
	return $?
}

#** show_next_backport: show the next upstream commit to backport
#
#     ARGUMENTS:  None
#       GLOBALS:  backportfile
#                 currentupcommit
#                 currentuphash
#                 b_conflict
#                 b_cmdline
#                 menupad
#                 tcols		# calculated in lib/ui.source
#       RETURNS:  none
#*
show_next_backport() {
	# ui_log "show_next_backport currentupcommit:$currentupcommit currentuphash:$currentuphash"
	# echo "\n${UND}show_next_backport$OFF"

	local linecount
	local prstr=
	local statstr
	local leadstr
	local cols=$((tcols - menupad))
	local show_next_backport_str
	local padstr="$(printf "%*c" "$menupad" " ")"

	($b_cmdline || $b_conflict || $b_statflag) \
		&& leadstr="    " || leadstr="$MNU c$OFF  "
	$b_conflict && statstr="${CAU}Conflicting commit       ${OFF}:" \
		    || statstr="Next backport commit     :$OFF"

	get_current_backport	&& prstr="$STA${currentupcommit:0:$cols}$OFF"

	show_next_backport_str=$(
cat <<EOF

$leadstr$statstr $prstr
EOF
)
	[ -n "$currentuphash" ] && echo -e "$show_next_backport_str"
	return 0
}

#** show_select_next_backport: let user select next commit to backport
#
#     ARGUMENTS:  none
#       GLOBALS:  backportfile
#       RETURNS:  0
#*
show_select_next_backport() {
	# echo -e "${UND}show_select_next_backport$OFF"

	local selcmt_str

	selcmt_str=$(
cat <<EOF

$MNU S$INF  Select a different commit for next backport$OFF
EOF
)
	[[ -f $backportfile ]] || return 1
	echo -e "$selcmt_str"
	return 0
}

#** get_lastbackport: get the last successfully applied upstream commit
#
# Globals:
#   dnorighead
#
# Returns:
#   0 extracted upstream hash is not dnorighead and is an actual hash
#   1 extracted upstream hash is the same as the dnorighead
#   2 extracted upstream hash field is not a hash
#   3 dnorighead is null
#*
get_lastbackport() {
	ui_log "get_lastbackport"
	local bp
	local hhash="$(git rev-parse --short HEAD)"

	[ -n "$dnorighead" ] || return 3

	[ "$(git rev-parse "$hhash")" == "$(git rev-parse "$dnorighead")" ] \
		&& return 1

	extract_upcmt "$hhash"
	[[ $hhash =~ ^[0-9a-fA-F]+$ ]] && return 0 || return 2
}

#** show_most_recent_backport: show the last upstream commit backported
#
#     ARGUMENTS:  none
#       GLOBALS:  lastuplog
#                 tcols
#                 menupad
#                 b_lasthashvalid
#       RETURNS:  none
#*
show_most_recent_backport() {
	ui_log "show_most_recent_backport"
	# echo -e "\n${UND}show_most_recent_backport$OFF"

	local cols=$((tcols - menupad))
	local laststr
	local padstr="$(printf "%*c" "$menupad" " ")"
	local eofstr="$CAU${padstr}was the last commit in Backports File$OFF"
	local lastbackport=

	[ -f "$backportfile" ] || return
	lastbackport="$(get_lastbackport)" || { echo -n; return; }

	laststr="\n    Last backported commit   : $STA${lastbackport:0:$cols}$OFF"
	echo -e "$laststr"
	((upcmtstartline > $(wc -l < "$backportfile"))) && echo -e "$eofstr"
}

#** extract_upcmt: extract upstream commit from downstream hash
#
# Echoes the extracted upstream hash to the caller. If there is no
# upstream commit in the downstream hash passed as argument, then it
# returns an empty string.
#
# Globals
#   none
#
# Arguments
#   1 - dnhash: downstream hash
#
#*
extract_upcmt() {
	local dnhash="${1:-"HEAD"}"	# default is HEAD

	git log -1 --pretty=%B "$dnhash" \
		| awk '/^commit[[:space:]]+[0-9a-f]{40}/ { print $2; exit }' \
		| xargs git rev-parse --short 2> /dev/null
}

#** show_upstream_commits_file: print the filename of the upstream commmits file
#
#     ARGUMENTS:  none
#       GLOBALS:  backportfile
#                 b_cmdline
#       RETURNS:  none
#*
show_upstream_commits_file() {
	ui_log "show_upstream_commits_file"
	# echo -e "${UND}show_upstream_commits_file$OFF"

	local cmtfilestr
	local -i nd	# number of commits to do
	local -i nb	# number of commits done
	local -i nc	# number of commits remaining to be done
	local lastupcmt	# last upstream commit backported in file
	local lastdncmt # last downstream commit in current downstream branch
	local lastdnup  # last upstream commit referenced in last downstream commit
	local padstr="$(printf "%*c" "$menupad" " ")"

	if $b_cmdline || $b_conflict || $b_statflag; then
		cmtfilestr="$INF    Upstream Backports File  : $STA$backportfile$OFF"
	else
		cmtfilestr="$MNU f$OFF  Upstream Backports File  : $STA$backportfile$OFF"
	fi

	echo -e "$cmtfilestr"

	[ "$backportfile" ] || return
	[ "$dnorighead" ] || return

	# Count commits that are not hashed-out
	nd="$(grep -c -v '^#' "$backportfile")"

	# Count backports in the file that indicate they have been committed.
	nb="$(grep -c '^+' "$backportfile")"

	# If none of the upstream commits has been applied to downstream, and
	# the current head is same as the dnorighead, then just return, else
	# report an inconsistent state.
	lastdncmt="$(git rev-parse --short HEAD)"
	dnorighead="$(git rev-parse --short "$dnorighead")"

	if ((nb == 0)); then
		if [ "$lastdncmt" == "$dnorighead" ]; then
			return 0
		else
			echo -e "$CAU\
$padstr Inconsistent State$INF
$padstr None of the commits in the Backports File
$padstr has been applied, but the current head : $STA$lastdncmt$INF
$padstr differs from \"Head at Session Start\"   : $STA$dnorighead\"$OFF."
			return 1
		fi
	fi

	# If the last one in the file that indicates it was committed is not
	# at the top of the current downstream branch, then notify inconsistent
	# state.

	lastupcmt="$(tac "$backportfile" | \
		grep -m 1 '^+' | sed 's/^\+\s*\([^[:space:]]*\).*/\1/')"

	lastdnup="$(extract_upcmt "$lastdncmt")"

	# If we didn't extract an upstream commit from the current HEAD,
	# then report that the backportfile has a backport marked, but
	# there's no upsteam commit referenced in the current HEAD.
	if [ -z "$lastdnup" ]; then
		echo -e "$CAU\
$padstr Inconsistent State$INF
$padstr Upstream Backport file shows upstream: $STA$lastupcmt$INF
$padstr was backported, but the current HEAD : $STA$lastdncmt$INF
$padstr does not have any upstream commit reference in its log.$OFF"
		return 1
	fi

	if [ "$lastdnup" != "$lastupcmt" ]; then
		echo -e "$CAU\
$padstr Inconsistent State$INF
$padstr Current Head references upstream commit  : $STA$lastupcmt$INF
$padstr Upstream Backports File says it should be: $STA$lastdnup$OFF"
		return 1
	fi

	nc=$((nd - nb))
	if ((nc == 0)); then
		echo -e \
"$padstr${CAU}It appears all upstream commits have been applied.$OFF"
	else
		echo -e \
"$padstr${INF}Commits backported: $STA$nb$INF Commits remaining: $STA$nc$OFF"
	fi

	return 0
}

#** show_history: history of applied patches in downstream branch

#     ARGUMENTS:  none
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#                 dnorighead
#       RETURNS:  none
#*
show_history() {
	local tmpfile=$(mktemp)
	local tmpfile
	local -i count
	local -i mypid
	local -a dncmtary=()

	echo -e "\n$MNU${UND}History of commits made this session$OFF"
	count=$(git rev-list --count "$dnorighead"..HEAD)
	echo -e "\
There are $STA$count$OFF commits since Head at Session Start: $STA$dnorighead$OFF"
	tmpfile=$(mktemp)
	extup -m "$dnorighead..HEAD" > "$tmpfile" & mypid=$!
	ui_waitonproc_tty "$mypid" 0.05 "${INF}Getting the History of commits...$OFF"
	ui_nclearline 1
	echo
	echo -e     "${MNU} Downstream $OFF|$MNU Upstream  "
	echo -e "$MNU${UND}  Commits   $OFF|$MNU${UND}  Commits   $OFF"
	cat "$tmpfile"
	echo -e "$OFF"
	rm -f "$tmpfile"

	$b_cmdline && exit 0
	ui_press_any
	return 0
}

#** show_status: prints the current status to the screen
#
#     ARGUMENTS:  $1 - If this argument is not empty, then forego the
#                      init_cmdline_call
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#       RETURNS:  none
#*
show_status() {
	ui_log "show_status $1"
	# echo -e "$UND\0show_status$OFF"

	local cols=$((tcols - menupad))
	local subjectprefix
	local lastbrcmt
	local orighead
	local statstr
	local b_internal

	echo -e "$INF"
	git status

	subjectprefix="$(git config format.subjectprefix)"
	[ "$1" ] && b_internal=true || b_internal=false

	lastbrcmt=$(git log -n1 --oneline)
	orighead=$(git log --oneline -n1 "$dnorighead")

	statstr=$(
cat <<EOF
\0
$INF    Session Start Date       : $STA$(get_cfg_item timestamp)
$INF$(show_upstream_commits_file)\
$INF$(show_most_recent_backport)\
$INF$(show_next_backport)
$INF    Current upstream dir     : $STA$updir
$INF    Current downstream branch: $STA$(get_gitbranch)
$INF    Current downstream head  : $STA${lastbrcmt:0:cols}
$INF    Original downstream head : $STA${orighead:0:cols}$OFF
\0
EOF
)
	echo -e "$statstr"
	$b_conflict && flag_conflict "$(get_cfg_item "conflicthash")"
	$b_cmdline && exit 0 || { ui_press_any; return; }
}

#** get_patchdir: get the directory to receive the patches
#
# Globals
#   patchdir
#
# Returns:
#   0 if new patchdir
#   1 if user quit without entering a new patchdir
#*
get_patchdir() {
	ui_log "get_patchdir"
	local pdir=
	local prstr

	prstr="\n${MNU}Directory path for patchfiles. $OFF\n"
	prstr+="${INF}Enter $qstr$INF to leave it as it is.$MNU\n"
	prstr+="$patchdir : $OFF"

	ui_getnewdir "$prstr" pdir || return 1
	patchdir="$pdir"
	set_cfg_item "patchdir" "$patchdir"
	return 0
}

#** create_patches: create a patch series from the backported commits
#
# Globals:
#  patchdir - directory for the patch series files
#  dnorighead - head when New session was started
#
#*
create_patches() {
	ui_log "create_patches"
	local dirstr="
${MNU}Do you want to use$STA $patchdir$MNU for your patches? y/n :$OFF "
	local findargs="-maxdepth 1 -type f -name "*.patch" -print -quit"

	cfg_get_item "patchdir" patchdir
	local pdir="$patchdir"

	echo -e "\n${INF}Create a patch series from the applied commits.$OFF"

	[ -d "$pdir" ] && {
		loop_yn "$dirstr" || pdir=
	}

	[ -d "$pdir" ] || {
		get_patchdir || return
	}

	local delprompt="$(
cat <<EOF
${CAU}There are .patch files in$STA $patchdir$CAU.
${INF}They will be erased if you continue.
Do you want to proceed?$MNU y/n : $OFF
EOF
)"
	[ -n "$(find "$patchdir" $findargs)" ] && {
		loop_yn "$delprompt" && rm -f "$patchdir"/*.patch || return
	}

	gitforpat -n "$patchdir" "$dnorighead"..
	return
}

#** show_tbackground
#
#  Globals:
#    tbackground
#    tb_light
#    tb_dark
#*
show_tbackground() {
	ui_log "show_tbackground"
	((tbackground == tb_dark)) && echo -n "Dark" ||
		                      echo -n "Light"
}

#** show_backport_mode: display the current backport mode
#
#  Globals:
#    backport_mode
#    bm_cherry
#    bm_apply
#    bm_apply3
#    bm_patch
#    bm_patch_merge
#*
show_backport_mode() {
	ui_log "show_backport_mode"
	case "$backport_mode" in
	    "$bm_patchpal"	) echo -e "${STA}patchpal$OFF"
				;;
	    "$bm_cherry"	) echo -e "${STA}git cherry-pick$OFF"
				;;
	    "$bm_apply"	        ) echo -e "${STA}git apply --reject$OFF"
				;;
	    "$bm_apply3"	) echo -e "${STA}git apply with 3-way merge$OFF"
				;;
	    "$bm_patch" 	) echo -e "${STA}patch$OFF"
				;;
	    "$bm_patch_merge"	)  echo -e "${STA}patch --merge$OFF"
	esac
}

#** show_options: display the options menu
#
#  Globals:
#    str_upstream
#    str_brew
#    str_test
#    str_jira
#    str_cve
#*
show_options() {
	ui_log "show_options"
	local options

	options=$(
cat <<EOF
$MNU
        ${UND}Options          $OFF
    $MNU u $OFF Upstream status          : $STA$str_upstream$OFF
    $MNU J $OFF JIRA link                : $STA$str_jira$OFF
    $MNU C $OFF CVE                      : $STA$str_cve
    $MNU b $OFF Brew or build info       : $STA$str_brew$OFF
    $MNU t $OFF Test information         : $STA$str_test$OFF
    $MNU p $OFF Patch subject prefix     : $STA$(git config format.subjectprefix)$OFF
    $MNU d $OFF Patch Directory          : $STA$patchdir$OFF
    $MNU B $OFF Backport Mode            : $STA$(show_backport_mode)$OFF
    $MNU c $OFF Change Terminal Colors   : $STA$(show_tbackground)$OFF
    $MNU q $OFF Quit to main menu
\0
EOF
)
	echo -e "$options"
}

#** input_oneopt: get one of the string options
#
# Arguments:
#   $1 - prompt string
#   $2 - option name by reference, so no leading $
#*
input_oneopt() {
	ui_log "input_oneopt"
	local prompt="$1"
	local -n getone_str="$2"
	local item="$2"
	local str
	local pstr

	ui_trunclog
	pstr="\n${INF}Press $qstr$INF to leave unchanged.\n"
	pstr+="Press$STA RETURN$INF with nothing to blank.\n"
	pstr+="Current value:$STA $getone_str$OFF\n$prompt"
	getuser "$pstr" str
	[ "$str" == "q" ] && return 1
	set_cfg_item "$item" "$str"
	getone_str="$str"
	return 0
}

#** get_options: parse the user's option entry
#
#  Globals:
#    str_upstream
#    str_brew
#    str_test
#    str_jira
#    str_cve
#
#  Returns 1 when user types 'q', else returns 0
#*
get_options() {
	ui_log "get_options"
	local opt=

	show_options
	"$promptgetkey_cmd" "${MNU}    Enter one of the above: $OFF" opt

	case $opt in
		J )	input_oneopt "${MNU}JIRA link: $OFF" "str_jira"
			;;
		C )	input_oneopt "${MNU}CVE: $OFF" "str_cve"
			;;
		u )     input_oneopt "${MNU}Upstream status: $OFF" "str_upstream"
			;;
		b )	input_oneopt "${MNU}Brew or build info: $OFF" "str_brew"
			;;
		t )	input_oneopt "${MNU}Testing info: $OFF" "str_test"
			;;
		p )	git_set_subjectprefix
			;;
		c )     ui_use_colors
			tbackground="$terminal_background"
			set_cfg_item "tbackground" "$tbackground"
			;;
		d )	get_patchdir
			;;
		B )	get_backport_mode
			;;
		q )	return 1
	esac

	return 0
}

#** options_looop: get the options until user types 'q'
#
#  Nothing complicated here. Basically an infinite loop with an
#  exit condition.
#*
options_loop() {
	ui_log "options_loop"
	while :; do
		get_options || return
	done
}

#** show_altopt: displays the Alt-Shift options
#
#  Arguments:
#    $1 - The option letter
#    $2 - The string that goes with it.
#*
show_altopt() {
	ui_log "show_altopt"
	local opt="$1"
	local str="$2"
	$ui_b_keypress || return 1
	echo -e "$CAU Alt-Shift-$opt $OFF$str"
	return 0
}

#** show_settings: display current settings and the main menu
#
#     ARGUMENTS:  none
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#                 dncurrenthead - current downstream head
#                 dnorighead - downstream head at new session start
#       RETURNS:  none
#*
show_settings() {
	ui_log "show_settings"
	# echo -e "$UND\0show_settings$OFF"
	local cols=$((tcols - menupad))
	local subjectprefix
	local lasttag
	local lastbrcmt
	local orighead=
	local settings

	subjectprefix="$(git config format.subjectprefix)"
	lastbrcmt="$(git log -n1 --oneline)"
	dncurrenthead="$(cut -d' ' -f1 <<< "$lastbrcmt")"
	[ -n "$dnorighead" ] && orighead="$(git log --oneline -n1 "$dnorighead")"

	settings=$(
cat <<EOF
$MNU
    ${UND}Upstream Environment    $OFF
$(show_upstream_commits_file)\
$(show_most_recent_backport)\
$(show_next_backport)

$MNU    ${UND}Downstream Environment  $OFF
    Current Head             : $STA${lastbrcmt:0:cols}$OFF
    Head at Session Start    : $STA${orighead:0:cols}$OFF
$MNU u $OFF Upstream repo directory  : $STA$updir$OFF
$MNU b $OFF Current git branch       : $STA$(get_gitbranch)$OFF
$MNU w $OFF Working directory        : $STA$workdir$OFF
$MNU B $OFF Backport method          : $(show_backport_mode)
$MNU O $OFF Options menu
$MNU
    ${UND}Control                $OFF
$MNU S $OFF Stop before              : $STA$stophash$OFF
$MNU P $OFF Create a patch series
$MNU N $OFF Start a New Session
$MNU H $OFF Show History
$MNU r $OFF Run all remaining commits
$MNU 1 $OFF Run the next commit and stop
$MNU s $OFF gort status
$MNU A $OFF Abort, reset to last good commit and clean status
$(show_altopt "R" "RESET to an earlier commit in this session ")
$MNU q $OFF Quit this tool
$MNU h $OFF Help
$OFF
EOF
)
# save for later
# $MNU V $OFF vim $STA$backportfile$OFF in a popup window

	echo -e "$settings"
}
## Deprecated menu items
## $(show_altopt "I" "Init or restart session")

#** menu_parser: parse the user input at the main menu
#
#     ARGUMENTS:  none, but lots of side effects
#       GLOBALS:
#         dncurrenthead
#         ui_b_keypress - defined in lib/keypress_support.soource
#       RETURNS:  rc_continue, used by menu_loop to determine whether to
#       	  continue looping.
#*
menu_parser() {
	# echo -e "$UND\0menu_parser$OFF"
	ui_log "menu_parser"

	local pops
	local setting=
	local -i retval

	validate_last_upstream_hash
	dncurrenthead="$(git rev-parse --short HEAD)"
	show_settings

	ui_trunclog
	"$promptgetkey_cmd" "${MNU}Enter one of the above: $OFF" setting
	retval=$?

	# keypress.c does not invoke SIGINT on ctrl-c, so test for it explicitly
	# when using keypress.
	$ui_b_keypress && [ "$setting" == $'\003' ] && ctrl_c

	case $setting in

		b )	select_gitbranch
			;;
		w )	input_dir "working" "workdir" workdir
			;;
		f )	input_backportfile
			;;
		u )	input_dir "Upstream repo directory" "updir" updir
			;;
		c )	set_next_backport
			;;
		N )	read_session; init_newsession
			;;
		H )	show_history
			;;
		h )	ptpage -b "$tbackground" "$MYHLP"
			;;
		q )	exit_gort $exit_good
			;;
		r )	run_me
			b_new=false
			;;
		O )	options_loop
			;;
		S )	getuser "${MNU}Stop before this hash: $OFF" stophash
			cfg_set_item "stophash" "$stophash"
			;;
		P )	create_patches
			;;
		1 )	run_me 1
			;;
		s )	b_statflag=true; show_status; b_statflag=false
			;;
#		V )	ui_popterm "vim $backportfile"
#			;;
#		I )	((retval == 1)) || return $rc_continue
#			init_current_session
#			;;
		R )	((retval == 1)) || return $rc_continue
			reset_gort
			;;
#		U )	update_gort
#			;;
		A )	abort_gort
			;;
		B )	get_backport_mode
	esac
	return $rc_continue
}

#** menu_loop: present the menu until user quits
#
#     ARGUMENTS:  none, but lots of side effects
#       GLOBALS:  workdir
#                 cmtmsgfile
#                 backportfile
#       RETURNS:  stat, which is the value returned by the call to menu_parser
#*
menu_loop() {
	ui_log "menu_loop"
	local stat=0

	cfg_update_configfile
	while :; do

		menu_parser
		stat=$?
		# echo "menu_parser_stat: $stat"
	done
	return $stat
}

#** edit_commit: Loop through process to edit commit message until done
#
#     ARGUMENTS:  none
#       GLOBALS:  cmtmsgfile
#       RETURNS:  none
#*
edit_commit() {
	ui_log "edit_commit"
	local yup

	while :; do
		# Display the git log message and inquire if it needs more
		# editing.
		#
		git log -n1 > "$cmtmsgfile"
		cat "$cmtmsgfile"
		echo

		getyn "Edit this commit message?" yup

		if $yup; then git commit --amend; else break; fi
	done
}

#** check_state - first thing before anything
#
# Globals
#
# Arguments
#
#*
check_state() {
	ui_log "check_state"
}

#** clean_status - abort everything and leave git status clean
#
# Globals
#
# Arguments
#*
clean_status() {
	ui_log "clean_status"
	git cherry-pick --abort > /dev/null 2>&1
	git checkout . > /dev/null 2>&1
	git clean -fd > /dev/null 2>&1
}


#** abort_gort: abort the current backport/apply and exit
#
#  This will clear conflicts flag and abort the pending backport
#
#     ARGUMENTS:  none
#
#       GLOBALS:  b_conflict
#                 b_cmdline
#                 upcmtstartline
#
#       RETURNS:  none
#*
abort_gort() {
	ui_log "abort_gort upcmtstartline:$upcmtstartline b_conflict:$b_conflict"
	local cmt

	clean_status

	# Get the last succesful commit and git reset to it.
	cmt="$(gitnice | cut -d' ' -f1)"
	git reset --hard "$cmt"

	upcmtstartline=1
	cfg_set_item "b_conflict" "$b_conflict"
	cfg_set_item "upcmtstartline" "$upcmtstartline"
	get_current_backport

	$b_cmdline && exit_gort $exit_good || return
}

#** get_newhead: choose from the heads since dnorighead
#
# Globals:
#   dnorighead    - result of 'git merge-base HEAD <origin-branch-name>'
#   dncurrenthead - this will be modified if caller selects different head
#*
get_newhead() {
	ui_log "get_newhead dnorighead:$dnorighead dncurrenthead:$dncurrenthead"
	local -a dncmtary=()
	local new
	local hashsize
	local addlprompt
	local tmp
	local spc
	local count
	local mypid
	local tmpfile

	# Get the number of commits made after dnorighead and notify
	# user.
	count=$(git rev-list --count "$dnorighead"..HEAD)
	echo -e "$INF
There are $STA$count$INF commits since Head at Session Start: $STA$dnorighead$INF"

	# Get the downstream and upstream commits in a spawned process and
	# save it to a named pipe.
	tmpfile=$(mktemp)
	extup -m "$dnorighead^..HEAD" > "$tmpfile" & mypid=$!
	ui_waitonproc_tty "$mypid" 0.05 "${INF}Getting the list of commits...$OFF"
	mapfile -t dncmtary < "$tmpfile"
	rm -f "$tmpfile"

	# Create space strings based on the sizes of the hashes.
	# These will be used to correctly align the column headings in the
	# selection menu.
	tmp="$(cut -d' ' -f1 <<< "${dncmtary[0]}")"
	hashsize="${#tmp}"
	spc="$(printf "%*c" $((hashsize - 12)) " ")"

	select_from_array dncmtary "Dn Commits" new \
		"      $MNU${UND}Dn Commits$spc$OFF  $MNU${UND}Up Commits$spc$OFF" || return 1

	# Set the new downstream current head global
	dncurrenthead="$(cut -d' ' -f1 <<< "$new")"
	# Normalize the hash length.
	dncurrenthead=$(git rev-parse --short "$dncurrenthead")
	return 0
}

#** update_gort: update the Head at Session Start to Current downstream head
#
# If the git index has been updated with a git pull or creation of a new
# branch, this will update the Head at Session Start to the current
# downstream head, after resetting all the markers in the backportfile.
# Basically, gort_reset, but without offering a choice, because there are
# likely hundreds of commits since the last downstream pull.
#
# Globals:
#   dnorighead
#   dncurrenthead
#   backportfile
#
# Arguments
#   none
#
# Returns
#   none
#*
update_gort() {
	ui_log "update_gort dnorighead:$dnorighead dncurrenthead:$dncurrenthead"
	clean_status
	clear_alldone
	dnorighead="$dncurrenthead"
	set_cfg_item "dnorighead" "$dnorighead"
	linenumber=1
	b_conflict=false
	b_lasthashvalid=false
	upcmtstartline=0
	get_next_backport

	$b_cmdline && exit_gort $exit_reset || return
}

#** reset_gort: reset the current downstream HEAD to an earlier commit
#
# If the current downstream HEAD is not at the original downstream HEAD, then
# the user is presented with a list of downstream commits and corresponding
# upstream commits. If the user chooses an earlier commit from the list, the
# downstream commit will be reset to that point, and the upstreamcommitsfile
# will be updated. It will appear as if those later commits have not yet been
# made.
# This is useful if things go over the edge, and you need to backtrack.
#
#     ARGUMENTS:  none
#       GLOBALS:  dnorighead
#                 dncurrenthead
#                 backportfile
#       RETURNS:  none
#*
reset_gort() {
	ui_log "reset_gort dnorighead:$dnorighead dncurrenthead:$dncurrenthead"
	local -a clrary=()
	local linenumber

	clean_status

	# Reset: Clear the leading "+ " from the lines in the upstreamcommitsfile to
	# indicate that the corresponding upstream commits are not applied.
	# We are backtracking.
	# If the user chose the original head, resetting it back to the beginning,
	# then clear all the done markers, else just clear the ones that we are
	# retreating from.
	get_newhead || return

	if [ "$dnorighead" == "$dncurrenthead" ]; then
		linenumber=1
	else
		mapfile -t clrary < \
			<(extup -m -b "$dncurrenthead"^.. | cut -d' ' -f1)
		# Get the last element in the array
		linenumber=$(grep -n -m1 "${clrary[@]: -1}" "$backportfile" | cut -d: -f1)
		((++linenumber))
	fi

	# Use sed to remove the done mark from the line number
	sed -i "${linenumber},\$s|^+ ||" "$backportfile"

	# Reset to the new head, and get the next backport.
	git reset --hard "$dncurrenthead"
	b_conflict=false
	set_cfg_item b_conflict "$b_conflict"
	b_lasthashvalid=false
	upcmtstartline=0
	get_next_backport

	$b_cmdline && exit_gort $exit_reset || return
}

#** run_continue: continue backporting after resolving conflicts
#
#  Assumes that changes were made and committed externally to this script.
#
#     ARGUMENTS:  none
#       GLOBALS:  b_conflict
#       RETURNS:  none
#*
run_continue() {
	# echo -e "$UND\0run_continue$OFF"
	ui_log "run_continue"

	local statstr
	local gitstat

	statstr=$(
cat <<EOF
$INF
You have made changes that must be committed before using "gort continue".
You can use "gort commit" if you want gort to make these commits for you.
$OFF
EOF
)
	# If the working tree is not clean, commit your changes before
	# useing gort continue or use git commit.
	git diff-index --quiet HEAD -- || {
		echo -e "$statstr"
		git status
		exit $exit_pending
	}

	edit_commit
	b_conflict=false
	get_next_backport
	run_me
}

#** run_commit: return from resolving conflicts, but let the script commit
#
#  Script will commit and create the commit log from the conflicthash.
#
#     ARGUMENTS:  $1 if == "ONE" run one and exit
#       GLOBALS:  currentuphash
#                 conflicthash
#                 b_conflict
#                 exit_nothing
#                 exit_good
#       RETURNS:  none
#*
run_commit() {
	ui_log "run_commit arg1:$1 currentuphash:$currentuphash conflicthash:$conflicthash"

	currentuphash="$conflicthash"	# get the stored conflict hash
	b_conflict="$(get_cfg_item b_conflict)"

	# If are no changes to commit, let the user know there's nothing
	# to commit, else stage the commit and continue.
	if git diff-index --quiet HEAD -- ; then
		echo -e "\n${CAU}There is nothing to commit.$OFF"
	else
		conflicthash=		# null out the stored conflict hash
		set_cfg_item "conflicthash" "$conflicthash"
		stage_commit
		mark_done $currentuphash
	fi

	b_conflict=false
	$b_one && exit_gort $exit_good
	get_next_backport
	b_cmdline=false
	menu_loop
}

#** run_single: just backport one commit
#
#     ARGUMENTS:  none
#       GLOBALS:  currentuphash
#                 b_single
#       RETURNS:  none
#*
run_single() {
	ui_log "run_single"
	local stat

	echo -e "$UND\0run_single$OFF"
	b_single=true

	set_cfg_item "lastuphash" "$currentuphash"

	backport
	stat=$?
	exit $stat
}

#** mark_out: mark the line with a leading #
#
# Globals
#   backportfile
#
# Arguments
#   1 - uphash
#   2 - optional user supplied mark
#
#*
mark_out() {
	ui_log "mark_out uphash: $1 mark:${2:-'+'}"
	local uphash="$1"
	local mark="${2:-#}"	# the default leading char is +

	[ -f "$backportfile" ] || return 1
	sed -i "s/^$uphash/$mark $uphash/" "$backportfile" || return 1
	return 0
}


#** mark_done: mark the line with a leading +
#
#  Indicates the upstream hash in this line of the backport commits file has
#  been backported.
#
#     ARGUMENTS:  $1 - uphash
#    		  $2 - optional user supplied mark
#       GLOBALS:  backportfile
#       RETURNS:  0 on success, nonzero on fail
#*
mark_done() {
	ui_log "mark_done uphash: $1 mark:${2:-'+'}"
	local uphash="$1"
	local mark="${2:-+}"	# the default leading char is +

	[ -f "$backportfile" ] || return 1
	sed -i "s/^$uphash/$mark $uphash/" "$backportfile" || return 1
	return 0
}

#** clear_done: clear "done" mark for line having given hash in backportfile
#
#     ARGUMENTS:  $1 - uphash
#    		  $2 - optional user supplied mark
#       GLOBALS:  backportfile
#       RETURNS:  0 on success, nonzero on fail
#*
clear_done() {
	ui_log "clear_done uphash: $1 mark:${2:-'+'}"
	local uphash="$1"
	local mark="${2:-+}"	# the default leading char is +

	[ -f "$backportfile" ] || return 1
	sed -i "s/^$mark $uphash/$uphash/" "$backportfile" || return 1
	return 0
}

#** clear_alldone: clear all the done marks in the backportfile
#
#          NAME:  clear_alldone
#   DESCRIPTION:  Clear the "done" mark for the line in the backportfile
#                 corresponding to the hash passed.
#     ARGUMENTS:  $1 - optional user supplied mark
#       GLOBALS:  backportfile
#       RETURNS:  0 on success, nonzero on fail
#*
clear_alldone() {
	ui_log "clear_alldone mark:${1:-+}"
	local mark="${1:-+}"	# the default leading char is +
	local markstr=

	[ -f "$backportfile" ] || return 1
	markstr="$mark "	# add the trailing space
	sed -i "s|^$markstr||g" "$backportfile" || return 1
	return 0
}

#** flag_conflict - print conflit message and status
#
# Globals
#   patchlog
#   b_conflict
#
# Arguments
#   1 - uphash - the conflicted commit
#*
flag_conflict() {
	ui_log "flag_conflict uphash:$1"
	local uphash="$1"
	local patch=
	local dashpad=
	local patpad=
	local patcmt=
	local b_patvalid=false
	local b_notsame=false

	b_conflict=true
	set_cfg_item "b_conflict" "$b_conflict"

	# We need to check the patch that was saved to see if it's the same as
	# the one for this conflict commit.
	#
	patch="$(get_cfg_item "patfil")"

	# If the patchfile exists, then extract the upstream commit field.
	if [ -f "$patch" ]; then
		patcmt="$(cut -d' ' -f2 < <(head -1 "$patch"))"
		# Verify that it's a valid commit
		git_upcmd "verify" "$patcmt" && b_patvalid=true || b_patvalid=false
	fi

	# If it's a valid commit, see if it's the same as the "$uphash" conflict.
	if $b_patvalid; then
		[ "$(git_upcmd parse "$patcmt")" != "$(git_upcmd parse "$uphash")" ] \
			&& b_notsame=true || b_notsame=false
	fi

	# If the commit hash in the existing file is not valid, or if it's
	# valid but not the same as the current conflict uphash, then
	# delete the old one and create a new one from the uphash conflict
	# commit.
	if ! $b_patvalid || $b_notsame; then
		ui_log "flag_conflict: creating new patch file"
		# Remove any patches in the workdir
		shopt -s extglob
		rm -f "${workdir%/}"/*.patch
		shopt -u extglob

		# Create the patch for this conflict
		patch="$(git_upcmd "format" "$uphash")"
		set_cfg_item "patfil" "$patch"
	fi

	patpad="$(printf '%*s\n' "${#patch}" "" | tr ' ' '-'})"
	dashpad="$(printf '%*s\n' "${#patchlog}" "" | tr ' ' '-'})"

	echo -e "
$CAU${UND}There are conflicts$INF

${CAU}The offending patch is in:
$STA$patch$OFF
$patpad
${CAU}grep the Patch Log for details:$OFF
$STA$patchlog$OFF
$dashpad$INF
Type ${CAU}gort abort$INF to restore your repo to the state it was in \
before the conflict.$OFF
     -----------$INF
After fixing the conflicts, you can reenter gort with the following commands.
${STA}gort commit$INF   : if you have fixed the conflicts and want the script to stage
                 the commit and create the commit log for you.
${STA}gort continue$INF : if you have fixed the conflicts and made the commit externally
                 and wish to continue with the next backport commit.$OFF
"
	exit_gort $exit_conflict
}

#** backport: backport the upstream commit in uphash
#
#     ARGUMENTS:  none
#       GLOBALS:  backportfile
#                 commit
#                 tcols
#                 currentuphash
#                 lastuphash
#                 b_conflict
#                 b_single
#       RETURNS:  non-zero if something went wrong
#*
backport() {
	ui_log "backport"
	# echo -e "$UND\0backport$OFF"

	local uphash=$currentuphash
	local stat
	local wcols=$((tcols - 10))
	local untracked
	local b_setexit=false
	commit=$(git_upcmd "nice" "$uphash")

	echo -e "${INF}Processing : $STA${commit:0:$wcols}$OFF"

	# If this upstream commit has already been applied, return now.
	is_backport_done && {
		echo -e "$STA$uphash$INF already committed.$OFF"
		mark_done "$uphash"
		set_cfg_item "lastuphash" "$uphash"
		return 0
	}

	# Prepare the patchlog. It will be refreshed for every patch applied.
	date '+%Y-%m-%d %H:%M:%S' > "$patchlog"
	echo "backport mode: $(show_backport_mode)" >> "$patchlog"

	case "$backport_mode" in
	    "$bm_cherry" )
		if $b_nit; then
			git cherry-pick -n "$uphash" >> "$patchlog" 2>&1
		else
			git -c merge.renameLimit=1 cherry-pick -x \
				"$uphash" >> "$patchlog" 2>&1
		fi
		;;
	    "$bm_patchpal" ) patchpal "$uphash"
		;;
	    "$bm_apply" )
		git apply --reject < <(git show "$uphash") >> "$patchlog" 2>&1
		;;
	    "$bm_apply3" )
		git apply -3 < <(git show "$uphash") >> "$patchlog" 2>&1
		;;
	    "$bm_patch" )
		patch --batch --verbose \
			-p1 < <(git_upcmd show "$uphash") >> "$patchlog" 2>&1
		;;
            "$bm_patch_merge" )
                patch --batch --verbose --merge \
			-p1 < <(git_upcmd show "$uphash") >> "$patchlog" 2>&1
                ;;
	esac

	stat=$?

	# Check for errors
	# git cherry-pick returns:
	#    0 all good
	#    1 conflicts or other problems
	#    128 fatal, invalid arg, missing patch, or repo corruption
	#
	# patch returns
	#    0 all good
	#    1 conflicts
	#    2 patch cannot be applied at all
	#
	(($stat > 1)) && exit_gort $exit_bogus "$CAU$err$OFF"

	# If the backport wants to add a new file to the index, or if the
	# backport exited with a nonzero status greater than 1, then we
	# must report the conflict and stop.
	untracked="$(git ls-files --others --exclude-standard)"

	if [ -n "$untracked" ] || ((stat != 0)); then
		ui_log "backport: conflict"
		b_setexit=true
		b_conflict=true
		$b_single && git status && exit $exit_conflict
		conflicthash=$uphash
		set_cfg_item "conflicthash" "$conflicthash"
		# echo -e "Saving: $BLD${commit:0:$wcols}$OFF"
		show_status internal
		flag_conflict "$uphash"
	fi

	# We process differently for patchpal.
	# If stage_patchpal doesn't return 0, then return with its status.
	if ((backport_mode == bm_patchpal )); then
		stage_patchpal || return $?
	else
		stage_commit
	fi

	get_lastuplog		# inits lastuphash from backport file
	return 0;
}

#** stage_commit: process the commit that was backported
#
#  Create the git log for the backported commit, including JIRA number, upstream
#  and brew info, if any.
#  Query the user to see if editing the commit is warranted, for conflicts, etc.
#
#     ARGUMENTS:  none
#       GLOBALS:  b_conflict
#		  cmtmsgfile
#		  str_jira
#		  str_cve
#		  str_upstream
#		  str_conflicts
#       RETURNS:  0 all good
#                 1 for patchpal retry
#*
stage_commit() {
	ui_log "stage_commit"
	local description
	local uphash=$currentuphash
	local uplog
	local b_crlf=false
	local b_committed=false	# committed externally to stage_commit

	# If this upstream commit has been committed external to stage_commit,
	# then flag it.
	#
	is_backport_done && {
		echo -e "$STA$uphash$INF was committed externaly.$OFF"
		b_committed=true
	}

	# Create the new commit message in a file consisting of ..
	#	The user of this script as author of the patch
	#	The current date
	#	Descriptor line, with leading whitespace trimmed
	#	Bugzilla and brew if available
	#	Upstream status if available
	#	Original commit message from applied commit
	#	Signed-off-by: line
	#
	echo -e "\n" > "$cmtmsgfile"

	set -f	# disable wildcard

	# Get the upstream commit log and extract the description
	# from the fifth line.
	#
	uplog="$(git_upcmd log "$uphash")"
	description=$(sed -n '5p' <<< "$uplog")

	# Trim leading whitespace from description line and append
	# it to the commit message. Also append the standard commit
	# message.
	#
	description=$(echo -e $description)

	echo -e "$description\n" >> "$cmtmsgfile"
	[ -n "$str_jira" ] && {
		echo -e "JIRA: $str_jira" >> "$cmtmsgfile"
		b_crlf=true
	}
	[ -n "$str_cve" ] && {
		echo -e "CVE: $str_cve" >> "$cmtmsgfile"
		b_crlf=true
	}
	[ -n "$str_upstream" ] && {
		echo -e "Upstream status: $str_upstream" >> "$cmtmsgfile"
		b_crlf=true
	}
	$b_crlf && echo >> "$cmtmsgfile"

	set +f	# re-enable wildcards

	$b_conflict && echo -e "$str_conflicts" >> "$cmtmsgfile"

	# Append the original commit message.
	#
	echo "$uplog"  >> "$cmtmsgfile"

	# If the uphash has NOT been committed anywhere, then do that now.
	#
	! $b_committed && {
		# Only use git add . if there are untracked
		# files. It saves time to use git add -u, because the git
		# logic won't waste time looking for untracked files.
		# git ls-files is much faster.
		#
		[ -n "$(git ls-files --others --exclude-standard | head -n 1)" ] \
			&& git add . \
			|| git add -u
		git commit -a -m"hold" > /dev/null 2>&1
	}

	# Amend the commit messsage with you as author, using the
	# commit message file we built in the previous few lines,
	# and a Signed-off-by: ("-s") line.
	#
	git commit -s --amend --reset-author --file="$cmtmsgfile"

	# If there are conflicts, give the user the option to edit
	# the commit log.
	#
	$b_conflict && edit_commit

	# Mark this done when we know it's done.
	mark_done "$uphash"

	b_conflict=false
}

#** stage_patchpal: process the commit that was backported
#
#  Create the git log for the backported commit, including JIRA number, upstream
#  and brew info, if any.
#  Query the user to see if editing the commit is warranted, for conflicts, etc.
#
#     ARGUMENTS:
#
#       GLOBALS:  cmtmsgfile
#		  str_jira
#		  str_cve
#		  str_upstream
#		  str_conflicts
#       RETURNS:  0 if all is well
#                 1 for patchpal not done
#*
stage_patchpal() {
	ui_log "stage_patchpal"
	local description=
	local uphash=$currentuphash
	local -i line=

	# If the backport was not completed, then tell the user and
	# try again.
	is_backport_done || {
		echo -e "${CAU}
patchpal$INF backport of $STA$uphash$INF was not completed.
You must press \"${STA}Accept$INF\" and \"${STA}Commit$INF\" in the \
patchpal tool dialog in order
to proceed to the next upstream commit.
You can press$CAU ctrl-c$OFF any time to safely exit.
$OFF"
		return 1
	}

	set -f	# disable wildcards
	git log -1 > "$cmtmsgfile"

	# Find the second instance of "commit <40-char-hash> in the
	# git log. This is where the upstream commit log is appended
	# to this downstream commit log.
	line=$(grep -n -E -m2 '^[[:space:]]*commit [0-9a-fA-F]{40}$' "$cmtmsgfile" \
		| tail -n1 | cut -d: -f1)

	# Insert new stuff above this line, so backup one.
	line=$((line - 1))

	description="
"

	[ -n "$str_jira" ] && {
		description+="JIRA: $str_jira
"
		b_crlf=true
	}
	[ -n "$str_cve" ] && {
		description+="CVE: $str_cve
"
		b_crlf=true
	}
	[ -n "$str_upstream" ] && {
		description+="Upstream status: $str_upstream
"
		b_crlf=true
	}
	$b_crlf && description+="
"
	export ins="$description"
	gawk -i inplace -v target="$line" '
	{
	  if (NR == target) {
	    # Insert the text from ENVIRON["ins"] before printing the current line
	    printf "%s", ENVIRON["ins"];
	    # Delete the variable so it isn’t printed again
	    delete ENVIRON["ins"];
	  }
	  print;
	}
	' "$cmtmsgfile"

	set +f	# re-enable wildcards
	mark_done "$uphash"
	return 0
}

#** is_backport_done
#
# Tests whether the upstream backport was done.
#
# Globals
#   currentuphash - the upstream commit hash being backported
#
# Returns
#   0 - if upstream backport was completed
#   1 - if not
#*
is_backport_done() {
	local uphash="$currentuphash"

	# Following line returns 0 if the upstream commit has already been
	# backported by doing a dry run of reversing the upstream commit
	# as a patch.
	# If the test shows that it can be reversed, then the backport of
	# that upstream hash is done, so it will return 0.
	# It the test shows that the patch cannot be reversed, then it
	# will return a 1, indicating that the backport was not done.
	#
	git apply --reverse --check  < <(git show "$uphash") > /dev/null 2>&1
	return $?
}

#** is_upcmt_marked
#
# Look int the backports file to see if the current upstream hash has been
# marked as done.
#
# Globals
#   currentuphash
#   backportfile
#
# Returns
#   0 - if marked done
#   1 - if not
#*
is_upcmt_marked() {
	[ -f "$backportfile" ] || return 0
	grep -E "^\+ ${currentuphash}\b" "$backportfile"
	return $?
}

#** set_cfg_item key value: writes the value to the key in the .conf file
#
# Arguments:
#   $1 - key
#   $2 - value
#*
set_cfg_item() {
	cfg_write_key "$1" "$2"
}

#** get_cfg_item key: echoes the value at the key offset in the .conf file
#
# Arguments:
#   $1 - the key in the config file to read
#
get_cfg_item() {
	cfg_read_key "$1"
}

#** get_originhead: get the HEAD of the downstream origin
#
# Get the original head by getting the commit where the current
# branch diverged from main
#
# Globals
#   dnorighead
#*
get_originhead() {
	ui_log "get_originhead"
	dnorighead="$(get_cfg_item dnorighead)"
}

#** get_x11devel - dnf install libX11-devel if possible
#
get_x11devel() {

	# No libX11-devel present, so we will have to install.
	# Before we can try to dnf install libX11-devel, we need to know
	# if user has superuser privileges.
	sudo -n true || {
		echo -e "
$CAU$USER$INF does not have privileges to install libx11-devel$OFF
"
		return 1
	}

	# If the user has sudoer privileges, let's install libX11-devel.
	sudo dnf install -y libX11-devel || {
		echo -e "\n${CAU}Could not dnf install$STA libX11-devel$OFF\n"
		return 1
	}

	return 0
}

#** is_xrunning - determine if x is running
#
# X needs to be running so that the application's windows can materialize
# somewhere. If we don't have the homegrown binary that detects whether X
# is running, then compile it on the fly.
#
# Globals
#
# Arguments
#
#*
is_xrunning() {
	local xtest_c="$MYDIR/x_test.c"
	local xtest_bin="$MYDIR/x_test"

	# If we don't already have the xtest binary, then build it.
	[ -x "$xtest_bin" ] || {
 
		# Before we build it, we need to be certain that we have the
		# libX11-devel first, and, if we don't, the user has sudoer
		# privs to dnf install it.
		rpm -q libX11-devel > /dev/null 2>&1 || get_x11devel

		# Write the C code to a file
cat << 'EOF' > "$xtest_c"
#include <X11/Xlib.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    Display *dpy = XOpenDisplay(NULL);
    if (dpy) {
	XCloseDisplay(dpy);
	return 0;  // X is available
    }
    return 1;  // No X server
}
EOF
		# Compile the program (you can change gcc options as needed)
		gcc "$xtest_c" -o "$xtest_bin" -lX11 >/dev/null 2>&1
	}

	# Check if the binary exists and is executable, then run it.
	if "$xtest_bin"; then
	    echo "X server is available."
	else
	    echo "No X server found."
	fi
}

#** check_X - simple X check to see if we have a display0
#
# Globals
#
# Arguments
#*
check_X() {
	[ -n "$DISPLAY" ] && return 0
	echo -e "$CAU
No X DISPLAY detected.$INF
You cannot use patchpal for backporting without an X DISPLAY.$OFF
"
	return 1
}

#** get_backport_mode: choose which of the availiable backport modes to use
#
# Globals
#   backport_mode
#*
get_backport_mode() {
while :; do
	ui_log "get_backport_mode"
	echo
	echo -e "    ${INF}Which backport mode do you want to use?$MNU"
	echo -e "      1.$OFF patchpal$MNU"
	echo -e "      2.$OFF git cherry-pick, leaves conflict markers$MNU"
	echo -e "      3.$OFF git apply --reject, with .rej files to peruse$MNU"
	echo -e "      4.$OFF git apply with 3-way merge$MNU"
	echo -e "      5.$OFF patch with reject files$MNU"
	echo -e "      6.$OFF patch --merge, use conflict markers instead of rej files$OFF"

	loop_range $bm_lower $bm_upper  backport_mode

	# We need to special case patchpal mode, because you need to be
	# running X to use it.
	# Works fine with VNC, so you can still be remote, as long as you
	# launce an X-client that can handle it, like VNC.
	#
	if ((backport_mode == bm_patchpal)); then
		check_X && break || continue
	fi
	break
done
	set_cfg_item "backport_mode" "$backport_mode"
}

#** save_session: save session's config variables to the .conf file
#
#          NAME:  save_session
#   DESCRIPTION:  Save session's project variables to the project file.
#     ARGUMENTS:  $1 is not empty if this is an status call
#       GLOBALS:  backportfile
#                 upcmtstartline
#                 All the sticky project variables
#       RETURNS:  none
#*
save_session() {
	# echo -e "$UND\0save_session$OFF"
	ui_log "save_session"
	local -a keys=()
	local fd
	exec {fd}< "$configfile"
	while IFS+="=" read -ru $fd key; do
		key="$(echo "$key" | cut -d' ' -f1)"
		set_cfg_item "$key" "${!key}"
	done
	exec {fd}<&-
}

#** read_session: read the config variables out of the .conf file
#
#
#  Read the variables stored in the .conf file Some project variables are
#  updated elsewhere, and only need to be retrieved at init time and saved at
#  exit time.
#
#     ARGUMENTS:  none
#       GLOBALS:  workdir
#                 backportfile
#                 upurl
#                 tbackground
#       RETURNS:  1 if any of the important conf values are missing
#                 0 otherwise
#*
read_session() {
	# echo -e "$UND\0read_session$OFF"
	ui_log "read_session"
	local cfgtemplate=

	# Initialize the paths for the current working directory
	#
	[ -d "$MYDATA" ] || mkdir -p "$MYDATA"
	configfile="$MYDATA/gort.conf"
	cfgtemplate="$MYLIB/gort.conf"

	# This call will init all the global variables with the values stored
	# in .data/gort.conf
	cfg_start "$cfgtemplate" "$configfile"

	# If the background value saved in the conf file is not valid, then
	# call to determine the background color

	if ((tbackground < tb_lite || tbackground > tb_dark)); then
		ui_setbg tbackground
		cfg_set_item "tbackground" "$tbackground"
	else
		ui_do_colors "$tbackground"
	fi

	# backport_mode enumeration
	#
	enum "bm" \
		patchpal \
		cherry \
		apply \
		apply3 \
		patch \
		patch_merge

	return 0
}

#** check_gitbranch - are we running on the same git branch as last time?
#
# If we are running on the same branch as before, no problem. Just return
# If we are not, try to checkout the last branch we were running on.
# If we can't do that, give the user the option to exit or to select a
# different branch. In either case, the backport file must not have any
# "done" marks in it.
#
# Globals
#   backportfile
#
# Arguments
#
#*
check_gitbranch() {
	ui_log "check_gitbranch backportfile:$backportfile"
	local cbranch	# current branch
	local sbranch	# saved branch

	cbranch="$(git rev-parse --abbrev-ref HEAD)"
	sbranch="$(get_cfg_item gitbranch)"

	[[ $cbranch == $sbranch ]] && return 0
	git checkout "$sbranch" 2> /dev/null && return 0

	# Okay, not the same branch, and previous branch is no longer valid.
	# Clear all done markers in the backport file.
	[ -f "$backportfile" ] && clear_alldone
	echo -e "$CAU
git cannot checkout branch: $STA$sbranch$INF"
	[ -n "$timestamp" ] && echo -e "${INF}\
This session started with that branch on: $STA$timestamp$INF"
	echo -e "$INF
Enter$CAU ctrl-c$INF to exit now, or any other key to select from a list
of available branches.$OFF"
	ui_press_any_ctlc
	select_gitbranch
}

#** check_repostate - is_repo_consistent?
#
# This function will clear all the "done" markers in the backport file if
# the original branch is no longer valid.
#
# Returns
#   0 - if last upstream commit in the backport file is the same as the
#       the upstream commit in the commit log of the most recent downstream
#       commit.
#   1 - If not the same
#
# Globals
#   backportfile
#
# Arguments
#
#*
check_repostate() {
	ui_log "check_repostate backportfile:$backportfile"
	local uphash
	local exhash
	local currenthead

	currenthead="$(git rev-parse --short HEAD)"

	# Find the last backported upstream commit in the backport file
	uphash="$(tac "$backportfile" | \
		grep -m 1 '^+' | sed 's/^\+\s*\([^[:space:]]*\).*/\1/')"

	# Extract the upstream commit from the first commit log in the
	# downstream repo
	exhash="$(extract_upcmt)"

	[[ $uphash == $exhash ]] && return 0

	[ -n "$exhash" ] && {
		starterr+="$CAU
Inconsistent state: $STA$uphash$INF in $STA$backportfile$INF
is not the same as: $STA$exhahs$INF in git HEAD: $STA$currenthead$INF
See Upstream Backports file: $STA$backportfile$OFF"
		return 1
	}

	starterr+="$CAU
Inconsistent state:$INF The current HEAD: $STA$currenthead$INF was not backported
from upstream.
See Upstream Backports file: $STA$backportfile$OFF"
	return 1
}

#** init_common: common to all init calls
#
#     ARGUMENTS:  none
#     GLOBALS:
#         updir - directory containing the upstream repo
#         workdir - scratch directory for gort
#         upcmtstartline - start line in the backport file, saved in config
#         backportfile - list of upstream commits to be backported
#         b_new - indicates new session
#         mirror - mirror of the upstream repo
#         patchlog - file to capture patch activity in backport function
#         cmtsmsgfile - a temp file to form commit messages
#     RETURNS:  none
#*
init_common() {
	# echo -e "$UND\0init_common$OFF"
	ui_log "init_common backportfile:$backportfile upcmtstartline:$upcmtstartline"
	local loc_main
	local rem_main

	# workdir was declared in init_newsession() or read from the config
	# file by read_session, called before this.
	cmtmsgfile="$workdir/.gcpgitlog"
	patchlog="${workdir%/}/patch.log"

	((backport_mode >= bm_lower && backport_mode <= bm_upper)) || {
		get_backport_mode
	}

	# The mirror repo is going to be parallel to the upstream repo.
	# If it's not there, create it.
	mirror="$(realpath "${updir%/}/../mirror")"
	[ -d "$mirror" ] || mkdir -p "$mirror"

	# Shared upstream repo housekeeping.
	#
	git --git-dir="$mirror" rev-parse --is-bare-repository > /dev/null 2>&1 || {
		ui_log "init_common: git clone --mirror $updir $mirror"
		git clone --mirror "${updir%/}" "${mirror%/}"
	}

	# Update the mirror
	gu_pushd "$mirror"
	ui_log "init_common: git fetch origin --prune"
	git fetch origin --prune
	gu_popd

	# If we don't have a reference to the upstream mirror yet, then
	# add it.
	if ! git config --get remote.mirror.url > /dev/null; then
		ui_log "init_common: remote add mirror $mirror"
		git remote add mirror "$mirror"
	fi

	# Check for updates in the mirror.
	#
	rem_main=$(git --git-dir="${mirror%/}" rev-parse refs/heads/master 2>/dev/null)
	loc_main=$(git for-each-ref --format='%(objectname) %(refname)' refs/remotes/mirror/ | \
		awk '$2 ~ /(heads\/)?master$/ {print $1; exit}')

	local infostr="$INF
If this is the first time running this script in this directory, or
if there have been significant changes upstream since you last used
it, please allow a couple minutes to fetch the upstream mirror.
You will not need to add the upstream kernel as a remote, since your
existing upstream kernel in $STA$updir$INF will be mirrored in
$STA$mirror$INF"

	if [ "$rem_main" != "$loc_main" ]; then
	    echo -e "$infostr"
	    ui_log "Master branch updated; fetching changes..."
	    git fetch mirror --prune
	fi

	check_gitbranch
	check_repostate

	$b_new && {
		# The "Head at Session Start" will be the current HEAD
		dnorighead="$(git rev-parse --short HEAD)"
		set_cfg_item dnorighead "$dnorighead"
		upcmtstartline=1
	}

	get_current_backport

	# If it's not a new session, and we don't have any conflicts, get the
	# last successfully backported commit.
	#
	($b_new || $b_conflict) || get_lastuplog
	b_session_inited=true
}

#** init_cmdline_call: for command line invocations
#
#     ARGUMENTS:  none
#       RETURNS:  none
#*
init_cmdline_call() {
	# echo -e "$UND\0init_cmdline_call$OFF"
	ui_log "init_cmdline_call"

	local stat
	local newstr="${INF}Please type $MNU$MYNAME new$INF to start.$OFF\n"

	read_session

	# If any one of workdir, updir, or backportfile is missing, then this
	# is a new session, so set $b_new true.
	#
	([ -d "$workdir" ] && [ -f "$backportfile" ] && is_valid_gitdir "$updir") ||
		init_newsession
	init_common
}

#** init_session: init config variables from the .conf file
#
#     ARGUMENTS:  none
#       GLOBALS:  All sesson variables are affected
#       RETURNS:  none
#*
init_session() {
	# echo -e "$UND\0init_session$OFF"

	read_session
	init_common
	# $b_cmdline && exit_gort $exit_good
}

#** init_newsession: initialize a new session from scratch
#
#       GLOBALS:  All session variables are affected
#     ARGUMENTS:  none
#       RETURNS:  none
#*
init_newsession() {
	# echo -e "\n$UND\0init_newsession$OFF"
	ui_log "init_newsession"
	local time="$(date '+%Y-%m-%d %H:%M:%S')"

	> "$configfile"
	read_session

	# Set the timestamp for this new session
	set_cfg_item timestamp "$time"

	b_conflict=false
	set_cfg_item b_conflict "$b_conflict"

	# Get the directory containing the upstream repo
	while :; do
		input_dir "Upstream repo" "updir" updir
		is_valid_gitdir "$updir" && break
	done

	input_dir "working" "workdir" workdir
	input_backportfile
	select_gitbranch

	# Create and init the patch.log file in the workdir.
	# This file will be refreshed with each patch applied.
	patchlog="${workdir%/}"/patch.log
	> "$patchlog"

	echo -e "\n${CAU}The following will be in the Options Menu.$OFF"
	input_oneopt "${MNU}JIRA link: $OFF" "str_jira"
	input_oneopt "${MNU}CVE: $OFF" "str_cve"
	input_oneopt "${MNU}Upstream status: $OFF" "str_upstream"
	get_backport_mode
	b_lasthashvalid=false
	b_new=true
	clear_alldone
	init_common
	$b_cmdline && exit_gort $exit_good
}

#* init_current_session: recover last good conf and internal variables
#
#       GLOBALS:  All session variables are affected
#     ARGUMENTS:  none
#       RETURNS:  none
#*
init_current_session() {
	upcmtstartline=1
	lastuphash=
	b_conflict=false
	set_cfg_item "upcmtstartline"	"$upcmtstartline"
	set_cfg_item "b_conflict"	"$b_conflict"
	set_cfg_item "lastuphash"	"$lastuphash"

	b_lasthashvalid=false
	git cherry-pick --abort > /dev/null 2>&1
	init_session
}

#** run_me: main program loop
#
#       GLOBALS:  backportfile
#                 currentuphash
#                 stophash
#                 exit_good
#                 updir
#                 workdir
#                 patchlog
#                 b_cmdline
#                 b_conflict
#                 b_session_inited
#     ARGUMENTS:  $1 - if .eq to 1, then just run the very next commit and stop.
#       RETURNS:  None
#*
run_me() {
	# echo -e "$UND\0run_me$OFF"
	ui_log "run_me"

	local uphash
	local stat
	local b_one=false
	local -i input="$1"

	patchlog="${workdir%/}/patch.log"

	[ -n "$input" ] && (($input == 1)) && b_one=true

	if $b_conflict; then
		echo -e "${CAU}
There were unresolved conflicts when backporting: $STA$currentuphash$OFF"
		echo -e "${INF}
We will print the information to the screen and exit after your next
keypress, so you can fix the conflicts.$OFF
"
		ui_press_any
		flag_conflict "$currentuphash"
	fi

	while :; do
		if [ "$currentuphash" == "$stophash" ]; then
			echo -e "${INF}Stopping before $MNU$stophash$OFF"
			break
		fi
		backport
		get_next_backport
		stat=$?

		if [ $stat -ne 0 ];then
			echo -e "${CAU}No more commits in $STA$backportfile$OFF"
			break
		fi

		$b_one && break
	done

	if $b_cmdline; then exit_gort $exit_good; else menu_loop; fi
}

#** ctrl_c: handler for user interrupt
#
# run if user hits control-c
#*
ctrl_c() {
	ui_log "ctrl_c"
	set +x
	echo
d
	# If user pressed ctrl-c, and the backport was committed but
	# was left unmarked, then mark it as done now.
	if is_backport_done && ! is_upcmt_marked; then
		mark_done "$currentuphash"
		set_cfg_item "lastuphash" "$currentuphash"
	fi

	validate_last_upstream_hash
	exit_gort $CTLC_EXIT         # defined in lib/ui.source
}

#** check_command: checks the command line command
#
# Arguments:
#   $1 - command from command line
#   $2 - receives the validated command from the command line
#*
check_command() {
	ui_log "check_command"
	local cmd="$1"
	local lead="--"

	[ "${#cmd}" -eq 2 ] && eval "$2"="$cmd" && return 0
	[ "${cmd:0:2}" = "$lead" ] && eval "$2"="$cmd" && return 0

	[ "${cmd:0:1}" = "-" ] && cmd="-$cmd" || cmd="--$cmd"
	eval "$2"="$cmd"
	return 1
}

###############################
#** Start of Script Execution
#*#############################
ui_log "start of script execution"

# trap keyboard interrupt (control-c)
#
trap ctrl_c SIGINT
ui_testkeypress	# from lib/keypress_support.source: inits promptgetkey_cmd

read_session
init_global_strings

if [ $# -eq 0 ]; then
	b_cmdline=false
	print_herald
else
	b_cmdline=true
fi

# If any one of workdir, updir, or backportfile is missing, then this
# is a new session, so set $b_new true.
#
([ -d "$workdir" ] && [ -f "$backportfile" ] && is_valid_gitdir "$updir") ||
	init_newsession
init_common

# Determine if we're at the top of a git tree. If not, exit.
#
if ! [ -d .git ]; then
	echo -3 "$CAU"
	echo -e "The current directory... $STA$PWD$CAU"
	echo -e "\t ...is not the top of a git tree.$INF"
	echo "Please cd to the top of a git tree.$OFF"
	echo
	exit 1
fi

#########################################
#** Command Line Options
#*########################################

declare checked_cmd
declare infostr
infostr="Type \"$(basename "$0") -h\" for more info."
declare invoptstr="\nInvalid option.\n$infostr"
declare needcmtstr="\nMust supply commit hash with -p | pick\n$infostr"
declare shortopts="sp:h"
declare longopts="\
abort,\
branch,\
apply:,\
commit,\
directory,\
hashlist,\
help,\
history,\
new,\
nit,\
pick:,\
run,\
select,\
setup,\
status,\
version,\
"

# If running from the command line ...
if $b_cmdline; then

	check_command "$1" checked_cmd || shift

	# [ $# -gt 1 ] && checked_cmd="$checked_cmd ${@:2:$#}"

	opts=$(getopt --options $shortopts --long $longopts --name "$0" -- "$@")
	eval set -- "$opts"

	while :; do
	    case "$checked_cmd" in
		"--abort" )
			abort_gort
			;;
		"--branch" )
			select_gitbranch
			;;
		"--commit" )
			[ "$2" == "1" ] && b_one=true || b_one=false
			run_commit
			;;
		-h | "--help" 	)
			ptpage -b "$tbackground" "$MYHLP"
			exit 0
			;;
		"--history" )
			show_history
			;;
		"--new" )
			read_session
			init_newsession
			;;
		-p | "--pick" )
			currentuphash=$2
			[ "$currentuphash" ] || { echo -e "$needcmtstr"; exit 1; }
			run_single
			;;
		"--reset" )
			reset_gort
			;;
		-r | "--run" )
			run_me
			;;
		"--select" )
			set_next_backport
			;;
		"--setup" )
			init_session
			menu_loop
			shift
			;;
		-s | "--status" )
			show_status
			;;
		"--version" )
			print_herald
			echo
			;;
		-- )	shift
			break
			;;
		* )	echo -e "$invoptstr"
			exit 1
			;;
	    esac
	    exit 0
	done
fi

##############################################
# Main Program
##############################################

# The following line will single step through this script.
# Use the # to comment it out.
# trap 'read -p "$(printf "%$((${#BASH_SOURCE[0]}+8))s" "")" \
#       line && eval "$line" || exit $?' DEBUG


# Present the ui and get the parameters for the commits to apply.
#
menu_loop

echo
exit_gort $exit_good

