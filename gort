#!/bin/bash
#
# gort - Gort is an Omnimodal Revision Tool
#
# Comprehensive interactive tool for automating the backporting of
# upstream kernel commits to downstream (RHEL) kernels. Features
# session management, conflict resolution, and batch operations.
#
# This file uses shdoc-style annotations. See: https://github.com/reconquest/shdoc
#
# Common annotations:
#   @description  - Function/script description
#   @arg          - Function argument: @arg $1 type description
#   @set          - Global variable set: @set varname type description
#   @exitcode     - Exit code: @exitcode 0 description
#   @stdout       - Standard output description
#   @example      - Usage example
#
# Use 'docscript -f funcname <scriptname>' to view function documentation.
#
# Usage:
#   gort                    # Interactive mode
#   gort help               # Show help
#   gort new                # Start a new session
#   gort run                # Run all remaining commits
#   gort next               # Run next commit only
#   gort status             # Show current session status
#   gort commit             # Commit after conflict resolution
#   gort continue           # Continue after external commit
#   gort reset              # Reset to earlier commit
#   gort history            # Show history of applied patches
#

#######################################
# Default file locations
#######################################
#
# Whatever directory this script and its companions are located in
# must be in the executable path.
#
# export PATH=$PATH:MYDIR
#
# Where MYDIR is the directory in which this script and its companions
# are located.
#
[ "$MYDIR" ] || {
	declare MYDIR=
	MYDIR="$(dirname "$(readlink -f "$0")")"
}
[ "$MYLIB" ] || {
	declare MYLIB=
	MYLIB="$MYDIR"/lib
}
declare MYMAN="$MYDIR"/man
declare MYDATA=
MYDATA="$(realpath ./.data)"
declare MYHLP="$MYMAN"/gort.pgman
declare MYNAME=
MYNAME="$(basename "$0")"

#######################################
# External Source Files
#######################################
[ "$ui_loaded" ]            || source "$MYLIB"/ui.source
[ "$configmanager_loaded" ] || source "$MYLIB"/config-manager.source
[ "$ptversion_loaded" ]     || source "$MYLIB"/patchtools-version.source
[ "$keypsupport_loaded" ]   || source "$MYLIB"/keypress-support.source

########################################
# Return and Control Codes
########################################
declare rc_continue=0	# Continue for another pass

declare exit_good=0	# Normal exit
declare exit_conflict=2	# Exit with a conflict
declare exit_reset=3	# Exit after resetting the world
declare exit_bogus=4	# Exit because of bogus commit
declare exit_pending=6	# There are changes pending, so action can't complete
declare exit_nothing=7	# There is nothing to do
declare exit_bad=10	# Exiting from command line call with bad status

declare b_session_inited=false	# boolean to indicate session is inited
declare b_cmdline=false		# boolean indicating a comman line call
declare b_log=false

#########################################
# Config Variables
#########################################
# These variables will be initialized by the call to cfg_start
declare configfile=
declare upcmtstartline=		# Line in backportfile to start backport
declare dnorighead=		# original downstream head at session start
declare lastuphash=		# most recently applied upstream commit hash
declare workdir=		# scratch directory for the session
declare backportfile=		# File of upstream commits to apply
declare b_conflict=		# last attempt generated a conflict
declare str_jira=		# Options: JIRA link
declare str_cve=		# Options: CVE
declare str_upstream=		# Options: upstream version, e.g, v6.7
declare str_brew=		# Options: brew link
declare str_test=		# Options: string containing test info
declare stophash=		# stop backporting when this currentuphash
declare tbackground=		# terminal background, light(1) or dark(2)
declare patchdir=		# directory that gets the patches
declare backport_mode=		# user's choice of backport mode
declare conflicthash=		# upstream hash that introduced a conflict
declare updir=			# directory of upstream repo
declare patfil= 		# conflicted commit formatted into a patch
declare gitbranch=		# branch at start of session
declare timestamp=		# timestamp at start of session

#########################################
# Global Variables
#########################################
declare -i menupad=31
declare cmtmsgfile=
declare b_lasthashvalid=false
declare b_new=false		# new session
declare b_single=false		# only perform single backport
declare b_statflag=false	# user asking for status

declare mirror		# bare shared repo of upstream
declare gitbranch	# current downstream branch
declare finaluphash
declare currentuphash	# next hash in the backportfile
declare currentupcommit # oneline gitlog of next hash in the backportfile
declare lastuplog	# oneline gitlog of last committed upstream hash
declare dncurrenthead	# hash of current downstread head
declare gortlog	# file containing the patching errors
declare starterr=	# errors on startup
declare bpfstartline	# used when selecting a commit out of sequence

# Lines in the backport file starting with any of these chars will be
# ignored.
# The '#' indicates a comment, and the '+' indicates already committed.
declare ignore_str="#+"

########################################
# Global Strings
########################################
declare str_herald=
declare str_conflicts=

# init_global_strings
# @description Initialize global display strings
#
# Globals:
# @set str_herald string The herald/banner string
# @set str_conflicts string Conflict message prefix
#
# Returns:
# @exitcode 0 Always succeeds
#
init_global_strings() {
$b_log && ui_log "init_global_strings"
str_herald="\n$MNU${UND}patchtools v$version$OFF - \
${CAU}G${INF}ort is an ${CAU}O${INF}mnimodal$CAU R${INF}evision$CAU T${INF}ool$OFF"
str_conflicts="Conflicts:\n"
return 0
}

#########################################
# Functions
#########################################

# test_sanity
# @description Debug helper to print sanity check message
#
# Arguments:
# @arg $1 string Message to display
#
test_sanity() { echo -en "${CAU}SANITY$INF : $1$OFF "; ui_press_any; }

# print_herald
# @description Print the script's herald/banner
#
# Globals:
# @set str_herald string Global herald string (read)
#
# Effects:
# @stdout Herald banner with version info
#
# Returns:
# @exitcode 0 Always succeeds
#
print_herald() {
	$b_log && ui_log "print_herald"
	echo -e "$str_herald"
	echo -e "${CAU}                   Klaatu barada nikto$OFF"
	return 0
}

# exit_gort
# @description Exit gort in an orderly manner
#
# Arguments:
# @arg $1 int Exit code
# @arg $2 string Optional exit message
#
# Returns:
# @exitcode * Returns the provided exit code
#
exit_gort() {
	$b_log && ui_log "exit_gort 1:$1  2:$2"
	# echo -e "$UND\0exit_gort $1$OFF"
	ui_trunclog
	[ -n "$2" ] && echo -e "\n$2\n"
	# $b_session_inited && save_session
	exit "$1"
}

# gu_pushd
# @description Push directory onto stack safely, exit on failure
#
# Arguments:
# @arg $1 string Directory to cd into
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 Directory invalid (exits script)
#
gu_pushd() {
	pushd "$1" > /dev/null 2>&1 ||
		exit_gort 1 "${CAU}${1} is not a valid directory!$OFF"
}

# gu_popd
# @description Pop directory from stack safely, exit on failure
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 Stack empty (exits script)
#
gu_popd() {
	popd > /dev/null 2>&1 ||
		exit_gort 1 "${CAU}Directory stack empty!$OFF"
}

# normalize_githash
# @description Normalize git hash using git rev-parse --short
#
# Arguments:
# @arg $1 string The hash to normalize
#
# Effects:
# @stdout Shortened normalized hash
#
# Returns:
# @exitcode 0 Valid hash normalized
# @exitcode 1 Not a valid hash
#
normalize_githash() {
	local inhash="$1"

	git rev-parse --short "$inhash" 2> /dev/null || return 1
	return 0
}

# get_gitbranch
# @description Print the name of the current git branch
#
# Effects:
# @stdout Current branch name
#
# Returns:
# @exitcode 0 Always succeeds
#
get_gitbranch() {
	git branch | grep '\*' | cut -d' ' -f2
}

# select_gitbranch
# @description List available git branches for user selection
#
# Globals:
# @set workdir string Work directory path (read)
# @set gitbranch string Selected branch name (written)
#
# Effects:
# @stdout Branch list with selection prompt
#
# Returns:
# @exitcode 0 New branch selected and checked out
# @exitcode 1 User cancelled or checkout failed
#
select_gitbranch() {
	ui_log "select_gitbranch"
	local index=1
	local linenumber
	local line
	local outline
	local hilite=
	local branchlistfile="$workdir"/branchlist

	echo
	echo -e "${MNU}Select the Downstrean Branch or press $qstr$INF to leave" \
		"the current "
	echo -e "selection marked with the leading *.$OFF"

	git branch > "$branchlistfile"

	while read -r line; do
		[ "${line:0:1}" = "*" ] && hilite="$MNU" || hilite="$INF"
		outline=$(printf "%s %2d %s $line\n" "$hilite" $index "$OFF")
		echo -e "$outline"
		((++index))
	done < "$branchlistfile"

	# echo -e "$brmsg"
	loop_range_q 1 $((index - 1)) linenumber || return
	gitbranch="$(ui_readline "$linenumber" "$branchlistfile" | tr -d '* ')"
	echo -e "${MNU}git checkout $STA$gitbranch$OFF"
	clean_status

        git checkout "$gitbranch" || {
		$b_cmdline && exit_gort $exit_pending;
		return 1
	}

	git log --oneline -1
	set_cfg_item gitbranch "$gitbranch"

	# The new head will be whatever the head is of this branch
	# The startline will be reset to 1, and the done markers will
	# be cleared.
	init_newhead

	$b_cmdline && exit_gort $exit_good || return 0
}

# init_newhead
# @description Initialize newhead after git resets
#   Sets dnorighead to current HEAD, upcmtstartline to 1,
#   and clears all done markers in the backport commits file.
#
# Globals:
# @set dnorighead string Current HEAD hash
# @set upcmtstartline int Reset to 1
#
# Returns:
# @exitcode 0 Always succeeds
#
init_newhead() {
	dnorighead="$(git rev-parse --short HEAD)"
	set_cfg_item dnorighead "$dnorighead"
	upcmtstartline=1
	clear_alldone
	return 0
}

# enter_newhead
# @description Prompt user to enter new starting head commit
#
# Globals:
# @set dnorighead string Updated HEAD hash
# @set upcmtstartline int Reset to 1
#
# Effects:
# @stdout Prompts and current head info
#
# Returns:
# @exitcode 0 Always succeeds
#
enter_newhead() {
	local newhead=
	local fmthead=
	local currentlog=

	currentlog=$(git log --oneline -n1 "$dnorighead" 2> /dev/null)

	echo -e "${MNU}Enter a commit hash for a new head or $qstr$MNU to keep the"
	echo -e "${MNU}current head:$STA $currentlog$OFF"
	while :; do
		getuser "${MNU}Commit hash for new head: " newhead
		[[ "$newhead" =~ ^[qQ]$ ]] && return
		fmthead=$(git rev-parse --short "$newhead" 2> /dev/null) || {
			echo -e "
${CAU}$newhead$OFF$MNU is not a valid commit hash
${INF}Press$STA ctrl-c$INF to quit and use '${CAU}git log$INF' to find a valid commit hash
for your new head.$OFF"
			continue
		}
		break
	done

	git reset --hard "$fmthead"
	init_newhead
	return 0
}

# git_set_subjectprefix
# @description Set the subject prefix in .git/config
#
# Effects:
# @stdout Prompt for new prefix
#
# Returns:
# @exitcode 0 Always succeeds
#
git_set_subjectprefix() {
	ui_log "git_set_subjectprefix"
	local newpfx
	newpfx="$(git config format.subjectprefix)"

	echo -e "$INF" \
"Just press ${STA}ENTER$INF to leave the current subject prefix unchanged.$OFF"
	getuser "${MNU}New subject prefix: $OFF" newpfx
	[ "$newpfx" ] || return
	git config format.subjectprefix "$newpfx"
	return 0
}

# input_dir
# @description Set a directory variable and save to config file
#
# Arguments:
# @arg $1 string Description string for prompt
# @arg $2 string Config file key for the directory
# @arg $3 string Variable name holding current directory value
#
# Effects:
# @stdout Directory prompts and confirmation
#
# Returns:
# @exitcode 0 Always succeeds
#
input_dir() {
	ui_log "input_dir"
	local dirstr="$1"
	local dircfgkey="$2"
	local dir="${!3}"
	local b_msgshown=false

	[ -n "$dir" ] && {
		echo -e "${INF}Current $STA$dirstr$INF directory : $STA$dir$OFF"
		echo -e "${INF}Type $qstr$INF to leave it as it is.$OFF"
	}

	ui_getnewdir "${INF}New $STA$dirstr$INF directory : $OFF" dir

	dir=$(realpath "$dir")
	set_cfg_item "$dircfgkey" "$dir"
	echo -e "$INF$dirstr directory is $STA$dir$OFF\n"
	eval "$3"="$dir"
	return 0
}

# is_valid_gitdir
# @description Check that directory is a valid git repository
#
# Arguments:
# @arg $1 string Directory to test
#
# Returns:
# @exitcode 0 Valid git directory
# @exitcode 1 Not a valid git directory
#
is_valid_gitdir() {
	$b_log && ui_log "is_valid_gitdir"
	local gdir="$1"

	# Strip off any tailing slash
	#
	gdir="${gdir%/}"

	[ "$gdir" == "$(git -C "$gdir" rev-parse --show-toplevel 2>&1)" ] \
		&& return 0 \
		|| return 1
}

# input_backportfile
# @description Prompt user for file containing commits to backport
#
# Globals:
# @set backportfile string Path to backport commits file
#
# Effects:
# @stdout File selection prompts
#
# Returns:
# @exitcode 0 File selected successfully
# @exitcode 1 User cancelled or invalid file
#
input_backportfile() {
	$b_log && ui_log "input_backportfile"
	local sts
	local prstr
	local commitsfilemsg
	local exitmsg
	local currentfile

	prstr=$(
cat <<EOF
${INF}Backports File$OFF
EOF
)
	commitsfilemsg=$(
cat <<EOF
${OFF}You can create a file containing the upstream commits to be backported
using the$INF mkbackportlog$OFF tool.
EOF
)
	exitmsg=$(
cat <<EOF
${INF}
You pressed $qstr$INF without providing a Backports File, so we must exit.$OFF
EOF
)
	currentfile=$(
cat <<EOF
${INF}The current file is $STA$backportfile$INF.
Press $qstr$INF at the prompt to use this file.$OFF
EOF
)
	# echo -e "$UND\0input_backportfile$OFF"

	[ "$backportfile" ] && prstr="$prstr.\n$currentfile"
	ui_getfilespec "$prstr : " backportfile
	sts=$?

	if [ $sts -ne 0 ]; then
		if [ "$backportfile" ]; then
			echo -e "${INF}Keeping: $STA$backportfile$OFF"
		else
			echo -e "$exitmsg"
			exit_gort $exit_nothing "$commitsfilemsg"
		fi
	fi

	backportfile="$(realpath "$backportfile")"
	set_cfg_item "backportfile" "$backportfile"
	return $sts
}

# pr_nohash_msg
# @description Print message when hash not found in backport file
#
# Arguments:
# @arg $1 string Hash that was not found
#
# Globals:
# @set backportfile string Path to backport file (read)
#
# Effects:
# @stdout Error message about missing hash
#
# Returns:
# @exitcode 0 Always succeeds
#
pr_nohash_msg () {
	$b_log && ui_log "pr_nohash_msg"
	local hash="$1"
	local nohash_msg

	nohash_msg=$(
cat <<EOF
$INF
  Cannot find $STA$hash$INF as a commit or valid line number in $STA$backportfile$INF
  Lines having a '$STA\0#$INF' as their first character are not listed or considered.
  Try again or type $qstr$INF to return to main menu.$OFF
EOF
)
	echo -e "$nohash_msg"
	return 0
}

# lookup_hash
# @description Find given hash in the backport commits file
#
# Arguments:
# @arg $1 string Hash to find
# @arg $2 string Variable name to receive line number
#
# Globals:
# @set backportfile string Path to backport file (read)
#
# Returns:
# @exitcode 0 Hash found, line number returned in $2
# @exitcode 1 Hash not found or file missing
#
lookup_hash() {
	$b_log && ui_log "lookup_hash"
	local hash=$1
	local counter
	local line
	local -i actual_line=0

	[[ -f "$backportfile" ]] || return 1

	# Search only in non-ignored lines
	while IFS= read -r line; do
		((actual_line++))
		# Skip ignored lines and empty lines
		[ "$(ui_strindex "$ignore_str" "${line:0:1}")" -ge 0 ] && continue
		[ -z "$line" ] && continue
		# Check if this line starts with the hash
		if [[ "$line" =~ ^[[:space:]]*$hash ]]; then
			counter=$actual_line
			break
		fi
	done < "$backportfile"

	[ -z "$counter" ] && return 1

	eval "$2"="$counter"
	return 0
}

# set_next_backport
# @description Select starting commit from backportfile interactively
#
# Globals:
# @set backportfile string Path to backport file (read)
# @set bpfstartline int Selected line number (written)
#
# Effects:
# @stdout Commit list and selection prompt
#
# Returns:
# @exitcode 0 Always succeeds
#
set_next_backport() {
	$b_log && ui_log "set_next_backport"

	local counter=0
	local line
	local linary
	local -i idx=0
	local -i sts
	local -i linecount
	local -i numwid=
	local -i cols=
	local selected

	[ -f "$backportfile" ] || return
	linecount=$(wc -l < "$backportfile")
	numwid=${#linecount}
	cols=$((tcols - 2 - numwid))
	echo -e "\n${INF}Contents of upstream commits file: $STA$backportfile$OFF"
	echo -e "$MNU\0NOTE:$INF Not showing lines starting with any of these chars:"\
	        "$STA$ignore_str$OFF\n"

	# Dump the contents of the backportfile
	#
	while read -r line; do
		((++counter))
		[ "$(ui_strindex "$ignore_str" "${line:0:1}")" -ge 0 ] && continue
		line=$(printf "%s %${numwid}d %s%s%s" "$MNU" $((idx+1)) "$OFF" "$line")
		echo -e "${line:0:cols}$OFF"
		linary[$idx]=$counter
		((++idx))
	done < "$backportfile"

	echo
	loop_range_q 1 "$idx" selected
	[ "$selected" = "q" ] && return

	bpfstartline=${linary[$((selected - 1))]}

	$b_cmdline && exit_gort $exit_good
	return 0
}

# validate_last_upstream_hash
# @description Validate that stored upstream hash is valid for this session
#
# Globals:
# @set backportfile string Path to backport file (read)
# @set b_lasthashvalid bool Set true if hash is valid
# @set lastuphash string Most recent upstream hash (read)
#
# Returns:
# @exitcode 0 Hash is valid
# @exitcode 1 Hash is not valid
#
validate_last_upstream_hash() {
	$b_log && ui_log "validate_last_upstream_hash"
	local sts=0

	$b_new && b_lasthashvalid=false || b_lasthashvalid=true

	# If we don't have a commits file, show nothing
	[[ -f $backportfile ]] || {
		b_lasthashvalid=false
		return 1
	}

	# If there is no hash saved in the config file, then nothing to do.
	[[ "$lastuphash" ]] || {
		b_lasthashvalid=false
		return 1
	}

	# If the commit stored in the config file is not in the backport file
	# then nothing to do.
	grep -m1 -n "$lastuphash" "$backportfile" >/dev/null 2>&1 || {
		b_lasthashvalid=false
		return 1
	}

	# If we can't get a log of that upstream hash, then it's not valid.
	lastuplog=$(git log -n1 --oneline "$lastuphash") 2>/dev/null || {
		b_lasthashvalid=false
		return 1
	}

	# If we got this far, the lastuphash is valid.
	b_lasthashvalid=true
	return 0
}

# get_lastuplog
# @description Get log of most recent successfully applied upstream commit
#
# Globals:
# @set lastuplog string Log line of last applied commit
# @set lastuphash string Hash of last applied commit
# @set backportfile string Path to backport file (read)
#
# Returns:
# @exitcode 0 Upstream hash was applied
# @exitcode 1 No upstream hash applied yet or no backport file
#
get_lastuplog() {
	$b_log && ui_log "get_lastuplog"
	local ch="+"
	local sts=

	lastuphash=

	[ -f "$backportfile" ] || sts=1

	lastuphash="$(tac "$backportfile" | \
		grep -m 1 '^+' | sed 's/^\+\s*\([^[:space:]]*\).*/\1/')"

	if [ -n "$lastuphash" ]; then
		lastuplog="$(git log --oneline -1 "$lastuphash")"
		sts=0
	else
		sts=1
	fi

	cfg_set_item "lastuphash" "$lastuphash"
	return "$sts"
}

# get_finaluphash
# @description Get the final upstream hash from backport commits file
#
# Globals:
# @set backportfile string Path to backport file (read)
# @set finaluphash string Last hash in file (written)
#
# Returns:
# @exitcode 0 Always succeeds
#
get_finaluphash() {
	local -a lary=()

	mapfile -t lary < <(grep -v "^[${ignore_str}]" "$backportfile" | grep -v '^$')
	finaluphash="$(cut -d' ' -f1 <<< "${lary[-1]}")"
	return 0
}

# git_verify
# @description Verify whether given hash is a valid commit
#
# Arguments:
# @arg $1 string Hash to verify
#
# Returns:
# @exitcode 0 Valid commit
# @exitcode 1 Invalid commit
#
git_verify() {
	local cmthash="$1"
	git rev-parse --verify "${cmthash}^{commit}" >/dev/null 2>&1
	return $?
}

# up_git
# @description Execute a git command in the upstream context
#
# Arguments:
# @arg $1 string Git command (show|log|nice|parse|format|verify)
# @arg $2 string Upstream hash for the command
#
# Globals:
# @set updir string Upstream directory (read)
# @set workdir string Work directory for patches (read)
#
# Effects:
# @stdout Command output
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 Verify failed
#
git_upcmd() {
	$b_log && ui_log "git_upcmd cmd:$1 uphash:$2"

	local cmd="$1"
	local uphash="$2"
	local upstr=

	case "$cmd" in
		"show")	upstr="$(git show "$uphash")"
			;;
		"log")	upstr="$(git log -n1 "$uphash")"
			;;
		"nice")	upstr="$(gitnice -1 "$uphash")"
			;;
		"parse") upstr="$(git rev-parse "$uphash")"
			;;
		"format" ) upstr=$(git format-patch -1 "$uphash" -o "$workdir")
			;;
		"verify" ) git_verify "$uphash" ; return $?
	esac
	echo "$upstr"
	return 0
}

# get_next_backport
# @description Get the next commit from the backport commits file
#   Ignores lines with leading # (comment) or + (already applied).
#
# Globals:
# @set backportfile string Path to backport file (read)
# @set upcmtstartline int Current line in backport file
# @set bpfstartline int One-time override start line
# @set currentuphash string Current upstream hash (written)
# @set currentupcommit string Log of current commit (written)
#
# Returns:
# @exitcode 0 Next commit found
# @exitcode 1 No more commits to backport
#
get_next_backport() {
	$b_log && ui_log "get_next_backport upcmtstartline:$upcmtstartline"

	[[ -f "$backportfile" ]] || return 1

	local -i line=
	local -a lary=()
	local -i sts=0
	local bplog=

	# Make sure we have a valid upstream directory, or prompt the user to
	# input one.
	#
	[ -d "$updir" ] || input_dir "Upstream repo directory" "updir" updir

	# If the caller passed in a startline, then use that.
	# Else find the first line that does NOT begin with one of the characters
	# in the ignore_string, starting from upcmtstartline if it's set.
	#
	if [ -n "$bpfstartline" ]; then
		bplog="$(ui_readline "$bpfstartline" "$backportfile")"
		# Check if the selected line starts with an ignored character
		if [ -n "$bplog" ] && [ "$(ui_strindex "$ignore_str" "${bplog:0:1}")" -ge 0 ]; then
			# Skip to the next non-ignored line
			mapfile -t lary < <(grep -v "^[${ignore_str}]" "$backportfile" | grep -v '^$')
			bplog="${lary[0]}"
		else
			upcmtstartline="$bpfstartline"
		fi
	else
		# Start from upcmtstartline if set, otherwise from beginning
		local -i start_from=1
		[ -n "$upcmtstartline" ] && [ "$upcmtstartline" -gt 0 ] && start_from=$upcmtstartline

		# Read file from start_from, skipping ignored lines
		local -i current_line=0
		local line_content
		while IFS= read -r line_content || [ -n "$line_content" ]; do
			current_line=$((current_line + 1))
			# Skip lines before start_from
			[ $current_line -lt $start_from ] && continue
			# Skip ignored lines and empty lines
			[ -z "$line_content" ] && continue
			[ "$(ui_strindex "$ignore_str" "${line_content:0:1}")" -ge 0 ] && continue
			# Found the next non-ignored line
			bplog="$line_content"
			break
		done < "$backportfile"

		# If we didn't find anything from start_from, get the first non-ignored line
		[ -z "$bplog" ] && {
			mapfile -t lary < <(grep -v "^[${ignore_str}]" "$backportfile" | grep -v '^$')
			bplog="${lary[0]}"
		}
	fi

	if ((${#bplog} > 0)); then
		# Double-check that we didn't accidentally get an ignored line
		[ "$(ui_strindex "$ignore_str" "${bplog:0:1}")" -ge 0 ] && {
			# This shouldn't happen, but if it does, skip to next non-ignored line
			mapfile -t lary < <(grep -v "^[${ignore_str}]" "$backportfile" | grep -v '^$')
			bplog="${lary[0]}"
		}
		[ -z "$bplog" ] && {
			currentuphash=
			upcmtstartline="$(($(wc -l < "$backportfile") + 1))"
			sts=1
			set_cfg_item "upcmtstartline" "$upcmtstartline"
			bpfstartline=
			return $sts
		}
		currentuphash="$(cut -d' ' -f1 <<< "$bplog")"
		# Find the line number, searching only in non-ignored lines
		# Then map back to the actual line number in the original file
		local -i filtered_line=0
		local -i actual_line=0
		local -i found_line=0
		local line_content
		# Read file line by line, skipping ignored lines
		while IFS= read -r line_content || [ -n "$line_content" ]; do
			actual_line=$((actual_line + 1))
			# Skip ignored lines and empty lines
			[ -z "$line_content" ] && continue
			[ "$(ui_strindex "$ignore_str" "${line_content:0:1}")" -ge 0 ] && continue
			filtered_line=$((filtered_line + 1))
			# Check if this line contains our hash (at the start, possibly after whitespace)
			if [[ "$line_content" =~ ^[[:space:]]*$currentuphash ]]; then
				found_line=$actual_line
				break
			fi
		done < "$backportfile"
		if [ $found_line -gt 0 ]; then
			upcmtstartline=$found_line
		else
			# This should not happen - hash came from filtered list, so it should be found
			# If it's not found, there's a logic error, but set to 0 to indicate error
			upcmtstartline=0
		fi
		currentupcommit="$(git log --oneline -n1 "$currentuphash")"
		sts=0
	else
		currentuphash=
		upcmtstartline="$(($(wc -l < "$backportfile") + 1))"
		sts=1
	fi

	set_cfg_item "upcmtstartline" "$upcmtstartline"
	bpfstartline=
	return $sts
}

# get_current_backport
# @description Get the current commit to backport at upcmtstartline
#   Decrements upcmtstartline before calling get_next_backport.
#
# Globals:
# @set upcmtstartline int Current line number (decremented)
# @set b_cmdline bool Command line mode (read)
#
# Returns:
# @exitcode 0 Current commit found
# @exitcode 1 No commit found
#
get_current_backport() {
	$b_log && ui_log "get_current_backport upcmtstartline:$upcmtstartline"
	# local myname="get_current_backport:"
	# echo -e "$OFF\n$UND$myname upcmtstartline: $upcmtstartline$OFF"

	$b_cmdline && return 0
	((--upcmtstartline))
	get_next_backport
	return $?
}

# show_next_backport
# @description Display the next upstream commit to backport
#
# Globals:
# @set currentupcommit string Current commit log line (read)
# @set currentuphash string Current commit hash (read)
# @set b_conflict bool Conflict status (read)
#
# Effects:
# @stdout Next commit information
#
# Returns:
# @exitcode 0 Always succeeds
#
show_next_backport() {
	$b_log && ui_log "show_next_backport currentupcommit:$currentupcommit currentuphash:$currentuphash"

	local linecount
	local prstr=
	local statstr
	local leadstr
	local cols=$((tcols - menupad))
	local show_next_backport_str
	local padstr="$(printf "%*c" "$menupad" " ")"

	($b_cmdline || $b_conflict || $b_statflag) \
		&& leadstr="    " || leadstr="$MNU c$OFF  "
	$b_conflict && statstr="${CAU}Conflicting commit       ${OFF}:" \
		    || statstr="Next backport commit     :$OFF"

	get_current_backport && prstr="$STA${currentupcommit:0:$cols}$OFF"

	show_next_backport_str=$(
cat <<EOF

$leadstr$statstr $prstr
EOF
)
	[ -n "$currentuphash" ] && echo -e "$show_next_backport_str"

	return 0
}

# show_select_next_backport
# @description Show menu option for selecting next commit
#
# Globals:
# @set backportfile string Path to backport file (read)
#
# Effects:
# @stdout Menu option text
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 No backport file
#
show_select_next_backport() {
	# echo -e "${UND}show_select_next_backport$OFF"

	local selcmt_str

	selcmt_str=$(
cat <<EOF

$MNU S$INF  Select a different commit for next backport$OFF
EOF
)
	[[ -f $backportfile ]] || return 1
	echo -e "$selcmt_str"
	return 0
}

# get_lastbackport
# @description Get the last successfully applied upstream commit
#
# Globals:
# @set dnorighead string Original downstream head (read)
#
# Effects:
# @stdout Upstream hash of last backported commit
#
# Returns:
# @exitcode 0 Hash extracted successfully
# @exitcode 1 Current head same as dnorighead
# @exitcode 2 Extracted field is not a hash
# @exitcode 3 dnorighead is null
# @exitcode 4 dnorighead is invalid
#
get_lastbackport() {
	$b_log && ui_log "get_lastbackport"
	local bp
	local hhash="$(normalize_githash HEAD)"

	[ -n "$dnorighead" ] || return 3
	dnorighead="$(normalize_githash "$dnorighead")" || return 4
	[ "$hhash" == "$dnorighead" ] 	&& return 1

	extract_upcmt "$hhash"
	[[ $hhash =~ ^[0-9a-fA-F]+$ ]] && return 0 || return 2
}

# show_most_recent_backport
# @description Display the most recently backported upstream commit
#
# Globals:
# @set lastuplog string Log of last upstream commit (read)
# @set tcols int Terminal columns (read)
#
# Effects:
# @stdout Last backported commit info
#
# Returns:
# @exitcode 0 Always succeeds
#
show_most_recent_backport() {
	$b_log && ui_log "show_most_recent_backport"
	# echo -e "\n${UND}show_most_recent_backport$OFF"

	local cols=$((tcols - menupad))
	local laststr
	local padstr="$(printf "%*c" "$menupad" " ")"
	local eofstr="$CAU${padstr}was the last commit in Backports File$OFF"
	local lastbackport=
	local lastbackportline=

	[ -f "$backportfile" ] || return
	lastbackport="$(get_lastbackport)" || { echo -n; return; }
	lastbackportline="$(git log --oneline -n1 "$lastbackport")"

	laststr="\n    Last backported commit   : $STA${lastbackportline:0:$cols}$OFF"
	echo -e "$laststr"
	((upcmtstartline > $(wc -l < "$backportfile"))) && echo -e "$eofstr"
}

# extract_upcmt
# @description Extract upstream commit hash from downstream commit message
#
# Arguments:
# @arg $1 string Downstream hash (default: HEAD)
#
# Effects:
# @stdout Upstream hash or empty if not found
#
# Returns:
# @exitcode 0 Always succeeds
#
extract_upcmt() {
	local dnhash="${1:-"HEAD"}"	# default is HEAD

	git log -1 --pretty=%B "$dnhash" \
		| awk '/^commit[[:space:]]+[0-9a-f]{40}/ { print $2; exit }' \
		| xargs git rev-parse --short 2> /dev/null
}

# show_upstream_commits_file
# @description Display the upstream commits file path and status
#
# Globals:
# @set backportfile string Path to backport file (read)
# @set b_cmdline bool Command line mode (read)
#
# Effects:
# @stdout File path and commit counts
#
# Returns:
# @exitcode 0 Always succeeds
#
show_upstream_commits_file() {
	$b_log && ui_log "show_upstream_commits_file"
	# echo -e "${UND}show_upstream_commits_file$OFF"

	local cmtfilestr
	local -i nd	# number of commits to do
	local -i nb	# number of commits done
	local -i nc	# number of commits remaining to be done
	local lastupcmt	# last upstream commit backported in file
	local lastdncmt # last downstream commit in current downstream branch
	local lastdnup  # last upstream commit referenced in last downstream commit
	local padstr="$(printf "%*c" "$menupad" " ")"

	if $b_cmdline || $b_conflict || $b_statflag; then
		cmtfilestr="$INF    Upstream Backports File  : $STA$backportfile$OFF"
	else
		cmtfilestr="$MNU f$OFF  Upstream Backports File  : $STA$backportfile$OFF"
	fi

	echo -e "$cmtfilestr"

	[ "$backportfile" ] || return
	[ "$dnorighead" ] || return

	# Count commits that are not hashed-out
	nd="$(grep -c -v '^#' "$backportfile")"

	# Count backports in the file that indicate they have been committed.
	nb="$(grep -c '^+' "$backportfile")"

	# If none of the upstream commits has been applied to downstream, and
	# the current head is same as the dnorighead, then just return, else
	# report an inconsistent state.
	lastdncmt="$(git rev-parse --short HEAD)"
	dnorighead="$(git rev-parse --short "$dnorighead")"

	if ((nb == 0)); then
		if [ "$lastdncmt" == "$dnorighead" ]; then
			return 0
		else
			echo -e "$CAU\
$padstr Inconsistent State$INF
$padstr None of the commits in the Backports File
$padstr has been applied, but the current head : $STA$lastdncmt$INF
$padstr differs from \"Head at Session Start\"   : $STA$dnorighead\"$OFF."
			return 1
		fi
	fi

	# If the last one in the file that indicates it was committed is not
	# at the top of the current downstream branch, then notify inconsistent
	# state.

	lastupcmt="$(tac "$backportfile" | \
		grep -m 1 '^+' | sed 's/^\+\s*\([^[:space:]]*\).*/\1/')"

	lastdnup="$(extract_upcmt "$lastdncmt")"

	# If we didn't extract an upstream commit from the current HEAD,
	# then report that the backportfile has a backport marked, but
	# there's no upsteam commit referenced in the current HEAD.
	if [ -z "$lastdnup" ]; then
		echo -e "$CAU\
$padstr Inconsistent State$INF
$padstr Upstream Backport file shows upstream: $STA$lastupcmt$INF
$padstr was backported, but the current HEAD : $STA$lastdncmt$INF
$padstr does not have any upstream commit reference in its log.$OFF"
		return 1
	fi

	if [ "$lastdnup" != "$lastupcmt" ]; then
		echo -e "$CAU\
$padstr Inconsistent State$INF
$padstr Current Head references upstream commit  : $STA$lastupcmt$INF
$padstr Upstream Backports File says it should be: $STA$lastdnup$OFF"
		return 1
	fi

	nc=$((nd - nb))
	if ((nc == 0)); then
		echo -e \
"$padstr${CAU}It appears all upstream commits have been applied.$OFF"
	else
		echo -e \
"$padstr${INF}Commits backported: $STA$nb$INF Commits remaining: $STA$nc$OFF"
	fi

	return 0
}

# show_history
# @description Display history of applied patches in downstream branch
#
# Globals:
# @set tcols int Terminal columns (read)
# @set dnorighead string Original downstream head (read)
#
# Effects:
# @stdout Commit history table
#
# Returns:
# @exitcode 0 Always succeeds
#
show_history() {
	local tmpfile=$(mktemp)
	local -i count
	local -i mypid
	local -a dncmtary=()

	echo -e "\n$MNU${UND}History of commits made this session$OFF"
	count=$(git rev-list --count "$dnorighead"..HEAD)
	echo -e "\
There are $STA$count$OFF commits since Head at Session Start: $STA$dnorighead$OFF"
	tmpfile=$(mktemp)
	extup -m "$dnorighead..HEAD" > "$tmpfile" & mypid=$!
	ui_waitonproc_tty "$mypid" 0.05 "${INF}Getting the History of commits...$OFF"
	ui_nclearline 1
	echo
	echo -e     "${MNU} Downstream $OFF|$MNU Upstream  "
	echo -e "$MNU${UND}  Commits   $OFF|$MNU${UND}  Commits   $OFF"
	cat "$tmpfile"
	echo -e "$OFF"
	rm -f "$tmpfile"

	$b_cmdline && exit 0
	ui_press_any
	return 0
}

# show_status
# @description Print current session status to screen
#
# Globals:
# @set tcols int Terminal columns (read)
# @set menupad int Menu padding (read)
#
# Effects:
# @stdout Status information
#
# Returns:
# @exitcode 0 Always succeeds
#
show_status() {
	$b_log && ui_log "show_status"

	local cols=$((tcols - menupad))
	local subjectprefix
	local lastbrcmt
	local orighead
	local statstr

	echo -e "$INF"
	git status

	subjectprefix="$(git config format.subjectprefix)"

	lastbrcmt=$(git log -n1 --oneline)
	orighead=$(git log --oneline -n1 "$dnorighead")

	statstr=$(
cat <<EOF
\0
$INF    Session Start Date       : $STA$(get_cfg_item timestamp)
$INF$(show_upstream_commits_file)\
$INF$(show_most_recent_backport)\
$INF$(show_next_backport)
$INF    Current upstream dir     : $STA$updir
$INF    Current downstream branch: $STA$(get_gitbranch)
$INF    Current downstream head  : $STA${lastbrcmt:0:cols}
$INF    Original downstream head : $STA${orighead:0:cols}$OFF
\0
EOF
)
	echo -e "$statstr"
	$b_conflict && flag_conflict "$(get_cfg_item "conflicthash")"
	$b_cmdline && exit 0 || { ui_press_any; return; }
}

# get_patchdir
# @description Get directory path for patch files
#
# Globals:
# @set patchdir string Patch directory (written)
#
# Effects:
# @stdout Prompt for directory
#
# Returns:
# @exitcode 0 New patchdir entered
# @exitcode 1 User quit without entering
#
get_patchdir() {
	$b_log && ui_log "get_patchdir"
	local pdir=
	local prstr

	prstr="\n${MNU}Directory path for patchfiles. $OFF\n"
	prstr+="${INF}Enter $qstr$INF to leave it as it is.$MNU\n"
	prstr+="$patchdir : $OFF"

	ui_getnewdir "$prstr" pdir || return 1
	patchdir="$pdir"
	set_cfg_item "patchdir" "$patchdir"
	return 0
}

# create_patches
# @description Create patch series from backported commits
#
# Globals:
# @set patchdir string Patch directory (read)
# @set dnorighead string Original head (read)
#
# Effects:
# @stdout Progress and prompts
#
# Returns:
# @exitcode 0 Patches created or user cancelled
#
create_patches() {
	$b_log && ui_log "create_patches"
	local dirstr="
${MNU}Do you want to use$STA $patchdir$MNU for your patches? y/n :$OFF "
	local findargs="-maxdepth 1 -type f -name "*.patch" -print -quit"

	cfg_get_item "patchdir" patchdir
	local pdir="$patchdir"

	echo -e "\n${INF}Create a patch series from the applied commits.$OFF"

	[ -d "$pdir" ] && {
		loop_yn "$dirstr" || pdir=
	}

	[ -d "$pdir" ] || {
		get_patchdir || return
	}

	local delprompt="$(
cat <<EOF
${CAU}There are .patch files in$STA $patchdir$CAU.
${INF}They will be erased if you continue.
Do you want to proceed?$MNU y/n : $OFF
EOF
)"
	[ -n "$(find "$patchdir" $findargs)" ] && {
		loop_yn "$delprompt" && rm -f "$patchdir"/*.patch || return
	}

	gitforpat -n "$patchdir" "$dnorighead"..
	return
}

# show_tbackground
# @description Display current terminal background setting
#
# Globals:
# @set tbackground int Background setting (read)
#
# Effects:
# @stdout "Dark" or "Light"
#
# Returns:
# @exitcode 0 Always succeeds
#
show_tbackground() {
	$b_log && ui_log "show_tbackground"
	((tbackground == tb_dark)) && echo -n "Dark" ||
		                      echo -n "Light"
}

# show_backport_mode
# @description Display the current backport mode setting
#
# Globals:
# @set backport_mode int Current mode (read)
#
# Effects:
# @stdout Mode name (patchpal, cherry-pick, apply, etc.)
#
# Returns:
# @exitcode 0 Always succeeds
#
show_backport_mode() {
	$b_log && ui_log "show_backport_mode"
	case "$backport_mode" in
	    "$bm_patchpal"	) echo -e "${STA}patchpal$OFF"
				;;
	    "$bm_cherry"	) echo -e "${STA}git cherry-pick$OFF"
				;;
	    "$bm_apply"	        ) echo -e "${STA}git apply --reject$OFF"
				;;
	    "$bm_apply3"	) echo -e "${STA}git apply with 3-way merge$OFF"
				;;
	    "$bm_patch" 	) echo -e "${STA}patch$OFF"
				;;
	    "$bm_patch_merge"	)  echo -e "${STA}patch --merge$OFF"
	esac
}

# show_options
# @description Display the options menu
#
# Globals:
# @set str_upstream string Upstream version info (read)
# @set str_jira string JIRA link (read)
# @set str_cve string CVE info (read)
#
# Effects:
# @stdout Options menu
#
# Returns:
# @exitcode 0 Always succeeds
#
show_options() {
	$b_log && ui_log "show_options"
	local options

	options=$(
cat <<EOF
$MNU
        ${UND}Options          $OFF
    $MNU u $OFF Upstream status          : $STA$str_upstream$OFF
    $MNU J $OFF JIRA link                : $STA$str_jira$OFF
    $MNU C $OFF CVE                      : $STA$str_cve
    $MNU b $OFF Brew or build info       : $STA$str_brew$OFF
    $MNU t $OFF Test information         : $STA$str_test$OFF
    $MNU p $OFF Patch subject prefix     : $STA$(git config format.subjectprefix)$OFF
    $MNU d $OFF Patch Directory          : $STA$patchdir$OFF
    $MNU B $OFF Backport Mode            : $STA$(show_backport_mode)$OFF
    $MNU c $OFF Change Terminal Colors   : $STA$(show_tbackground)$OFF
    $MNU q $OFF Quit to main menu
\0
EOF
)
	echo -e "$options"
	return 0
}

# input_oneopt
# @description Get one of the string options from user
#
# Arguments:
# @arg $1 string Prompt string
# @arg $2 string Option variable name (by reference)
#
# Returns:
# @exitcode 0 Value entered
# @exitcode 1 User quit
#
input_oneopt() {
	$b_log && ui_log "input_oneopt"
	local prompt="$1"
	local -n getone_str="$2"
	local item="$2"
	local str
	local pstr

	ui_trunclog
	pstr="\n${INF}Press $qstr$INF to leave unchanged.\n"
	pstr+="Press$STA RETURN$INF with nothing to blank.\n"
	pstr+="Current value:$STA $getone_str$OFF\n$prompt"
	getuser "$pstr" str
	[ "$str" == "q" ] && return 1
	set_cfg_item "$item" "$str"
	getone_str="$str"
	return 0
}

# get_options
# @description Parse user's option entry from options menu
#
# Globals:
# @set str_upstream string Upstream version (modified)
# @set str_brew string Brew info (modified)
# @set str_jira string JIRA link (modified)
#
# Returns:
# @exitcode 0 Option processed
# @exitcode 1 User typed 'q' to quit
#
get_options() {
	$b_log && ui_log "get_options"
	local opt=

	show_options
	"$promptgetkey_cmd" "${MNU}    Enter one of the above: $OFF" opt

	case $opt in
		J )	input_oneopt "${MNU}JIRA link: $OFF" "str_jira"
			;;
		C )	input_oneopt "${MNU}CVE: $OFF" "str_cve"
			;;
		u )     input_oneopt "${MNU}Upstream status: $OFF" "str_upstream"
			;;
		b )	input_oneopt "${MNU}Brew or build info: $OFF" "str_brew"
			;;
		t )	input_oneopt "${MNU}Testing info: $OFF" "str_test"
			;;
		p )	git_set_subjectprefix
			;;
		c )     ui_use_colors
			tbackground="$terminal_background"
			set_cfg_item "tbackground" "$tbackground"
			;;
		d )	get_patchdir
			;;
		B )	get_backport_mode
			;;
		q )	return 1
	esac

	return 0
}

# options_loop
# @description Loop getting options until user types 'q'
#
# Returns:
# @exitcode 0 User quit
#
options_loop() {
	$b_log && ui_log "options_loop"
	while :; do
		get_options || return
	done
}

# show_altopt
# @description Display Alt-Shift option if keypress mode active
#
# Arguments:
# @arg $1 string Option letter
# @arg $2 string Description string
#
# Effects:
# @stdout Option line or nothing if not in keypress mode
#
# Returns:
# @exitcode 0 Displayed
# @exitcode 1 Not in keypress mode
#
show_altopt() {
	$b_log && ui_log "show_altopt"
	local opt="$1"
	local str="$2"
	$ui_b_keypress || return 1
	echo -e "$CAU Alt-Shift-$opt $OFF$str"
	return 0
}

# show_settings
# @description Display current settings and main menu
#
# Globals:
# @set tcols int Terminal columns (read)
# @set dncurrenthead string Current downstream head (written)
# @set dnorighead string Original downstream head (read)
#
# Effects:
# @stdout Settings and menu
#
# Returns:
# @exitcode 0 Always succeeds
#
show_settings() {
	$b_log && ui_log "show_settings"
	# echo -e "$UND\0show_settings$OFF"
	local cols=$((tcols - menupad))
	local subjectprefix
	local lasttag
	local lastbrcmt
	local orighead=
	local settings

	subjectprefix="$(git config format.subjectprefix)"
	lastbrcmt="$(git log -n1 --oneline)"
	dncurrenthead="$(cut -d' ' -f1 <<< "$lastbrcmt")"
	[ -n "$dnorighead" ] && orighead="$(git log --oneline -n1 "$dnorighead")"

	settings=$(
cat <<EOF
$MNU
    ${UND}Upstream Environment    $OFF
$(show_upstream_commits_file)\
$(show_most_recent_backport)\
$(show_next_backport)

$MNU    ${UND}Downstream Environment  $OFF
    Current Head             : $STA${lastbrcmt:0:cols}$OFF
    Head at Session Start    : $STA${orighead:0:cols}$OFF
$MNU u $OFF Upstream repo directory  : $STA$updir$OFF
$MNU b $OFF Current git branch       : $STA$(get_gitbranch)$OFF
$MNU w $OFF Working directory        : $STA$workdir$OFF
$MNU B $OFF Backport method          : $(show_backport_mode)
$MNU O $OFF Options menu
$MNU
    ${UND}Control                $OFF
$MNU S $OFF Stop before              : $STA$stophash$OFF
$MNU P $OFF Create a patch series
$MNU N $OFF Start a New Session
$MNU H $OFF Show History
$MNU r $OFF Run all remaining commits
$MNU 1 $OFF Run the next commit and stop
$MNU s $OFF gort status
$MNU A $OFF Abort, reset to last good commit and clean status
$(show_altopt "R" "RESET to an earlier commit in this session ")
$(show_altopt "H" "Enter a new starting HEAD ")
$MNU q $OFF Quit this tool
$MNU h $OFF Help
$OFF
EOF
)
# save for later
# $MNU V $OFF vim $STA$backportfile$OFF in a popup window

	echo -e "$settings"
	return 0
}

# menu_parser
# @description Parse user input at main menu
#
# Globals:
# @set dncurrenthead string Current downstream head (written)
#
# Returns:
# @exitcode rc_continue Continue menu loop
#
menu_parser() {
	# echo -e "$UND\0menu_parser$OFF"
	$b_log && ui_log "menu_parser"

	local pops
	local setting=
	local -i retval

	validate_last_upstream_hash
	dncurrenthead="$(git rev-parse --short HEAD)"
	show_settings

	ui_trunclog
	"$promptgetkey_cmd" "${MNU}Enter one of the above: $OFF" setting
	retval=$?

	# keypress.c does not invoke SIGINT on ctrl-c, so test for it explicitly
	# when using keypress.
	$ui_b_keypress && [ "$setting" == $'\003' ] && ctrl_c

	case $setting in

		b )	select_gitbranch
			;;
		w )	input_dir "working" "workdir" workdir
			;;
		f )	input_backportfile
			;;
		u )	input_dir "Upstream repo directory" "updir" updir
			;;
		c )	set_next_backport
			;;
		N )	read_session; init_newsession
			;;
		h )	ptpage -b "$tbackground" "$MYHLP"
			;;
		q )	exit_gort $exit_good
			;;
		r )	run_me
			b_new=false
			;;
		O )	options_loop
			;;
		S )	getuser "${MNU}Stop before this hash: $OFF" stophash
			cfg_set_item "stophash" "$stophash"
			;;
		P )	create_patches
			;;
		1 )	run_me 1
			;;
		s )	b_statflag=true; show_status; b_statflag=false
			;;
#		V )	ui_popterm "vim $backportfile"
#			;;
		R )	((retval == 1)) || return $rc_continue
			reset_gort
			;;
		H )	((retval == 1)) && enter_newhead || show_history
			;;
#		U )	update_gort
#			;;
		A )	abort_gort
			;;
		B )	get_backport_mode
	esac
	return $rc_continue
}

# menu_loop
# @description Present main menu until user quits
#
# Globals:
# @set workdir string Work directory (read)
# @set cmtmsgfile string Commit message file (read)
# @set backportfile string Backport file path (read)
#
# Returns:
# @exitcode * Status from menu_parser
#
menu_loop() {
	$b_log && ui_log "menu_loop"
	local sts=0

	cfg_update_configfile
	while :; do

		menu_parser
		sts=$?
		# echo "menu_parser_stat: $sts"
	done
	return $sts
}

# edit_commit
# @description Loop through commit message editing until done
#
# Globals:
# @set cmtmsgfile string Commit message file (read)
#
# Effects:
# @stdout Commit log and prompts
#
# Returns:
# @exitcode 0 Always succeeds
#
edit_commit() {
	$b_log && ui_log "edit_commit"
	local yup

	while :; do
		# Display the git log message and inquire if it needs more
		# editing.
		#
		git log -n1 > "$cmtmsgfile"
		cat "$cmtmsgfile"
		echo

		getyn "Edit this commit message?" yup

		if $yup; then git commit --amend; else break; fi
	done
}

# check_state
# @description Check state before any operations (placeholder)
#
# Returns:
# @exitcode 0 Always succeeds
#
check_state() {
	$b_log && ui_log "check_state"
}

# clean_status
# @description Abort operations and leave git status clean
#
# Globals:
# @set backport_mode int Backport mode (read)
#
# Returns:
# @exitcode 0 Always succeeds
#
clean_status() {
	$b_log && ui_log "clean_status"
	((backport_mode == bm_cherry)) && git cherry-pick --abort > /dev/null 2>&1
	git restore --staged . > /dev/null 2>&1
	git checkout . > /dev/null 2>&1
	git clean -fd > /dev/null 2>&1
}

# abort_gort
# @description Abort current backport, clear conflicts, reset to last good commit
#
# Globals:
# @set b_conflict bool Conflict flag (cleared)
# @set upcmtstartline int Start line (reset to 1)
#
# Returns:
# @exitcode 0 On return to menu
#
abort_gort() {
	$b_log && ui_log "abort_gort upcmtstartline:$upcmtstartline b_conflict:$b_conflict"
	local cmt

	# clean_status
	((backport_mode == bm_cherry)) && git cherry-pick --abort > /dev/null 2>&1

	# Get the last succesful commit and git reset to it.
	cmt="$(git rev-parse --short HEAD)"
	git reset "$cmt"

	upcmtstartline=1
	b_conflict=false
	cfg_set_item "b_conflict" "$b_conflict"
	cfg_set_item "upcmtstartline" "$upcmtstartline"
	get_current_backport

	$b_cmdline && exit_gort $exit_good || return
}

# get_newhead
# @description Choose from heads since dnorighead
#
# Globals:
# @set dnorighead string Original downstream head (read)
# @set dncurrenthead string Modified if user selects different head
#
# Effects:
# @stdout Commit list and selection
#
# Returns:
# @exitcode 0 Selection made
# @exitcode 1 User cancelled
#
get_newhead() {
	$b_log && ui_log "get_newhead dnorighead:$dnorighead dncurrenthead:$dncurrenthead"
	local -a dncmtary=()
	local new
	local hashsize
	local addlprompt
	local tmp
	local spc
	local count
	local mypid
	local tmpfile

	# Get the number of commits made after dnorighead and notify
	# user.
	count=$(git rev-list --count "$dnorighead"..HEAD)
	echo -e "$INF
There are $STA$count$INF commits since Head at Session Start: $STA$dnorighead$INF"

	# Get the downstream and upstream commits in a spawned process and
	# save it to a named pipe.
	tmpfile=$(mktemp)
	extup -m "$dnorighead^..HEAD" > "$tmpfile" & mypid=$!
	ui_waitonproc_tty "$mypid" 0.05 "${INF}Getting the list of commits...$OFF"
	ui_nclearline 1
	mapfile -t dncmtary < "$tmpfile"
	rm -f "$tmpfile"

	# Create space strings based on the sizes of the hashes.
	# These will be used to correctly align the column headings in the
	# selection menu.
	tmp="$(cut -d' ' -f1 <<< "${dncmtary[0]}")"
	hashsize="${#tmp}"
	spc="$(printf "%*c" $((hashsize - 12)) " ")"

	select_from_array dncmtary "Dn Commits" new \
		"      $MNU${UND}Dn Commits$spc$OFF  $MNU${UND}Up Commits$spc$OFF" || return 1

	# Set the new downstream current head global
	dncurrenthead="$(cut -d' ' -f1 <<< "$new")"
	# Normalize the hash length.
	dncurrenthead=$(git rev-parse --short "$dncurrenthead")
	return 0
}

# update_gort
# @description Update Head at Session Start to current downstream head
#   Resets markers in backportfile after git pull or new branch creation.
#
# Globals:
# @set dnorighead string Updated to dncurrenthead
# @set dncurrenthead string Current downstream head (read)
#
# Returns:
# @exitcode 0 On return to menu
#
update_gort() {
	$b_log && ui_log "update_gort dnorighead:$dnorighead dncurrenthead:$dncurrenthead"
	clean_status
	clear_alldone
	dnorighead="$dncurrenthead"
	set_cfg_item "dnorighead" "$dnorighead"
	linenumber=1
	b_conflict=false
	b_lasthashvalid=false
	upcmtstartline=0
	get_next_backport

	$b_cmdline && exit_gort $exit_reset || return
}

# reset_gort
# @description Reset downstream HEAD to an earlier commit
#   Presents list of commits since dnorighead for user to select.
#   Useful for backtracking when things go wrong.
#
# Globals:
# @set dnorighead string Original downstream head (read)
# @set dncurrenthead string Current downstream head (modified)
# @set backportfile string Backport file (markers updated)
#
# Returns:
# @exitcode 0 On return to menu
#
reset_gort() {
	$b_log && ui_log "reset_gort dnorighead:$dnorighead dncurrenthead:$dncurrenthead"
	local -a clrary=()
	local linenumber

	clean_status
	b_conflict=false
	set_cfg_item "b_conflict" "$b_conflict"

	# Reset: Clear the leading "+ " from the lines in the upstreamcommitsfile to
	# indicate that the corresponding upstream commits are not applied.
	# We are backtracking.
	# If the user chose the original head, resetting it back to the beginning,
	# then clear all the done markers, else just clear the ones that we are
	# retreating from.
	get_newhead || return

	if [ "$dnorighead" == "$dncurrenthead" ]; then
		linenumber=1
	else
		mapfile -t clrary < \
			<(extup -m -b "$dncurrenthead"^.. | cut -d' ' -f1)
		# Get the last element in the array
		linenumber=$(grep -n -m1 "${clrary[@]: -1}" "$backportfile" | cut -d: -f1)
		((++linenumber))
	fi

	# Use sed to remove the done mark from the line number
	sed -i "${linenumber},\$s|^+ ||" "$backportfile"

	# Reset to the new head, and get the next backport.
	git reset --hard "$dncurrenthead"
	b_conflict=false
	set_cfg_item b_conflict "$b_conflict"
	b_lasthashvalid=false
	upcmtstartline=0
	get_next_backport

	$b_cmdline && exit_gort $exit_reset || return
}

# run_continue
# @description Continue backporting after resolving conflicts
#   Assumes changes were made and committed externally.
#
# Globals:
# @set b_conflict bool Conflict flag (cleared)
#
# Effects:
# @stdout Status and prompts
#
# Returns:
# @exitcode 0 Continuing to run
#
run_continue() {
	# echo -e "$UND\0run_continue$OFF"
	$b_log && ui_log "run_continue"

	local statstr
	local gitstat

	statstr=$(
cat <<EOF
$INF
You have made changes that must be committed before using "gort continue".
You can use "gort commit" if you want gort to make these commits for you.
$OFF
EOF
)
	# If the working tree is not clean, commit your changes before
	# useing gort continue or use git commit.
	git diff-index --quiet HEAD -- || {
		echo -e "$statstr"
		git status
		exit $exit_pending
	}

	edit_commit
	b_conflict=false
	get_next_backport
	run_me
}

# run_commit
# @description Return from conflict resolution, let script commit
#
# Arguments:
# @arg $1 string If "ONE", run one and exit
#
# Globals:
# @set currentuphash string Current upstream hash (read)
# @set conflicthash string Conflicting hash (read/cleared)
# @set b_conflict bool Conflict flag (cleared)
#
# Returns:
# @exitcode 0 Commit processed
#
run_commit() {
	$b_log && ui_log "run_commit arg1:$1 currentuphash:$currentuphash conflicthash:$conflicthash"

	# Ensure cmtmsgfile is initialized (needed when called from command line)
	cmtmsgfile="/tmp/.gcpgitlog"

	# Load conflicthash from config (needed when called from command line)
	conflicthash="$(get_cfg_item conflicthash)"
	currentuphash="$conflicthash"	# get the stored conflict hash
	b_conflict="$(get_cfg_item b_conflict)"

	# If are no changes to commit, let the user know there's nothing
	# to commit, else stage the commit and continue.
	if git diff-index --quiet HEAD -- ; then
		echo -e "\n${CAU}There is nothing to commit.$OFF"
	else
		conflicthash=		# null out the stored conflict hash
		set_cfg_item "conflicthash" "$conflicthash"
		stage_commit
		mark_done $currentuphash
	fi

	b_conflict=false
	$b_one && exit_gort $exit_good
	get_next_backport
	b_cmdline=false
	menu_loop
}

# run_single
# @description Backport just one commit and exit
#
# Globals:
# @set currentuphash string Current upstream hash (read)
# @set b_single bool Single mode flag (set true)
#
# Returns:
# @exitcode * Exit code from backport
#
run_single() {
	$b_log && ui_log "run_single"
	local sts
	echo -e "$UND\0run_single$OFF"
	b_single=true

	set_cfg_item "lastuphash" "$currentuphash"

	backport
	sts=$?
	exit $sts
}

# mark_out
# @description Mark line with leading # (comment out)
#
# Arguments:
# @arg $1 string Upstream hash
# @arg $2 string Optional mark character (default: #)
#
# Globals:
# @set backportfile string Backport file (read)
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 File missing or sed failed
#
mark_out() {
	$b_log && ui_log "mark_out uphash: $1 mark:${2:-'+'}"
	local uphash="$1"
	local mark="${2:-#}"	# the default leading char is +

	[ -f "$backportfile" ] || return 1
	sed -i "s/^$uphash/$mark $uphash/" "$backportfile" || return 1
	return 0
}

# mark_done
# @description Mark line with leading + (done)
#
# Arguments:
# @arg $1 string Upstream hash
# @arg $2 string Optional mark character (default: +)
#
# Globals:
# @set backportfile string Backport file (read)
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 File missing or sed failed
#
mark_done() {
	$b_log && ui_log "mark_done uphash: $1 mark:${2:-'+'}"
	local uphash="$1"
	local mark="${2:-+}"	# the default leading char is +

	[ -f "$backportfile" ] || return 1
	sed -i "s/^$uphash/$mark $uphash/" "$backportfile" || return 1
	return 0
}

# clear_done
# @description Clear done mark for line with given hash
#
# Arguments:
# @arg $1 string Upstream hash
# @arg $2 string Optional mark character (default: +)
#
# Globals:
# @set backportfile string Backport file (read)
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 File missing or sed failed
#
clear_done() {
	 #ui_log "clear_done uphash: $1 mark:${2:-'+'}"
	local uphash="$1"
	local mark="${2:-+}"	# the default leading char is +

	[ -f "$backportfile" ] || return 1
	sed -i "s/^$mark $uphash/$uphash/" "$backportfile" || return 1
	return 0
}

# clear_alldone
# @description Clear all done marks in the backportfile
#
# Arguments:
# @arg $1 string Optional mark character (default: +)
#
# Globals:
# @set backportfile string Backport file (read)
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 File missing or sed failed
#
clear_alldone() {
	$b_log && ui_log "clear_alldone mark:${1:-+}"
	local mark="${1:-+}"	# the default leading char is +
	local markstr=

	[ -f "$backportfile" ] || return 1
	markstr="$mark "	# add the trailing space
	sed -i "s|^$markstr||g" "$backportfile" || return 1
	return 0
}

# flag_conflict
# @description Print conflict message and status
#
# Arguments:
# @arg $1 string Upstream hash that conflicted
#
# Globals:
# @set b_conflict bool Conflict flag (read)
#
# Effects:
# @stdout Conflict details and resolution instructions
#
flag_conflict() {
	$b_log && ui_log "flag_conflict uphash:$1"
	local uphash="$1"
	local patch=
	local dashpad=
	local patpad=
	local patcmt=
	local b_patvalid=false
	local b_notsame=false

	b_conflict=true
	set_cfg_item "b_conflict" "$b_conflict"

	# We need to check the patch that was saved to see if it's the same as
	# the one for this conflict commit.
	#
	patch="$(get_cfg_item "patfil")"

	# If the patchfile exists, then extract the upstream commit field.
	if [ -f "$patch" ]; then
		patcmt="$(cut -d' ' -f2 < <(head -1 "$patch"))"
		# Verify that it's a valid commit
		git_upcmd "verify" "$patcmt" && b_patvalid=true || b_patvalid=false
	fi

	# If it's a valid commit, see if it's the same as the "$uphash" conflict.
	if $b_patvalid; then
		[ "$(git_upcmd parse "$patcmt")" != "$(git_upcmd parse "$uphash")" ] \
			&& b_notsame=true || b_notsame=false
	fi

	# If the commit hash in the existing file is not valid, or if it's
	# valid but not the same as the current conflict uphash, then
	# delete the old one and create a new one from the uphash conflict
	# commit.
	if ! $b_patvalid || $b_notsame; then
		$b_log && ui_log "flag_conflict: creating new patch file"
		# Remove any patches in the workdir
		shopt -s extglob
		rm -f "${workdir%/}"/*.patch
		shopt -u extglob

		# Create the patch for this conflict
		patch="$(git_upcmd "format" "$uphash")"
		set_cfg_item "patfil" "$patch"
	fi

	patpad="$(printf '%*s\n' "${#patch}" "" | tr ' ' '-'})"
	dashpad="$(printf '%*s\n' "${#gortlog}" "" | tr ' ' '-'})"

	echo -e "
$CAU${UND}There are conflicts$INF

${CAU}The offending patch is in:
$STA$patch$OFF
$patpad
${CAU}grep the Gort Log for details:$OFF
$STA$gortlog$OFF
$dashpad$INF
Type ${CAU}gort abort$INF to restore your repo to the state it was in \
before the conflict.$OFF
     -----------$INF
After fixing the conflicts, you can reenter gort with the following commands.
${STA}gort commit$INF   : if you have fixed the conflicts and want the script to stage
                 the commit and create the commit log for you.
${STA}gort continue$INF : if you have fixed the conflicts and made the commit externally
                 and wish to continue with the next backport commit.$OFF
"
	exit_gort $exit_conflict
}

# backport
# @description Backport the upstream commit in currentuphash
#
# Globals:
# @set currentuphash string Current upstream hash (read)
# @set lastuphash string Last applied hash (written)
# @set b_conflict bool Conflict flag (may be set)
#
# Effects:
# @stdout Progress messages
#
# Returns:
# @exitcode 0 Success
# @exitcode * Non-zero if something went wrong
#
backport() {
	$b_log && ui_log "backport"
	# echo -e "$UND\0backport$OFF"

	local uphash=$currentuphash
	local sts
	local wcols=$((tcols - 10))
	local untracked
	local b_setexit=false
	commit=$(git log --oneline -n1 "$uphash")
	local outfil=

	outfil=$([[ $b_cmdline == "false" ]] && echo "$gortlog" || echo "/dev/stdout")
	echo -e "${INF}Processing : $STA${commit:0:$wcols}$OFF"

	# If this upstream commit has already been applied, return now.
	is_backport_done && {
		echo -e "$STA$uphash$INF already committed.$OFF"
		mark_done "$uphash"
		set_cfg_item "lastuphash" "$uphash"
		return 0
	}

	# Prepare the outfil. It will be refreshed for every patch applied.
	date '+%Y-%m-%d %H:%M:%S' > "$outfil"
	echo "backport mode: $(show_backport_mode)" >> "$outfil"

	case "$backport_mode" in
	    "$bm_cherry" )
		if $b_nit; then
			git cherry-pick -n "$uphash" >> "$outfil" 2>&1
		else
			git -c merge.renameLimit=1 cherry-pick -x \
				"$uphash" >> "$outfil" 2>&1
		fi
		;;
	    "$bm_patchpal" ) patchpal "$uphash"
		;;
	    "$bm_apply" )
		git apply --reject < <(git show "$uphash") >> "$outfil" 2>&1
		;;
	    "$bm_apply3" )
		git apply -3 < <(git show "$uphash") >> "$outfil" 2>&1
		;;
	    "$bm_patch" )
		patch --no-backup-if-mismatch --batch --verbose \
			-p1 < <(git_upcmd show "$uphash") >> "$outfil" 2>&1
		;;
            "$bm_patch_merge" )
                patch --no-backup-if-mismatch --batch --verbose --merge \
			-p1 < <(git_upcmd show "$uphash") >> "$outfil" 2>&1
                ;;
	esac

	sts=$?

	# Check for errors
	# git cherry-pick returns:
	#    0 all good
	#    1 conflicts or other problems
	#    128 fatal, invalid arg, missing patch, or repo corruption
	#
	# patch returns
	#    0 all good
	#    1 conflicts
	#    2 patch cannot be applied at all
	#
	(($sts > 1)) && exit_gort $exit_bogus "$CAU$err$OFF"

	# If the backport wants to add a new file to the index, or if the
	# backport exited with a nonzero status greater than 1, then we
	# must report the conflict and stop.
	untracked="$(git ls-files --others --exclude-standard)"

	if [ -n "$untracked" ] || ((sts != 0)); then
		$b_log && ui_log "backport: conflict"
		b_setexit=true
		b_conflict=true
		$b_single && git status && exit $exit_conflict
		conflicthash=$uphash
		set_cfg_item "conflicthash" "$conflicthash"
		# echo -e "Saving: $BLD${commit:0:$wcols}$OFF"
		show_status internal
		flag_conflict "$uphash"
	fi

	# We process differently for patchpal.
	# If stage_patchpal doesn't return 0, then return with its status.
	if ((backport_mode == bm_patchpal )); then
		stage_patchpal || return $?
	else
		stage_commit
	fi

	get_lastuplog		# inits lastuphash from backport file
	return 0;
}

# stage_commit
# @description Process and commit the backported commit
#   Creates git log with JIRA, CVE, upstream info if available.
#
# Globals:
# @set b_conflict bool Conflict flag (read)
# @set cmtmsgfile string Commit message file (written)
# @set str_jira string JIRA link (read)
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 Commit message error
#
stage_commit() {
	$b_log && ui_log "stage_commit"
	local summary
	local uphash=$currentuphash
	local uplog
	local b_crlf=false

	# If this upstream commit has been committed external to stage_commit,
	# then flag it.
	#
	is_backport_done && {
		echo -e "
$STA$uphash$INF was committed externaly.
The commit log will be displayed in the vim editor for review.
$OFF"
		edit_commit
		return
	}

	# Create the new commit message in a file consisting of ..
	#	The user of this script as author of the patch
	#	The current date
	#	Descriptor line, with leading whitespace trimmed
	#	Bugzilla and brew if available
	#	Upstream status if available
	#	Original commit message from applied commit
	#	Signed-off-by: line
	#
	echo -e "\n" > "$cmtmsgfile"

	set -f	# disable wildcard

	# Get the upstream commit log and extract the summary
	# from the fifth line, removing leading spaces.
	#
	uplog="$(git log -n1 "$uphash")"
	summary=$(sed -n '5{s/^[[:space:]]*//; p}' <<< "$uplog")

	echo -e "$summary\n" >> "$cmtmsgfile"
	[ -n "$str_jira" ] && {
		echo -e "JIRA: $str_jira" >> "$cmtmsgfile"
		b_crlf=true
	}
	[ -n "$str_cve" ] && {
		echo -e "CVE: $str_cve" >> "$cmtmsgfile"
		b_crlf=true
	}
	[ -n "$str_upstream" ] && {
		echo -e "Upstream status: $str_upstream" >> "$cmtmsgfile"
		b_crlf=true
	}
	$b_crlf && echo >> "$cmtmsgfile"

	set +f	# re-enable wildcards

	$b_conflict && echo -e "$str_conflicts" >> "$cmtmsgfile"

	# Append the original commit message.
	#
	echo "$uplog"  >> "$cmtmsgfile"

	# Verify the commit message file exists and has content
	[ ! -f "$cmtmsgfile" ] || [ ! -s "$cmtmsgfile" ] && {
		echo -e "${CAU}Error: Commit message file is empty or missing.$OFF"
		return 1
	}

	# Only use git add . if there are untracked
	# files. It saves time to use git add -u, because the git
	# logic won't waste time looking for untracked files.
	# git ls-files is much faster.
	#
	[ -n "$(git ls-files --others --exclude-standard | head -n 1)" ] \
		&& git add . \
		|| git add -u

	git commit -s -F "$cmtmsgfile" --no-edit

	# If there are conflicts, give the user the option to edit
	# the commit log (including in command-line mode for conflict resolution).
	#
	$b_conflict && edit_commit

	# Mark this done when we know it's done.
	mark_done "$uphash"

	b_conflict=false
}

# stage_patchpal
# @description Process and commit via patchpal mode
#   Creates git log with JIRA, CVE, upstream info if available.
#
# Globals:
# @set cmtmsgfile string Commit message file (written)
# @set str_jira string JIRA link (read)
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 Patchpal not done
#
stage_patchpal() {
	$b_log && ui_log "stage_patchpal"
	local newlog=
	local uphash=$currentuphash
	local -i line=
	local b_crlf=false

	# If the backport was not completed, then tell the user and
	# try again.
	is_backport_done || {
		echo -e "${CAU}
patchpal$INF backport of $STA$uphash$INF was not completed.
You must press \"${STA}Accept$INF\" and \"${STA}Commit$INF\" in the \
patchpal tool dialog in order
to proceed to the next upstream commit.
You can press$CAU ctrl-c$OFF any time to safely exit.
$OFF"
		return 1
	}

	set -f	# disable wildcards

	# Patchpal creates the full RHEL commit, with the backporting
	# developer as author, the original upstream commit, and
	# signed-off-by the backporting developer.
	git log -1 > "$cmtmsgfile"

	# Find the second instance of "commit <40-char-hash> in the
	# git log. This is where the upstream commit log is appended
	# to this downstream commit log.
	line=$(grep -n -E -m2 '^[[:space:]]*commit [0-9a-fA-F]{40}$' "$cmtmsgfile" \
		| tail -n1 | cut -d: -f1)

	# Insert new stuff above this line, so backup one.
	line=$((line - 1))

	newlog="
"

	[ -n "$str_jira" ] && {
		newlog+="JIRA: $str_jira
"
		b_crlf=true
	}
	[ -n "$str_cve" ] && {
		newlog+="CVE: $str_cve
"
		b_crlf=true
	}
	[ -n "$str_upstream" ] && {
		newlog+="Upstream status: $str_upstream
"
		b_crlf=true
	}
	$b_crlf && newlog+="
"
	export ins="$newlog"
	gawk -i inplace -v target="$line" '
	{
	  if (NR == target) {
	    # Insert the text from ENVIRON["ins"] before printing the current line
	    printf "%s", ENVIRON["ins"];
	    # Delete the variable so it isnt printed again
	    delete ENVIRON["ins"];
	  }
	  print;
	}
	' "$cmtmsgfile"

	set +f	# re-enable wildcards
	mark_done "$uphash"
	return 0
}

# is_backport_done
# @description Test if upstream backport was already completed
#
# Globals:
# @set currentuphash string Upstream hash being backported (read)
# @set dnorighead string Head at session start (read)
#
# Returns:
# @exitcode 0 Backport was completed
# @exitcode 1 Backport not done
#
is_backport_done() {
	local uphash="$currentuphash"

	[ -n "$uphash" ] || return 1

	# Following line returns 0 if the upstream commit has already been
	# backported by doing a dry run of reversing the upstream commit
	# as a patch.
	# If the test shows that it can be reversed, then the backport of
	# that upstream hash is done, so it will return 0.
	# It the test shows that the patch cannot be reversed, then it
	# will return a 1, indicating that the backport was not done.
	#
	[ -n "$(git log "$dnorighead".. --grep=$uphash)" ] && return 0 || return 1
}

# is_upcmt_marked
# @description Check if upstream commit is marked done in backportfile
#
# Globals:
# @set currentuphash string Current upstream hash (read)
# @set backportfile string Backport file path (read)
#
# Returns:
# @exitcode 0 Marked done or nothing to mark
# @exitcode 1 Not marked
#
is_upcmt_marked() {

	[ -n "$currentuphash" ] || return 0
	[ -f "$backportfile" ] || return 0
	grep -E "^\+ ${currentuphash}\b" "$backportfile"
	return $?
}

# set_cfg_item
# @description Write value to key in config file
#
# Arguments:
# @arg $1 string Key name
# @arg $2 string Value to write
#
# Returns:
# @exitcode 0 Always succeeds
#
set_cfg_item() {
	cfg_write_key "$1" "$2"
}

# get_cfg_item
# @description Read value from key in config file
#
# Arguments:
# @arg $1 string Key to read
#
# Effects:
# @stdout Value at key
#
# Returns:
# @exitcode 0 Always succeeds
#
get_cfg_item() {
	cfg_read_key "$1"
}

# get_originhead
# @description Get HEAD of downstream origin from config
#
# Globals:
# @set dnorighead string Original downstream head (written)
#
# Returns:
# @exitcode 0 Always succeeds
#
get_originhead() {
	$b_log && ui_log "get_originhead"
	dnorighead="$(get_cfg_item dnorighead)"
}

# get_x11devel
# @description Install libX11-devel if user has privileges
#
# Effects:
# @stdout Installation messages
#
# Returns:
# @exitcode 0 Installed successfully
# @exitcode 1 No privileges or install failed
#
get_x11devel() {

	# No libX11-devel present, so we will have to install.
	# Before we can try to dnf install libX11-devel, we need to know
	# if user has superuser privileges.
	sudo -n true || {
		echo -e "
$CAU$USER$INF does not have privileges to install libx11-devel$OFF
"
		return 1
	}

	# If the user has sudoer privileges, let's install libX11-devel.
	sudo dnf install -y libX11-devel || {
		echo -e "\n${CAU}Could not dnf install$STA libX11-devel$OFF\n"
		return 1
	}

	return 0
}

# is_xrunning
# @description Determine if X server is running
#   Compiles test binary on-the-fly if needed.
#
# Effects:
# @stdout X server availability message
#
# Returns:
# @exitcode 0 X is available
# @exitcode 1 No X server
#
is_xrunning() {
	local xtest_c="$MYDIR/x_test.c"
	local xtest_bin="$MYDIR/x_test"

	# If we don't already have the xtest binary, then build it.
	[ -x "$xtest_bin" ] || {

		# Before we build it, we need to be certain that we have the
		# libX11-devel first, and, if we don't, the user has sudoer
		# privs to dnf install it.
		rpm -q libX11-devel > /dev/null 2>&1 || get_x11devel

		# Write the C code to a file
cat << 'EOF' > "$xtest_c"
#include <X11/Xlib.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    Display *dpy = XOpenDisplay(NULL);
    if (dpy) {
	XCloseDisplay(dpy);
	return 0;  // X is available
    }
    return 1;  // No X server
}
EOF
		# Compile the program (you can change gcc options as needed)
		gcc "$xtest_c" -o "$xtest_bin" -lX11 >/dev/null 2>&1
	}

	# Check if the binary exists and is executable, then run it.
	if "$xtest_bin"; then
	    echo "X server is available."
	else
	    echo "No X server found."
	fi
}

# check_X
# @description Simple X check for DISPLAY environment
#
# Effects:
# @stdout Error message if no display
#
# Returns:
# @exitcode 0 DISPLAY is set
# @exitcode 1 No DISPLAY
#
check_X() {
	[ -n "$DISPLAY" ] && return 0
	echo -e "$CAU
No X DISPLAY detected.$INF
You cannot use patchpal for backporting without an X DISPLAY.$OFF"
	return 1
}

# get_backport_mode
# @description Choose which backport mode to use
#
# Globals:
# @set backport_mode int Selected mode (written)
#
# Effects:
# @stdout Mode selection menu
#
# Returns:
# @exitcode 0 Mode selected
#
get_backport_mode() {
while :; do
	$b_log && ui_log "get_backport_mode"
	echo
	echo -e "    ${INF}Which backport mode do you want to use?$MNU"
	echo -e "      1.$OFF patchpal$MNU"
	echo -e "      2.$OFF git cherry-pick, leaves conflict markers$MNU"
	echo -e "      3.$OFF git apply --reject, with .rej files to peruse$MNU"
	echo -e "      4.$OFF git apply with 3-way merge$MNU"
	echo -e "      5.$OFF patch with reject files$MNU"
	echo -e "      6.$OFF patch --merge, use conflict markers instead of rej files$OFF"

	loop_range $bm_lower $bm_upper  backport_mode

	# We need to special case patchpal mode, because you need to be
	# running X to use it.
	# Works fine with VNC, so you can still be remote, as long as you
	# launce an X-client that can handle it, like VNC.
	#
	if ((backport_mode == bm_patchpal)); then
		check_X && break || continue
	fi
	break
done
	set_cfg_item "backport_mode" "$backport_mode"
}

# save_session
# @description Save session config variables to .conf file
#
# Globals:
# @set backportfile string Backport file path (read)
# @set upcmtstartline int Start line (read)
#
# Returns:
# @exitcode 0 Always succeeds
#
save_session() {
	# echo -e "$UND\0save_session$OFF"
	$b_log && ui_log "save_session"
	local -a keys=()
	local fd
	exec {fd}< "$configfile"
	while IFS+="=" read -ru $fd key; do
		key="$(echo "$key" | cut -d' ' -f1)"
		set_cfg_item "$key" "${!key}"
	done
	exec {fd}<&-
}

# read_session
# @description Read config variables from .conf file
#
# Globals:
# @set workdir string Work directory (written)
# @set backportfile string Backport file path (written)
# @set tbackground int Terminal background (written)
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 Important config values missing
#
read_session() {
	# echo -e "$UND\0read_session$OFF"
	$b_log && ui_log "read_session"
	local cfgtemplate=

	# Initialize the paths for the current working directory
	#
	[ -d "$MYDATA" ] || mkdir -p "$MYDATA"
	configfile="$MYDATA/gort.conf"
	cfgtemplate="$MYLIB/gort.conf"

	# This call will init all the global variables with the values stored
	# in .data/gort.conf
	cfg_start "$cfgtemplate" "$configfile"

	# If the background value saved in the conf file is not valid, then
	# call to determine the background color

	if ((tbackground < tb_lite || tbackground > tb_dark)); then
		ui_setbg tbackground
		cfg_set_item "tbackground" "$tbackground"
	else
		ui_do_colors "$tbackground"
	fi

	# backport_mode enumeration
	#
	enum "bm" \
		patchpal \
		cherry \
		apply \
		apply3 \
		patch \
		patch_merge

	return 0
}

# check_gitbranch
# @description Check if running on same git branch as last time
#   If not, try to checkout last branch or let user select.
#
# Globals:
# @set backportfile string Backport file path (read)
#
# Returns:
# @exitcode 0 On correct branch or switched successfully
#
check_gitbranch() {
	$b_log && ui_log "check_gitbranch backportfile:$backportfile"
	local cbranch	# current branch
	local sbranch	# saved branch

	cbranch="$(git rev-parse --abbrev-ref HEAD)"
	sbranch="$(get_cfg_item gitbranch)"

	[[ $cbranch == $sbranch ]] && return 0
	git checkout "$sbranch" 2> /dev/null && return 0

	# Okay, not the same branch, and previous branch is no longer valid.
	# Clear all done markers in the backport file.
	[ -f "$backportfile" ] && clear_alldone
	echo -e "$CAU
git cannot checkout branch: $STA$sbranch$INF"
	[ -n "$timestamp" ] && echo -e "${INF}\
This session started with that branch on: $STA$timestamp$INF"
	echo -e "$INF
Enter$CAU ctrl-c$INF to exit now, or any other key to select from a list
of available branches.$OFF"
	ui_press_any_ctlc
	select_gitbranch
}

# check_repostate
# @description Check repository consistency
#   Verifies last backported commit matches downstream HEAD.
#
# Globals:
# @set backportfile string Backport file path (read)
#
# Returns:
# @exitcode 0 State is consistent
# @exitcode 1 Inconsistent state detected
#
check_repostate() {
	$b_log && ui_log "check_repostate backportfile:$backportfile"
	local uphash
	local exhash
	local currenthead

	currenthead="$(git rev-parse --short HEAD)"

	# Find the last backported upstream commit in the backport file
	uphash="$(tac "$backportfile" | \
		grep -m 1 '^+' | sed 's/^\+\s*\([^[:space:]]*\).*/\1/')"

	# Extract the upstream commit from the first commit log in the
	# downstream repo
	exhash="$(extract_upcmt)"

	[[ $uphash == $exhash ]] && return 0

	[ -n "$exhash" ] && {
		starterr+="$CAU
Inconsistent state: $STA$uphash$INF in $STA$backportfile$INF
is not the same as: $STA$exhash$INF in git HEAD: $STA$currenthead$INF
See Upstream Backports file: $STA$backportfile$OFF"
		return 1
	}

	starterr+="$CAU
Inconsistent state:$INF The current HEAD: $STA$currenthead$INF was not backported
from upstream.
See Upstream Backports file: $STA$backportfile$OFF"
	return 1
}

# init_run
# @description Initialize before running from backport file
#
# Globals:
# @set updir string Upstream repo directory
# @set workdir string Work directory
# @set backportfile string Backport file path
# @set gortlog string Log file path
#
# Returns:
# @exitcode 0 Always succeeds
#
init_run() {

	# Let's make sure we have the work directory and the backport file
	[ -d "$workdir" ] || input_dir "working" "workdir" workdir
	[ -f "$backportfile" ] || input_backportfile

	gortlog="${workdir%/}/gort.log"

	# We need this file for any op that creates a commit.
	cmtmsgfile="/tmp/.gcpgitlog"

	# If we don't have a backport_mode saved in the .data/gort.conf
	# then get the backport_mode from the user now.
	((backport_mode >= bm_lower && backport_mode <= bm_upper)) || {
		get_backport_mode
	}

	# If the backport mode was saved, and if it's patchpal, then if
	# we are not running X, get a new backport_mode.
	if ((backport_mode == bm_patchpal)); then
		check_X || get_backport_mode
	fi
}

# init_common
# @description Common initialization for all init calls
#
# Globals:
# @set updir string Upstream repo directory
# @set workdir string Work directory
# @set mirror string Mirror repo path
# @set b_session_inited bool Session initialized flag
#
# Returns:
# @exitcode 0 Always succeeds
#
init_common() {
	# echo -e "$UND\0init_common$OFF"
	$b_log && ui_log "init_common backportfile:$backportfile upcmtstartline:$upcmtstartline"
	local loc_main
	local rem_main
	local line

	# If we don't have a valid upstream directory, get it now.
	([ -d "$updir" ] && is_valid_gitdir "$updir") || {
		# Get the directory containing the upstream repo
		while :; do
			input_dir "Upstream repo" "updir" updir
			is_valid_gitdir "$updir" && break
		done
	}

	# We need this file for any op that creates a commit.
	cmtmsgfile="/tmp/.gcpgitlog"

	# The mirror repo is going to be parallel to the upstream repo.
	# If it's not there, create it.
	mirror="$(realpath "${updir%/}/../mirror")"
	[ -d "$mirror" ] || mkdir -p "$mirror"

	# Shared upstream repo housekeeping.
	# If the mirror bare-repo has not been created yet, let's do
	# that now.
	git --git-dir="$mirror" rev-parse --is-bare-repository > /dev/null 2>&1 || {
		$b_log && ui_log "init_common: git clone --mirror $updir $mirror"
		local repostr="$INF
If this is the first time running this script in this directory,
please allow a couple minutes to fetch the upstream mirror.
You will not need to add the upstream kernel as a remote, since your
existing upstream kernel in $STA$updir$INF will be mirrored in
$STA$mirror$INF"
		echo -e "$repostr"
		git clone --mirror "${updir%/}" "${mirror%/}" 2>&1 \
			| while read -r line; do echo "$line"; done &
		ui_waitonproc $!
	}

	# Update the mirror
	gu_pushd "$mirror"
	$b_log && ui_log "init_common: git fetch origin --prune"
	git fetch origin --prune
	gu_popd

	# If we don't have a reference to the upstream mirror yet, then
	# add it.
	if ! git config --get remote.mirror.url > /dev/null; then
		$b_log && ui_log "init_common: remote add mirror $mirror"
		git remote add mirror "$mirror"
	fi

	# Check for updates in the mirror.
	#
	rem_main=$(git --git-dir="${mirror%/}" rev-parse refs/heads/master 2>/dev/null)
	loc_main=$(git for-each-ref --format='%(objectname) %(refname)' refs/remotes/mirror/ | \
		awk '$2 ~ /(heads\/)?master$/ {print $1; exit}')

	if [ "$rem_main" != "$loc_main" ]; then
	local infostr="$INF
Fetching the upstream mirror...
"
	    echo -e "$infostr"
	    $b_log && ui_log "Master branch updated; fetching changes..."
	    git fetch mirror --prune 2>&1 | while read -r line; do echo "$line"; done &
	    ui_waitonproc $!
	fi

	check_gitbranch
	check_repostate

	$b_new && init_newhead

	get_current_backport

	# If it's not a new session, and we don't have any conflicts, get the
	# last successfully backported commit.
	#
	($b_new || $b_conflict) || get_lastuplog
	b_session_inited=true
}

# init_cmdline_call
# @description Initialize for command line invocations
#
# Returns:
# @exitcode 0 Always succeeds
#
init_cmdline_call() {
	# echo -e "$UND\0init_cmdline_call$OFF"
	$b_log && ui_log "init_cmdline_call"

	local sts
	local newstr="${INF}Please type $MNU$MYNAME new$INF to start.$OFF\n"

	read_session

	init_common
}

# init_newsession
# @description Initialize a new session from scratch
#
# Globals:
# @set All session variables affected
#
# Returns:
# @exitcode 0 Always succeeds
#
init_newsession() {
	# echo -e "\n$UND\0init_newsession$OFF"
	$b_log && ui_log "init_newsession"
	local time="$(date '+%Y-%m-%d %H:%M:%S')"

	> "$configfile"
	read_session

	# Set the timestamp for this new session
	set_cfg_item timestamp "$time"

	b_conflict=false
	set_cfg_item b_conflict "$b_conflict"

	# Get the directory containing the upstream repo
	while :; do
		input_dir "Upstream repo" "updir" updir
		is_valid_gitdir "$updir" && break
	done

	input_dir "working" "workdir" workdir
	input_backportfile
	select_gitbranch

	# Create and init the gort.log file in the workdir.
	# This file will be refreshed with each patch applied.
	gortlog="${workdir%/}"/gort.log
	> "$gortlog"

	echo -e "\n${CAU}The following will be in the Options Menu.$OFF"
	input_oneopt "${MNU}JIRA link: $OFF" "str_jira"
	input_oneopt "${MNU}CVE: $OFF" "str_cve"
	input_oneopt "${MNU}Upstream status: $OFF" "str_upstream"
	get_backport_mode
	b_lasthashvalid=false
	b_new=true
	clear_alldone
	init_common
	$b_cmdline && exit_gort $exit_good
}

# run_me
# @description Main program loop for backporting
#
# Arguments:
# @arg $1 int If 1, run only next commit and stop
#
# Globals:
# @set backportfile string Backport file path (read)
# @set currentuphash string Current upstream hash
# @set stophash string Hash to stop before
#
# Returns:
# @exitcode 0 On completion or menu return
#
run_me() {
	# echo -e "$UND\0run_me$OFF"
	$b_log && ui_log "run_me"

	local uphash
	local sts
	local b_one=false
	local -i input="$1"

	init_run

	[ -n "$input" ] && (($input == 1)) && b_one=true

	if $b_conflict; then
		echo -e "${CAU}
There were unresolved conflicts when backporting: $STA$currentuphash$OFF"
		echo -e "${INF}
We will print the information to the screen and exit after your next
keypress, so you can fix the conflicts.$OFF
"
		ui_press_any
		flag_conflict "$currentuphash"
	fi

	while :; do
		# Get the next commit to process
		get_next_backport
		sts=$?
		[ $sts -ne 0 ] && {
			echo -e "${CAU}No more commits in $STA$backportfile$OFF"
			break
		}

		# Check if we should stop before this commit
		if [ -n "$stophash" ] && [ "$currentuphash" == "$stophash" ]; then
			echo -e "${INF}Stopping before $MNU$stophash$OFF"
			break
		fi

		# Process the commit
		backport

		# If we only want to process one commit, break now
		$b_one && break
	done

	if $b_cmdline; then exit_gort $exit_good; else menu_loop; fi
}

# ctrl_c
# @description Handler for user interrupt (Ctrl-C)
#
# Globals:
# @set currentuphash string Current hash (may mark done)
#
# Returns:
# @exitcode CTLC_EXIT Signal exit code
#
ctrl_c() {
	$b_log && ui_log "ctrl_c"
	set +x
	echo

	# If user pressed ctrl-c, and the backport was committed but
	# was left unmarked, then mark it as done now.
	if is_backport_done && ! is_upcmt_marked; then
		mark_done "$currentuphash"
		set_cfg_item "lastuphash" "$currentuphash"
	fi

	validate_last_upstream_hash
	exit_gort $CTLC_EXIT         # defined in lib/ui.source
}

# check_command
# @description Validate and normalize command line command
#
# Arguments:
# @arg $1 string Command from command line
# @arg $2 string Variable to receive validated command
#
# Returns:
# @exitcode 0 Command was already properly formatted
# @exitcode 1 Command was normalized
#
check_command() {
	$b_log && ui_log "check_command"
	local cmd="$1"
	local lead="--"

	[ "${#cmd}" -eq 2 ] && eval "$2"="$cmd" && return 0
	[ "${cmd:0:2}" = "$lead" ] && eval "$2"="$cmd" && return 0

	[ "${cmd:0:1}" = "-" ] && cmd="-$cmd" || cmd="--$cmd"
	eval "$2"="$cmd"
	return 1
}

parse_command_line() {
	#########################################
	# Commands and Options
	#########################################

	local infostr=
	infostr="${INF}Type ${STA}\"$(basename "$0") help\"$INF for more info.$OFF"
	local invoptstr="${CAU}Invalid command or option.\n$infostr"
	local needcmtstr="${CAU}Must supply commit hash with ${MNU}-p${OFF} | ${MNU}pick\n$infostr"

	case "$1" in
		"abort" )
			abort_gort
			;;
		"branch" )
			select_gitbranch
			;;
		"commit" )
			[ "$2" == "1" ] && b_one=true || b_one=false
			run_commit
			;;
		-h | "--help" | "help" 	)
			ptpage -b "$tbackground" "$MYHLP"
			exit 0
			;;
		"history" )
			show_history
			;;
		"new" )
			read_session
			init_newsession
			;;
		"next" )
			run_me 1
			;;
		-p | "pick" )
			currentuphash=$2
			[ "$currentuphash" ] || { echo -e "$needcmtstr"; exit 1; }
			run_single
			;;
		"reset" )
			reset_gort
			;;
		-r | "run" )
			run_me
			;;
		"select" )
			set_next_backport
			;;
		-s | "status" )
			show_status
			;;
		"version" )
			print_herald
			echo
			;;
		-- )	shift
			break
			;;
		* )	echo -e "$invoptstr"
			exit 1
			;;
	esac
}

##############################################
# Main Program
##############################################

main() {
	# trap keyboard interrupt (control-c)
	#
	trap ctrl_c SIGINT
	ui_testkeypress	# from lib/keypress_support.source: inits promptgetkey_cmd

	$b_log && ui_log "start of script execution"

	read_session
	init_global_strings

	if [ $# -eq 0 ]; then
		b_cmdline=false
		print_herald
	else
		b_cmdline=true
	fi

	# If any one of workdir, updir, or backportfile is missing, then this
	# is a new session but only if it's NOT from the command line.
	#
	if $b_cmdline; then
		parse_command_line "$@"
	else
		([ -d "$workdir" ] && [ -f "$backportfile" ] && is_valid_gitdir "$updir") || {
			init_newsession
		}
	fi

	# Determine if we're at the top of a git tree. If not, exit.
	#
	git rev-parse --is-inside-work-tree >/dev/null 2>&1 || exit_gort 1 "$(cat <<EOF
${CAU}The current directory... $STA$PWD$CAU
\t ...is not the top of a git tree.$INF
Please cd to the top of a git tree.$OFF
EOF
)"
	init_common

	# Present the ui and get the parameters for the commits to apply.
	#
	menu_loop

	echo
	exit_gort $exit_good
}

main "$@"
