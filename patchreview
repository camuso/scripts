#!/bin/bash
#
# patchreview
#
# This script assumes that you have already extracted your patches into
# the directory named as "indir" below. Only files named "*.patch" will
# be considered.
#
# To create a patch set from email ...
# In mutt, tag the thread you want to extract with esc-t. Untag the
# prologue, as it's not a patch. Then extract the thread into text
# files using ;-esc-C (uppercase C). When prompted for the directory,
# type the name of the mailbox directory or uparrow to the previous
# save.
#
# This script can also be used to compare any two patch sets.
#
# Calls on the following external scripts.
#
# ./githead
# ./patcmp
# ./patbatcmp
# ./patbatcmpmgr
#
# Requires to run ...
#
# ./lib/*.source
# ./.data/patchreview.prj
# ./man/patchreview.man

#######################################
# Default file locations
#######################################
#
# Whatever directory this script and its companions are located in
# must be in the executable path.
#
# export PATH=$PATH:MYDIR
#
# Where MYDIR is the directory in which this script and its companions
# are located.

declare MYDIR=$(dirname $(which $(basename $0)))
declare MYLIB=$MYDIR/lib

#######################################
# External Source Files
#######################################
source $MYLIB/ui.source
source $MYLIB/gitutilities.source
source $MYLIB/patch-common.source
source $MYLIB/patch-utils.source
source $MYLIB/patch-mrutilities.source
source $MYLIB/config-manager.source

#########################################
# Functions
#########################################

function init_booleans {
	b_prologue=false

	# Only these two booleans are inited to true at the
	# beginning of every invocation of the script.
	#
	for bool in \
	b_rename_infiles \
	b_fmt_upstream
	do
		set_cfg_item $bool true
	done
}

# get_booleans
#
# Read the values of the program flow control booleans from the
# config file.
#
function get_booleans {
	# echo "patchreview::get_booleans()"
	local bool
	for bool in \
	b_rename_infiles \
	b_fmt_upstream \
	b_verbose \
	b_mrcomments \
	b_seekfixes
	do
		eval $bool=$(get_cfg_item $bool)
		ui_digit2bool $bool
	done
}

# set_booleans
#
# Write the current values of the program flow booleans into the
# config file.
#
function set_booleans {
	# echo "patchreview::set_booleans()"
	local bool

	for bool in \
	b_rename_infiles \
	b_fmt_upstream \
	b_verbose \
	b_mrcomments \
	b_seekfixes
	do
		set_cfg_item $bool ${!bool}
		let index++
	done
	b_prologue=false
	return 0
}

function clean_dir {
	local delquery="Are you sure you want to delete the contents of:"
	local response=false

	getyn "$delquery\n\t$1\n" response
	$response && find "$1" -mindepth 1 -exec rm -rvf '{}' \;
}

clean_indir() {
	# remove everything in the indir, except any subdirs
	find $indir -maxdepth 1 -not -type d -exec rm -vf '{}' \;
	patchcount=0
}

clean_outdir() {
	find "$outdir" -maxdepth 1 -not -type d -exec rm -vf '{}' \;
	rm -vf $outdir/$mismatch_file
}

clean_directories() {
	local answer
	local cleanstr=$(
cat <<EOF

    $BLD$UND\0Clean Directory$OFF
    Select one of$BLD

 1  Clean $OFF$indir$BLD
 2  Clean $OFF$outdir$BLD
 3  Clean both
\0
EOF
)
	echo -e "$cleanstr"
	loop_range_q 1 3 answer
	[ $? -ne 0 ] && return

	case $answer in
		1 ) clean_indir
		    ;;
		2 ) clean_outdir
		    ;;
		3 ) clean_indir
		    clean_outdir
		    ;;
		* ) echo "Not a valid selection for Clean Directories"
	esac
}

# reset_to_lasttag - reset the current branch to its most recent tag
#
# Also checks that the saved lasttag is the same as the lasttag of the
# current branch. If they are not, the reset is not executed and the user
# is warned, because the results would be a merge of two branches.
#
# Globals:
# 	lasttag
#
reset_to_lasttag() {
	local newlasttag
	local head=$(git log --oneline -n1)
	git_get_lasttag newlasttag $last_tag_file
	local errstr=$(
cat <<EOF

$WRN\0Warning
It appears the head was moved outside of this script.$INF
		Current branch: $STA$(git_getcurrentbranch)$INF
Most recent tag of that branch: $STA$lasttag$INF
Most recent tag in this script: $STA$newlasttag$INF

Please switch to the correct branch.
We won't reset the head.$OFF

\0
EOF
)
	[ "$newlasttag" =  "$lasttag" ] || { echo -e "$errstr"; return; }

	echo -e "$BLD\0Resetting git head to$OFF $lasttag."
	git reset --hard $lasttag
	b_allapplied=false
}

# nuke - delete files in indir and outdir, except logs, and reset to lasttag
#
#        Also calls the init sequence.
#
# Globals:
# 	indir
# 	outdir
# 	applymode
#
nuke() {
	clean_indir
	clean_outdir

	# Reset the git head to the last tag
	reset_to_lasttag

	# Init the booleans to their defaults
	init_booleans
	get_booleans

	# Set the apply mode to its default value
	applymode=$applymode_norm
	set_cfg_item applymode $applymode
}

# show_config_menu - display the configuration options and their current state
#
# Globals:
# 	indir
# 	indirstr
# 	infilecount
# 	outdir
# 	outdirstr
# 	patstr
# 	editor
#
show_config_menu() {
	local config_menu=$(
cat <<EOF
$MNU
    $UND\0Configuration       $OFF
$MNU o$OFF  Operating mode           :$STA $(show_opmode)
$MNU c$OFF  See comments first       :$STA $(show_mrcomments)
$MNU s$OFF  Automatically Seek Fixes :$STA $(show_seekfixes)
$(show_patches)
$(show_workdir)
$MNU r$OFF  Remote Repo/Branch       :$STA $remote_repo/$remote_branch$OFF
    Remote URL               :$STA$(show_remote_url "$remote_repo")$OFF
$MNU e$OFF  Diff Editor              :$STA $editor
$MNU f$OFF  Patch Validation fuzz    :$STA $(show_patchvalfuzz)
$MNU p$OFF  Cycle Patch Compare Mode :$STA $(show_cmpmode)$OFF
$MNU v$OFF  Toggle verbose mode      : $(show_verbose)
$MNU q$OFF  Quit and return to previous menu
\0
EOF
)
	echo -e "$config_menu"
}

# config_parser - config the options selected from the config menu
#
# Globals
# 	opmode
# 	opmode_mr
# 	opmode_states
# 	b_mrflag
# 	indir
# 	indirstr
# 	outdir
# 	outdirstr
#
config_parser() {
	local opt

	while :; do
		get_booleans
		init_files
		init_loopvars
		show_config_menu
		promptgetchar ""$MNU"Enter one of the above: "$OFF"" opt

		case $opt in
		o )	change_opmode
			;;
		c )	ui_toggle b_mrcomments
			set_cfg_item "b_mrcomments" $b_mrcomments
			;;
		d )	set_dir "$indirstr" "indir" indir
			;;
		w )	set_dir "$outdirstr" "outdir" outdir
			;;
		r )	get_remote_seek
			;;
		e )	set_editor
			;;
		f )	set_patchvalfuzz
			;;
		p )	ui_cycle_state cmpmode $cmpmode_states
			set_cfg_item "cmpmode" $cmpmode
			;;
		v )	ui_toggle b_verbose
			set_cfg_item "b_verbose" $b_verbose
			;;
		s )	ui_toggle b_seekfixes
			set_cfg_item "b_seekfixes" $b_seekfixes
			;;
		q ) 	return
			;;
		esac
	done
}

# show_extops - display the extended operations menu
#
# Presents the Discrete Operations
#
# Globals
# 	b_mrflag
# 	indir
# 	outdir
# 	current_head_trunc
# 	indirstr
# 	outdirstr
# 	lasttag
#
show_extops() {
	local opt
	local extops=$(
cat <<EOF
$MNU\
    $UND\0Discrete Operations $OFF \
$( $b_mrflag || echo -e "\n$MNU R$OFF  Rename mail files in    :$STA $indir$OFF")
$MNU i$OFF  Init to defaults
$MNU h$OFF  help text
$MNU F$OFF  Format commits into      :$STA $outdir
$MNU S$OFF  Seek missing Fixes
$MNU P$OFF  Compare Patches \
 $(show_apply_patches)
$MNU B$OFF  Create a new branch at   :$STA $(get_current_head_trunc)
$MNU C$OFF  Clean the $STA$indirstr$OFF and/or $STA$outdirstr$OFF directories
$MNU G$OFF  Git reset to             :$STA $lasttag
$MNU N$OFF  Nuke the directories and reset head to most recent tag \
 $(show_view_logs)
$OFF

EOF
)
	echo -e "$extops"
}

# show_mr_menu - display the Merge Request opmode of the Main menu
#
# Gobals
# 	lasttag
# 	remote_repo
# 	remote_branch
# 	mergelist_filter
# 	menumode
# 	menumode_ext
#
show_mr_menu() {
	local opt
	local mr_menu=$(
cat <<EOF
$MNU
    $UND\0Environment:$STA $(show_opmode)$MNU Version: $STA$version$OFF
$MNU c$OFF  Config Menu
    Most recent tag          :$STA $lasttag$OFF
    Current Head             :$STA $(get_current_head_trunc)$OFF
$MNU b$OFF  Current git branch       :$STA $(git_getcurrentbranch)$OFF
$(show_patches)
$MNU g$OFF  grep Merge List for      : $(show_mrfilter) \
 $(show_mrstatus)
$MNU
    $UND\0Main Controls     $OFF
$MNU M$OFF  Enter a specific Merge Request for review
$MNU m$OFF  Show the list of Merge Requests and select one for review
$MNU v$OFF  $(show_comments)
$MNU r$OFF  Refresh the list of Merge Requests and select one for review
$MNU a$OFF  Ack, Nack and/or Comment on a Merge Request
$MNU i$OFF  $(show_init)
$MNU q$OFF  Quit this script
$MNU x$OFF  Toggle Discrete Operations display
$OFF

EOF
)
	echo -e "$mr_menu"
	[ $menumode -eq $menumode_ext ] && show_extops
}

# show_email_menu - display the email opmode of the main menu
#
# Globals:
# 	lasttag
#	current_head_trunc
#	remote_repo
# 	remote_branch
#
show_email_menu() {
	local opt
	local email_menu=$(
cat <<EOF
$MNU
    $UND\0Environment:$STA $(show_opmode)$MNU Version: $STA$version$OFF
$MNU c$OFF  Config Menu
    Most recent tag         :$STA $lasttag$OFF
    Current Head            :$STA $(get_current_head_trunc)$OFF
$MNU b$OFF  Current git branch      :$STA $(git_getcurrentbranch)$OFF
$(show_patches)
$MNU
    $UND\0Batch Run Parameters$OFF
$MNU 1$OFF  Compare mode            :$STA $(show_cmpmode)$OFF
$MNU 2$OFF  Patch apply mode        :$STA $(show_applymode)$OFF
$MNU 3$OFF  Patch apply fail mode   :$STA $(show_applyfailmode)$OFF
$MNU 4$OFF  Seek missing Fixes      :$STA $(show_patchseekmode)$OFF \
 $(show_nextpatch)$BLD
$MNU
    $UND\0Main Controls     $OFF
$MNU r$OFF  Run in batch mode
$MNU i$OFF  Init to defaults
$MNU h$OFF  help text
$MNU q$OFF  Quit this script
$MNU x$OFF  Toggle Extended Menu
$OFF
EOF
)
	echo -e "$email_menu"
	[ $menumode -eq $menumode_ext ]  && show_extops
}

menu_parser() {
	get_filecount
	if $b_mrflag; then show_mr_menu; else show_email_menu; fi
	promptgetchar ""$MNU"Enter one of the above: "$OFF"" setting

	case $setting in
		c )	config_parser
			;;
		o )	ui_cycle_state opmode $opmode_states
			set_cfg_item "opmode" $opmode
			if [ $opmode -eq $opmode_mr ]; then b_mrflag=true; else b_mrflag=false; fi
			;;
		g )	grep_mrlist && return $rc_run
			;;
		a )	$b_mrflag && query_acknack
			;;
		m )	$b_mrflag && select_merge_request
			[ $? -eq 0 ] && return $rc_run
			;;
		M )	$b_mrflag && get_merge_request
			[ $? -eq 0 ] && return $rc_run
			;;
		s )	get_remote_seek
			;;
		b )	git_setbranch $branchlist
			git_get_lasttag lasttag $last_tag_file
			;;
		d )	set_dir "$indirstr" "indir" indir
			;;
		w )	set_dir "$outdirstr" "outdir" outdir
			;;
		e )	set_editor
			;;
		f )	set_patchvalfuzz
			;;
		x )	ui_cycle_state menumode $menumode_states
			set_cfg_item "menumode" $menumode
			;;
		R )	$b_mrflag || renpatfiles
			;;
		F )	format_upstream_patches
			;;
		S )	[ -n "$remote_repo" ] && [ -n "$remote_branch" ] || get_remote_seek
			seek_missing_fixes
			;;
		A )	[ $applymode -ne $applymode_off ] && ! $b_allapplied \
				&& exec_apply_patches
			;;
		V )	view_logs
			;;
		1 )	$b_mrflag || { ui_cycle_state cmpmode $cmpmode_states;
				       set_cfg_item "cmpmode" $cmpmode; }
			;;
		2 )	$b_mrflag || { ui_cycle_state applymode $applymode_states;
			               set_cfg_item "applymode" $applymode; }
			;;
		3 )	$b_mrflag || { ui_cycle_state applyfailmode $applyfailmode_states;
			               set_cfg_item "applyfailmode" $applyfailmode; }
			;;
		4 )	$b_mrflag || { ui_cycle_state patchseekmode $patchseek_states;
			               set_cfg_item "patchseekmode" $patchseekmode; }
			;;
		5 )	! $b_mrflag && $b_selpat && select_patch
			;;
		C )	clean_directories
			;;
		N )	nuke
			;;
		G )	reset_to_lasttag
			rm -f $usvbp_commits
			;;
		B )	create_branch
			;;
		P )	compare_patches
			# if [ $opmode -eq $opmode_mr ]; then query_acknack; fi
			;;
		i )	init_menu
			;;
		q )	exit_me 0
			;;
		r )	if $b_mrflag; then
				refresh_mergelist
				[ $? -eq 0 ] && return $rc_run
			else
				set_booleans
				return $rc_run
			fi
			;;
		h )	less $manual
			;;
		v )     view_comments
			;;
#		T )	# test functions
			# hidden from main menu
			# ;;
	esac
	return $rc_continue
}

# init_files
#
# Initialize the global names of the directories and files to be used
# throughout the script.
#
# Globals:
# 	indirstr
# 	outdirstr
# 	indir
# 	outdir
# 	bp_commits_name
# 	us_commits_name
# 	bp_commists
# 	us_commits
# 	usvbp_commits_name
# 	usvp_commits
# 	mismatch_file
#
init_files() {

	# get the patch and work directories.
	#
	indir=$(get_cfg_item indir)
	outdir=$(get_cfg_item outdir)
	bp_commits="$outdir/$bp_commits_name"
	us_commits="$outdir/$us_commits_name"
	usvbp_commits="$outdir/$usvbp_commits_name"
	mmfile="$outdir/$mismatch_file"
	missing_fixes="$outdir/missing_fixes"
}

# init_loopvars - init the global variables used in menus
#
# This needs to be called for every pass through the config and
# main menus.
#
# Globals:
# 	All clearly visible on every line.
#
init_loopvars() {
	editor=$(get_cfg_item editor)
	cmpmode=$(get_cfg_item cmpmode)
	applymode=$(get_cfg_item applymode)
	applyfailmode=$(get_cfg_item applyfailmode)
	patchseekmode=$(get_cfg_item patchseekmode)
	patchvalfuzz=$(get_cfg_item patchvalfuzz)
	menumode=$(get_cfg_item menumode)
	remote_repo=$(get_cfg_item remote_repo)
	remote_branch=$(get_cfg_item remote_branch)
	mergelist_filter=$(get_cfg_item mergelist_filter)
	opmode=$(get_cfg_item opmode)
	[ $opmode -eq $opmode_mr ] && b_mrflag=true
}

# menu_loop - loop containing the call to the menu_parser
#
# The main function of this loop is to init all the variables that are
# presented in the primary and configuration menus, and to call the
# menu_parser function in a loop.
#
function menu_loop {

	get_booleans
	init_files
	init_loopvars

	# delete any "scratch" file from the indir
	#
	rm -f "$indir"/scratch

	local stat=0

	while true; do
		menu_parser
		stat=$?
		# echo "menu_parser_stat: $stat"
		[ $stat -eq $rc_run ] && break
	done
	return $stat
}

###########################################
# Parameter Initialization
###########################################
init_parms() {
	local confline
	local lary
	local cfgdif
	local newcfgstr=$(
cat <<EOF
$INF
There was no$STA $MYDATA/patchreview.conf$INF file, so a new one has been created.

We will need to know:
1. The $STA$indirstr$INF directory to contain the patches for review
2. The $STA$outdirstr$INF directory to contain output from this script
3. Your choice of$STA diff editor$INF
4. The upstream repo/branch to reference 'Seek missing Fixes'.
$OFF
EOF
)
	b_color=true

	# If the config file doens't exist, copy the default one
	# from MYLIB and get the color scheme.
	#
	[ -d "$MYDATA" ] || mkdir $MYDATA
	configfile="$MYDATA/patchreview.conf"

	# If the configfile in $MYLIB has more lines in it than the users
	# configfile, then add the extra lines to the user's config file.
	# The configfile in $MYLIB must always have new lines added to the
	# end. We could create an empty file and copy all the old contents
	# and add the new contents, but why make more work when a little
	# bit of planning ahead goes a long way.
	#
	if [ -f "$configfile" ]; then
		local n_libcfg=$(cat $MYLIB/patchreview.conf | wc -l)
		local n_usrcfg=$(cat $configfile | wc -l)
		local n_cfgdif=$((n_libcfg - n_usrcfg))
		[ $n_cfgdif -eq 0 ] || tail -$n_cfgdif $MYLIB/patchreview.conf >> $configfile
	else
		cp $MYLIB/patchreview.conf $configfile
	fi

	# Init the config globals
	#

	while read confline; do
		ui_strtok "$confline" "= " lary
		eval ${lary[0]}=${lary[1]}
	done < $configfile

	# If color hasn't already been set up, then query the user for terminal
	# background color and init the color engine.
	# Else just init the terminal_background variable from the config global.
	#
	if [ -z "$background" ] ||(( background < 1 || background > 2 )); then
		ui_use_colors
		background=$terminal_background
		set_cfg_item background $terminal_background
		echo
	else
		terminal_background=$background
		ui_set_colors
	fi

	# Trap for control-c
	#
	trap control_c SIGINT

	# ################################################################
	#
	# Init the config fields that must not be blank
	# 	indir
	# 	outdir
	# 	editor
	# 	remote_repo
	# 	remote_branch
	#
	# ################################################################

	[ -z "$indir" ] && {
		set_dir $indirstr "indir" indir
		echo
	}
	[ -z "$outdir" ] && {
		outdir="$indir/tmp"
		set_dir $outdirstr "outdir" outdir
		echo
	}
	[ -z "$editor" ] && set_editor
	([ -z "$remote_repo" ] || [ -z "$remote_branch" ]) && get_remote_seek

	init_booleans
	init_files
	init_loopvars
	get_booleans
}

# main_loop - this is the loop for the top layer of the script
#
# When menu_loop returns, the patchreview is executed using the variables
# and environment selected by the user in the menu_loop.
#
main_loop() {

	local stat

	##############################################
	# Main Program Loop
	##############################################

	while true; do
		menu_loop
		menu_stat=$?
		# echo "menu_loop_stat: $menu_stat"

		if ! $b_mrflag && $b_rename_infiles; then
			exec_boolean "b_rename_infiles" false "renpatfiles"
			[ $? -ne 0 ] && continue
		fi

		if $b_mrflag; then
			format_upstream_patches
		else
			$b_fmt_upstream && format_upstream_patches
		fi

		if [ $patchseekmode -eq $patchseek_on ]; then
			[ -f "$us_commits" ] || format_upstream_patches
			[ -f "$us_commits" ] &&	check_fixes "$us_commits" \
				"$remote_repo/$remote_branch" $b_verbose
		fi

		if [ $applymode -ne $applymode_off ]; then
			exec_apply_patches
			[ $? -ne 0 ] && continue
		fi

		$b_seekfixes && check_fixes "$us_commits" \
			"$remote_repo/$remote_branch" "$missing_fixes" $b_verbose

		if [ $cmpmode -ne $cmpmode_off ]; then
			compare_patches
			[ $? -ne 0 ] && continue
			$b_mrflag && query_acknack
		fi
	done
}

# cmd_check_fixes - execute the -S command line option
#
cmd_check_fixes() {
	local stat=0

	get_filecount
	$b_rename_infiles && exec_boolean "b_rename_infiles" false "renpatfiles"

	[ -n "$remote_repo" ] && [ -n "$remote_branch" ] || get_remote_seek
	[ -f "$us_commits" ] || format_upstream_patches
	[ -f "$us_commits" ] &&	check_fixes "$us_commits" \
		"$remote_repo/$remote_branch" "$missing_fixes" $b_verbose

	return 0
}

cmd_show_verbose() {
	local current_verbose_state
	local next_verbose_state

	if $b_verbose; then
		curr="${STA}ON$OFF"
		next="${STA}OFF$OFF"
	else
		curr="${STA}OFF$OFF"
		next="${STA}ON$OFF"
	fi

	echo -e "set verbose displays $next$INF : currently $curr"
}

cmd_show_status() {
	local statscreen=$(
cat <<EOF

  $MNU${UND}Current $(basename $0) status$INF
  editor    : $STA$editor$INF
  indir     : $STA$indir$INF
  outdir    : $STA$outdir$INF
  branch    : $STA$(git_getcurrentbranch)$INF
  remote    : $STA$remote_repo$MNU/$STA$remote_branch$INF
  verbose   : $STA$($b_verbose && echo "ON" || echo "OFF")$INF
$OFF
EOF
)
	echo -e "$statscreen"
}

# parse_cmdline - command line interface
#
parse_cmdline() {
	local argc=$#
	local cmdlineops=$(
cat <<EOF

  $MNU$(basename $0)$INF command line options and operations$MNU

  version  $INF : show $MNU$(basename $0)$INF version$MNU
  help     $INF : command line help (this text)$MNU
  man      $INF : full patchreview manual$MNU

  editor   $INF ; choose one of three available editors for diff presentation$MNU
  remotes  $INF : choose a remote repo/branch from the ones availaible in your
              .git/config file$MNU

  branch   $INF : choose the branch having the MR or the patches applied$MNU
  indir    $INF : name the directory that contains the patches$MNU
  outdir   $INF : name the directory to contain the upstream git-formatted patches$MNU
  remote   $INF : get the remote repo/branch to be used for upstream fixe$MNU
  verbose  $INF : set screen output to verbose mode$MNU
  quiet    $INF : set screen output to quiet mode$MNU
  status   $INF : show the current status of the above parameters$MNU
  compare  $INF : compare the RHEL patches with upstream and present any diffs in
              the diff editor.$MNU

  rename   $INF : rename patchfiles in $indir, useful if downloaded from a mail client$MNU
  format   $INF : format upstream patches into $STA$outdir$INF using upstream commits from
              patches in $STA$indir$MNU

  seek     $INF : Seek missing fixes in $STA$remote_repo${INF}/$STA$remote_branch
$OFF
EOF
)

	while (( $# > 0 )) ;do
		key="$1"
		case $key in
			"seek" ) 	init_parms; cmd_check_fixes
					shift
					exit
					;;
			"rename" )	rinit_parms; enpatfiles
					shift
					;;
			"format" )  	init_parms; format_upstream_patches
					shift
					;;
			"status" )	cmd_show_status
					exit 0
					;;
			"-P" )		;&
			"compare" )	cinit_parms; ompare_patches
					shift
					;;

			"editor" )	set_editor
					exit 0
					;;

			"branch" )	git_setbranch $branchlist
					exit 0
					;;

			"remote" )	;&
			"remotes" )	get_remote_seek
					exit 0
					;;

			"outdir" )	set_dir "$outdirstr" "outdir" outdir
					shift
					;;

			"indir" )	set_dir "$indirstr" "indir" indir
					shift
					;;

			"-V" )		;&
			"-vv" )		;&
			"verbose" )	;&
			"-verbose" )	b_verbose=true
					set_cfg_item "b_verbose" $b_verbose
					shift
					;;

			"quiet" )	b_verbose=false
					set_cfg_item "b_verbose" $b_verbose
					shift
					;;

			"-v" )		;&
			"version" )	;&
			"-version" )	;&
			"--version" ) 	show_version
					exit 0
					;;

			"-h" )		;&
			"help" )	;&
			"-help" ) 	;&
			"--help" )	echo -e "$cmdlineops"
					exit 0
					;;

			"man" )		less $manual
					exit 0
					;;
			* ) echo -e "$STA$key ${WRN}is an invalid argument!$OFF\n"
			    exit 1
		esac
	done
}

#############################
# main() entry point
#############################
main() {
	local argc=$#

	! $(git_checkrepo) && git_invrepomsg && exit 1

	# Check for "lab" installation for gitlab support
	which lab > /dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo -e "\n"$WRN"You must install the \"lab\" utility$OFF"
		echo -e ""$INF"Please see:$OFF"
		echo -e ""$STA"  https://docs.google.com/document/d/1PLPBqrnV-m4hr8Jos_7dhYGYqtMdiuCZZC72t2ljyEA/edit$OFF\n"
		exit 1
	fi

	init_parms

	if [ $argc -eq 0 ]; then
		git_get_lasttag lasttag $last_tag_file
		main_loop
	else
		parse_cmdline $@
	fi

	exit 0
}

# Call main.
# Exit when done.
#
main $@
exit_me 0
