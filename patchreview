#!/bin/bash
#
# patchreview
#
# This script assumes that you have already extracted your patches into
# the directory named as "indir" below. Only files named "*.patch" will
# be considered.
#
# To create a patch set from email ...
# In mutt, tag the thread you want to extract with esc-t. Untag the
# prologue, as it's not a patch. Then extract the thread into text
# files using ;-esc-C (uppercase C). When prompted for the directory,
# type the name of the mailbox directory or uparrow to the previous
# save.
#
# This script can also be used to compare any two patch sets.
#
# Calls on the following external scripts.
#
# ./githead
# ./patcmp
# ./patbatcmp
# ./patbatcmpmgr
#
# Requires to run ...
#
# ./lib/*.source
# ./.data/patchreview.prj
# ./man/patchreview.man

#######################################
# Default file locations
#######################################
#
# Whatever directory this script and its companions are located in
# must be in the executable path.
#
# export PATH=$PATH:MYDIR
#
# Where MYDIR is the directory in which this script and its companions
# are located.

declare MYDIR=$(dirname $(which $(basename $0)))
declare MYLIB=$MYDIR/lib

#######################################
# External Source Files
#######################################
source $MYLIB/ui.source
source $MYLIB/project.source
source $MYLIB/gitutilities.source
source $MYLIB/patch-common.source
source $MYLIB/patch-mrutilities.source

#########################################
# Functions
#########################################

function init_booleans {
	b_prologue=false

	[ $index -eq 0 ] && return
	for ((index=boolindex; index <= prj_entries; index++)); do
		prj_set_item $index true
	done
}

# get_booleans
#
# Read the values of the program flow control booleans from the
# project file.
#
# removed in v3.0
#	b_restore_githead
#	b_clean_indir
#	b_clean_outdir
#
# added in v 4.0
#	b_patbatcmp
#
# removed in v4.4
# 	b_patcmp
# 	b_patbatcmp
#
# added in v4.4
# 	b_40digit
#
# removed in v5.0
#	b_apply_patches
#
# removed in v7.0
# 	b_save_githead
# 	b_gitam_err_abort
#
# removed in v9.0
#	b_40digit
#
# added in v9.0
#	b_extmenu
#
# removed in v9.1
# 	b_extmenu
#
function get_booleans {
	# echo "patchreview::get_booleans()"
	local bool
	index=$boolindex
	[ $index -eq 0 ] && return
	for bool in \
	b_rename_infiles \
	b_fmt_upstream
	do
		eval $bool=$(prj_get_item $index)
		ui_digit2bool $bool
		let index++
	done
}

# set_booleans
#
# Write the current values of the program flow booleans into the
# project file.
#
# removed in v3.0
#	b_restore_githead \
#	b_clean_indir \
#	b_clean_outdir \
#
# added in v 4.0
#	b_patbatcmp
#
# removed in v4.4
# 	b_patcmp
# 	b_patbatcmp
#
# added in v4.4
# 	b_40digit
#
# removed in v5.0
#	b_apply_patches
#
# removed in v7.0
# 	b_save_githead
# 	b_gitam_err_abort
#
# removed in v9.0
#	b_40digit
#
# added in v9.0
#	b_extmenu
#
# removed in v9.1
# 	b_extmenu
#
function set_booleans {
	# echo "patchreview::set_booleans()"
	local bool
	index=$boolindex
	[ $index -eq 0 ] && return 0
	for bool in \
	b_rename_infiles \
	b_fmt_upstream
	do
		prj_set_item $index ${!bool}
		let index++
	done
	b_prologue=false
	return 0
}

function clean_dir {
	local delquery="Are you sure you want to delete the contents of:"
	local response=false

	getyn "$delquery\n\t$1\n" response
	$response && find "$1" -mindepth 1 -exec rm -rvf '{}' \;
}

clean_indir() {
	# remove everything in the indir, except any subdirs
	find $indir -maxdepth 1 -not -type d -exec rm -vf '{}' \;
	patchcount=0
}

clean_outdir() {
	find "$outdir" -maxdepth 1 -not -type d -exec rm -vf '{}' \;
	rm -vf $outdir/$mismatch_file
}

clean_directories() {
	local answer
	local cleanstr=$(
cat <<EOF

    $BLD$UND\0Clean Directory$OFF
    Select one of$BLD

 1  Clean $OFF$indir$BLD
 2  Clean $OFF$outdir$BLD
 3  Clean both
\0
EOF
)
	echo -e "$cleanstr"
	loop_range_q 1 3 answer
	[ $? -ne 0 ] && return

	case $answer in
		1 ) clean_indir
		    ;;
		2 ) clean_outdir
		    ;;
		3 ) clean_indir
		    clean_outdir
		    ;;
		* ) echo "Not a valid selection for Clean Directories"
	esac
}

# reset_to_lasttag - reset the current branch to its most recent tag
#
# Also checks that the saved lasttag is the same as the lasttag of the
# current branch. If they are not, the reset is not executed and the user
# is warned, because the results would be a merge of two branches.
#
# Globals:
# 	lasttag
#
reset_to_lasttag() {
	local newlasttag
	local head=$(git log --oneline -n1)
	git_get_lasttag newlasttag $last_tag_file
	local errstr=$(
cat <<EOF

$WRN\0Warning
It appears the head was moved outside of this script.$INF
		Current branch: $STA$(git_getcurrentbranch)$INF
Most recent tag of that branch: $STA$lasttag$INF
Most recent tag in this script: $STA$newlasttag$INF

Please switch to the correct branch.
We won't reset the head.$OFF

\0
EOF
)
	[ "$newlasttag" =  "$lasttag" ] || { echo -e "$errstr"; return; }

	echo -e "$BLD\0Resetting git head to$OFF $lasttag."
	git reset --hard $lasttag
	b_allapplied=false
}

# nuke - delete files in indir and outdir, except logs, and reset to lasttag
#
#        Also calls the init sequence.
#
# Globals:
# 	indir
# 	outdir
# 	prj_applymode
# 	applymode
#
nuke() {
	clean_indir
	clean_outdir

	# Reset the git head to the last tag
	reset_to_lasttag

	# Init the booleans to their defaults
	init_booleans
	get_booleans

	# Set the apply mode to its default value
	applymode=$applymode_norm
	prj_set_item $prj_applymode $applymode
}

# show_config_menu - display the configuration options and their current state
#
# Globals:
# 	indir
# 	indirstr
# 	infilecount
# 	outdir
# 	outdirstr
# 	patstr
# 	editor
#
show_config_menu() {
	local config_menu=$(
cat <<EOF
$MNU
    $UND\0Configuration       $OFF
$MNU o$OFF  Operating mode          :$STA $(show_opmode)
$MNU c$OFF  See comments first      :$STA $(show_mrcomments)
$MNU d$OFF  $indirstr directory         :$STA $indir$OFF has$STA $infilecount$OFF $patstr\0files
$MNU w$OFF  $outdirstr directory          :$STA $outdir
$MNU s$OFF  Remote Repo/Branch      :$STA $remote_repo/$remote_branch$OFF
    Remote URL              :$STA$(show_remote_url "$remote_repo")$OFF
$MNU e$OFF  Diff Editor             :$STA $editor
$MNU f$OFF  Patch Validation fuzz   :$STA $(show_patchvalfuzz)
$MNU p$OFF  Cycle Patch Compare Mode:$STA $(show_cmpmode)$OFF
$MNU q$OFF  Quit and return to previous menu
\0
EOF
)
	echo -e "$config_menu"
}

# config_parser - config the options selected from the config menu
#
# Globals
# 	opmode
# 	opmode_mr
# 	opmode_states
# 	b_mrflag
# 	indir
# 	indirstr
# 	prj_indir
# 	outdir
# 	outdirstr
# 	prj_outdir
#
config_parser() {
	local opt

	while :; do
		get_booleans
		init_files
		init_loopvars
		show_config_menu
		promptgetchar ""$MNU"Enter one of the above: "$OFF"" opt

		case $opt in
		o )	change_opmode
			;;
		c )	ui_toggle b_mrcomments
			;;
		d )	prj_set_directory "$indirstr" $prj_indir indir quiet
			;;
		w )	prj_set_directory "$outdirstr" $prj_outdir outdir quiet
			;;
		s )	get_remote_seek
			;;
		e )	set_editor
			;;
		f )	set_patchvalfuzz
			;;
		p )	ui_cycle_state cmpmode $cmpmode_states
			prj_set_item $prj_cmpmode $cmpmode
			;;
		q ) 	return
			;;
		esac
	done
}

# show_extops - display the extended operations menu
#
# Presents the Discrete Operations
#
# Globals
# 	b_mrflag
# 	indir
# 	outdir
# 	current_head_trunc
# 	indirstr
# 	outdirstr
# 	lasttag
#
show_extops() {
	local opt
	local extops=$(
cat <<EOF
$MNU\
    $UND\0Discrete Operations $OFF \
$( $b_mrflag || echo -e "\n$MNU R$OFF  Rename mail files in    :$STA $indir$OFF")
$MNU i$OFF  Init to defaults
$MNU h$OFF  help text
$MNU F$OFF  Format commits into     :$STA $outdir
$MNU S$OFF  Seek missing commits
$MNU P$OFF  Compare Patches \
 $(show_apply_patches)
$MNU B$OFF  Create a new branch at  :$STA $(get_current_head_trunc)
$MNU C$OFF  Clean the $STA$indirstr$OFF and/or $STA$outdirstr$OFF directories
$MNU G$OFF  Git reset to            :$STA $lasttag
$MNU N$OFF  Nuke the directories and reset head to most recent tag \
 $(show_view_logs)
$OFF

EOF
)
	echo -e "$extops"
}

# show_mr_menu - display the Merge Request opmode of the Main menu
#
# Gobals
# 	lasttag
# 	remote_repo
# 	remote_branch
# 	mergelist_filter
# 	menumode
# 	menumode_ext
#
show_mr_menu() {
	local opt
	local mr_menu=$(
cat <<EOF
$MNU
    $UND\0Environment:$STA $(show_opmode)$MNU Version: $STA$version$OFF
$MNU c$OFF  Config Menu
    Most recent tag         :$STA $lasttag$OFF
    Current Head            :$STA $(get_current_head_trunc)$OFF
$MNU b$OFF  Current git branch      :$STA $(git_getcurrentbranch)$OFF
$MNU g$OFF  grep Merge List for     : $(show_mrfilter) \
 $(show_mrstatus)
$MNU
    $UND\0Main Controls     $OFF
$MNU M$OFF  Enter a specific Merge Request for review
$MNU m$OFF  Show the list of Merge Requests and select one for review
$MNU r$OFF  Refresh the list of Merge Requests and select one for review
$MNU a$OFF  Ack, Nack and/or Comment on a Merge Request
$MNU q$OFF  Quit this script
$MNU x$OFF  Toggle Discrete Operations display
$OFF

EOF
)
	echo -e "$mr_menu"
	[ $menumode -eq $menumode_ext ] && show_extops
}

# show_email_menu - display the email opmode of the main menu
#
# Globals:
# 	lasttag
#	current_head_trunc
#	remote_repo
# 	remote_branch
#
show_email_menu() {
	local opt
	local email_menu=$(
cat <<EOF
$MNU
    $UND\0Environment:$STA $(show_opmode)$MNU Version: $STA$version$OFF
$MNU c$OFF  Config Menu
    Most recent tag         :$STA $lasttag$OFF
    Current Head            :$STA $(get_current_head_trunc)$OFF
$MNU b$OFF  Current git branch      :$STA $(git_getcurrentbranch)$OFF
$MNU
    $UND\0Batch Run Parameters$OFF
$MNU 1$OFF  Compare mode            :$STA $(show_cmpmode)$OFF
$MNU 2$OFF  Patch apply mode        :$STA $(show_applymode)$OFF
$MNU 3$OFF  Patch apply fail mode   :$STA $(show_applyfailmode)$OFF
$MNU 4$OFF  Seek missing commits    :$STA $(show_patchseekmode)$OFF \
 $(show_nextpatch)$BLD
$MNU
    $UND\0Main Controls     $OFF
$MNU r$OFF  Run in batch mode
$MNU i$OFF  Init to defaults
$MNU h$OFF  help text
$MNU q$OFF  Quit this script
$MNU x$OFF  Toggle Extended Menu
$OFF
EOF
)
	echo -e "$email_menu"
	[ $menumode -eq $menumode_ext ]  && show_extops
}

menu_parser() {
	get_filecount
	if $b_mrflag; then show_mr_menu; else show_email_menu; fi
	promptgetchar ""$MNU"Enter one of the above: "$OFF"" setting

	case $setting in
		c )	config_parser
			;;
		o )	ui_cycle_state opmode $opmode_states
			prj_set_item $prj_opmode $opmode
			if [ $opmode -eq $opmode_mr ]; then b_mrflag=true; else b_mrflag=false; fi
			;;
		g )	grep_mrlist && return $rc_run
			;;
		a )	$b_mrflag && query_acknack
			;;
		m )	$b_mrflag && select_merge_request
			[ $? -eq 0 ] && return $rc_run
			;;
		M )	$b_mrflag && get_merge_request
			[ $? -eq 0 ] && return $rc_run
			;;
		s )	get_remote_seek
			;;
		b )	git_setbranch $branchlist
			git_get_lasttag lasttag $last_tag_file
			;;
		d )	prj_set_directory "$indirstr" $prj_indir indir quiet
			;;
		w )	prj_set_directory "$outdirstr" $prj_outdir outdir quiet
			;;
		e )	set_editor
			;;
		f )	set_patchvalfuzz
			;;
		x )	ui_cycle_state menumode $menumode_states
			prj_set_item $prj_menumode $menumode
			;;
		R )	$b_mrflag || renpatfiles
			;;
		F )	format_upstream_patches
			;;
		S )	[ -n "$remote_repo" ] && [ -n "$remote_branch" ] || get_remote_seek
			seek_missing_commits
			;;
		A )	[ $applymode -ne $applymode_off ] && ! $b_allapplied \
				&& exec_apply_patches
			;;
		V )	view_logs
			;;
		1 )	$b_mrflag || { ui_cycle_state cmpmode $cmpmode_states;
				       prj_set_item $prj_cmpmode $cmpmode; }
			;;
		2 )	$b_mrflag || { ui_cycle_state applymode $applymode_states;
			               prj_set_item $prj_applymode $applymode; }
			;;
		3 )	$b_mrflag || { ui_cycle_state applyfailmode $applyfailmode_states;
			               prj_set_item $prj_applyfailmode $applyfailmode; }
			;;
		4 )	$b_mrflag || { ui_cycle_state patchseekmode $patchseek_states;
			               prj_set_item $prj_patchseekmode $patchseekmode; }
			;;
		5 )	! $b_mrflag && $b_selpat && select_patch
			;;
		C )	clean_directories
			;;
		N )	nuke
			;;
		G )	reset_to_lasttag
			rm -f $usvbp_commits
			;;
		B )	create_branch
			;;
		P )	compare_patches
			# if [ $opmode -eq $opmode_mr ]; then query_acknack; fi
			;;
		i )	init_menu
			;;
		q )	exit_me 0
			;;
		r )	$b_mrflag && refresh_mergelist || {
				set_booleans
				return $rc_run
			}
			;;
		h )	less $manual
			;;
		v )    show_version
			;;
#		T )	# test functions
			# hidden from main menu
			# ;;
	esac
	return $rc_continue
}

# init_files
#
# Initialize the global names of the directories and files to be used
# throughout the script.
#
# Globals:
# 	prj_indir
# 	prj_outdir
# 	indirstr
# 	outdirstr
# 	indir
# 	outdir
# 	bp_commits_name
# 	us_commits_name
# 	bp_commists
# 	us_commits
# 	usvbp_commits_name
# 	usvp_commits
# 	mismatch_file
#
init_files() {

	# get the patch and work directories.
	#
	check_dir $prj_indir "$indirstr" indir
	check_dir $prj_outdir "$outdirstr" outdir
	bp_commits="$outdir/$bp_commits_name"
	us_commits="$outdir/$us_commits_name"
	usvbp_commits="$outdir/$usvbp_commits_name"
	mmfile="$outdir/$mismatch_file"
}

# init_loopvars - init the global variables used in menus
#
# This needs to be called for every pass through the config and
# main menus.
#
# Globals:
# 	All clearly visible on every line.
#
init_loopvars() {
	editor=$(prj_get_item $prj_editor)
	cmpmode=$(prj_get_item $prj_cmpmode)
	applymode=$(prj_get_item $prj_applymode)
	applyfailmode=$(prj_get_item $prj_applyfailmode)
	patchseekmode=$(prj_get_item $prj_patchseekmode)
	patchvalfuzz=$(prj_get_item $prj_patchvalfuzz)
	menumode=$(prj_get_item $prj_menumode)
	remote_repo=$(prj_get_item $prj_remote_repo)
	remote_branch=$(prj_get_item $prj_remote_branch)
	mergelist_filter=$(prj_get_item $prj_mergelist_filter)
	opmode=$(prj_get_item $prj_opmode)
	[ $opmode -eq $opmode_mr ] && b_mrflag=true
}

# menu_loop - loop containing the call to the menu_parser
#
# The main function of this loop is to init all the variables that are
# presented in the primary and configuration menus, and to call the
# menu_parser function in a loop.
#
function menu_loop {

	get_booleans
	init_files
	init_loopvars

	# delete any "scratch" file from the indir
	#
	rm -f "$indir"/scratch

	local stat=0

	while true; do
		menu_parser
		stat=$?
		# echo "menu_parser_stat: $stat"
		[ $stat -eq $rc_run ] && break
	done
	return $stat
}

###########################################
# Parameter Initialization
###########################################
init_parms() {
	local offset=0
	local index=0
	local stat=0

	# This loop enumerates and counts the items in the project file.
	# Add new booleans to the end of the list.
	# Add new non-boolean parameters before the first boolean, but
	# after all the non-booleans.
	#
	for offset in \
	prj_menumode \
	prj_patchvalfuzz \
	prj_patchseekmode \
	prj_applyfailmode \
	prj_applymode \
	prj_cmpmode \
	prj_editor \
	prj_indir \
	prj_outdir \
	prj_background \
	prj_remote_repo \
	prj_remote_branch \
	prj_mergelist_filter \
	prj_opmode \
	prj_b_rename_infiles \
	prj_b_fmt_upstream
	do
		let index++
		let $offset=$index
		if [ "${offset:3:3}" == "_b_" ]; then
			let boolcount++
			if ! $b_found_first_bool; then
				boolindex=$index
				b_found_first_bool=true
			fi
		fi
	done

	prj_entries=$index
	[ -d "$MYDATA" ] || mkdir $MYDATA

	# Init the project file and test for blank fields that must not be blank
	#
	prj_init_prjfile $MYDATA/patchreview.prj $index \
		$prj_editor \
		$prj_indir \
		$prj_outdir \
		$prj_background
	stat=$?

	# If the above call to prj_init_prjfile returns nonzero, it means that a
	# new project file has been created and its values must be initialized.
	#
	if [ $stat -ne 0 ]; then
		ui_use_colors
		prj_set_item $prj_background $terminal_background # lib/ui.source

		local newprjstr=$(
cat <<EOF
$INF
The project file has changed, or a new one has been created.

We will need to know:
1. The $STA$indirstr$INF directory to contain the patches for review
2. The $STA$outdirstr$INF directory to contain output from this script
3. Your choice of$STA diff editor
$OFF
EOF
)
		echo -e "$newprjstr"
		prj_set_directory "$indirstr" $prj_indir indir quiet
		echo
		prj_set_item $prj_outdir "$indir/tmp"
		prj_set_directory "$outdirstr" $prj_outdir outdir quiet
		echo
		set_editor
		# get_remote_seek
		cmpmode=$cmpmode_batch
		applymode=$applymode_norm
		applyfailmode=$applyfailmode_exit
		patchseekmode=$patchseek_off
		patchvalfuzz=3
		menumode=$menumode_min
		opmode=$opmode_mr
		# remote_repo="origin"
		# remote_branch="master"
		prj_set_item $prj_menumode $menumode
		prj_set_item $prj_cmpmode $cmpmode
		prj_set_item $prj_applymode $applymode
		prj_set_item $prj_applyfailmode $applyfailmode
		prj_set_item $prj_patchseekmode $patchseekmode
		prj_set_item $prj_patchvalfuzz $patchvalfuzz
		prj_set_item $prj_remote_repo $remote_repo
		prj_set_item $prj_remote_branch $remote_branch
		prj_set_item $prj_opmode $opmode
	fi

	b_color=true

	if $b_color; then
		terminal_background=$(prj_get_item $prj_background)
		(( $terminal_background > 0 && $terminal_background < 3 )) || ui_get_screenbackground
		ui_set_colors
	fi

	init_booleans
	init_files
	init_loopvars
	get_booleans
}

# main_loop - this is the loop for the top layer of the script
#
# When menu_loop returns, the patchreview is executed using the variables
# and environment selected by the user in the menu_loop.
#
main_loop() {

	local stat

	##############################################
	# Main Program Loop
	##############################################

	while true; do
		menu_loop
		menu_stat=$?
		# echo "menu_loop_stat: $menu_stat"

		if ! $b_mrflag && $b_rename_infiles; then
			exec_boolean b_rename_infiles false "renpatfiles"
			[ $? -ne 0 ] && continue
		fi

		if $b_mrflag; then
			format_upstream_patches
		else
			$b_fmt_upstream && format_upstream_patches
		fi

		if [ $patchseekmode -eq $patchseek_on ]; then
			[ -f "$us_commits" ] || format_upstream_patches
			[ -f "$us_commits" ] &&	check_fixes "$us_commits" \
				"$remote_repo/$remote_branch"
		fi

		if [ $applymode -ne $applymode_off ]; then
			exec_apply_patches
			[ $? -ne 0 ] && continue
		fi

		if [ $cmpmode -ne $cmpmode_off ]; then
			compare_patches
			[ $? -ne 0 ] && continue
			$b_mrflag && query_acknack
		fi
	done
}

# cmd_check_fixes - execute the -S command line option
#
cmd_check_fixes() {
	local stat=0

	get_filecount
	$b_rename_infiles exec_boolean b_rename_infiles false "renpatfiles"

	[ -f "$us_commits" ] || format_upstream_patches
	[ -f "$us_commits" ] &&	check_fixes "$us_commits" \
		"$remote_repo/$remote_branch"

	return 0
}

# refresh_me - used between releases to update $MYDATA/patchreview.prj
#
# This is likely to change with each release.
#
refresh_me() {
	echo -e "${INF}Refresh $STA$prjfile$INF to new release states.$OFF"
	menumode=$menumode_min
	prj_set_item $prj_menumode $menumode
}

# parse_cmdline - command line interface
#
parse_cmdline() {
	local argc=$#

	init_files
	init_loopvars

	while (( $# > 0 )) ;do
		key="$1"
		case $key in
			"-S" ) 	cmd_check_fixes
				shift
				;;
			"-R" )	renpatfiles
				shift
				;;

			"-v" )		;&
			"version" )	;&
			"-version" )	;&
			"--version" ) 	show_version
					shift
					exit 0
					;;

			"-h" )		;&
			"help" )	;&
			"-help" ) 	;&
			"--help" )	less $manual
					shift
					exit 0
					;;
			"refresh" )	refresh_me
					shift
					exit 0
					;;
			* ) echo -e "$STA$key$WRN is an invalid argument!\n"
			    exit 1
		esac
	done
}

#############################
# main() entry point
#############################
main() {
	local argc=$#

	# Trap for control-c
	#
	trap control_c SIGINT

	! $(git_checkrepo) && git_invrepomsg && exit 1

	# Check for "lab" installation for gitlab support
	which lab > /dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo -e "\n"$WRN"You must install the \"lab\" utility$OFF"
		echo -e ""$INF"Please see:$OFF"
		echo -e ""$STA"  https://docs.google.com/document/d/1PLPBqrnV-m4hr8Jos_7dhYGYqtMdiuCZZC72t2ljyEA/edit$OFF\n"
		exit 1
	fi

	init_parms

	if [ $argc -eq 0 ]; then
		git_get_lasttag lasttag $last_tag_file
		main_loop
	else
		parse_cmdline $@
	fi

	exit 0
}

# Call main.
# Exit when done.
#
main $@
exit_me 0
