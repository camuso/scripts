#!/bin/bash
#
# cherp
#
# Provide some automation for cherrypicking.
#

VERSION="3.0"

#######################################
# Default file locations
#######################################
#
# Whatever directory this script and its companions are located in
# must be in the executable path.
#
# export PATH=$PATH:MYDIR
#
# Where MYDIR is the directory in which this script and its companions
# are located.
#
declare MYDIR
MYDIR="$(dirname "$(which "$(basename "$0")")")"
declare MYLIB="$MYDIR"/lib
declare MYMAN="$MYDIR"/man
declare MYDATA
MYDATA="$(realpath ./.data)"
declare MYHLP="$MYMAN"/cherp.txt
declare MYNAME
MYNAME="$(basename "$0")"

#######################################
# External Source Files
#######################################
source "$MYLIB"/ui.source
source "$MYLIB"/config-manager.source

########################################
# Return and Control Codes
########################################
declare rc_continue=0	# Continue for another pass

declare exit_good=0	# Normal exit
declare exit_conflict=2	# Exit with a conflict
declare exit_reset=3	# Exit after resetting the world
declare exit_bogus=4	# Exit because of bogus commit
declare exit_pending=6	# There are changes pending, so action can't complete
declare exit_nothing=7	# There is nothing to do
declare exit_bad=10	# Exiting from command line call with bad status

declare b_session_inited=false	# boolean to indicate session is inited
declare b_cmdline=false		# boolean indicating a comman line call

#########################################
# Config Variables
#########################################
declare upcmtstartline		# Line in upcommitsfile to start cherrypick
declare dnorighead		# original downstream head at new session
declare lastuphash		# most recently applied upstream commit hash
declare workdir			# scratch directory for the session
declare upcommitsfile		# File of upstream commits to cherry-pick
declare b_conflict		# last attempt generated a conflict
declare updir			# directory with the upstream repo
declare upurl			# the url of the upstream repo
declare uprepo			# the name of the upstream repo
declare upbranch		# the branch of the upstream repo

#########################################
# Global Variables
#########################################
declare -i menupad=36
declare cmtmsgfile=/dev/shm/gcpcmtmsgfile
declare lasthashvalid=false
declare lasttagfile="/dev/shm/gcplasttag"

declare b_new=false		# new session
declare b_single=false		# only perform single cherrypick
declare b_nit=false		# selective cherrypick

declare gitbranch

declare currentuphash
declare currentupcommit

# Default upstream repo
declare upurl="git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git"

# Lines starting with any of these chars will be ignored.
# The '#' indicates a comment, and the '+' indicates already committed.
declare ignore_str="#+"

########################################
# Global Strings
########################################
declare str_herald=
declare str_conflicts=
declare str_bugzilla=
declare str_upstream=
declare str_brew=
declare str_test=

init_global_strings() {
str_herald="\n$MNU${UND}cherp $VERSION - Automates git cherry-pick$OFF\n"
str_conflicts="Conflicts:\n"
}

#########################################
# Functions
#########################################

#===  FUNCTION  ================================================================
#          NAME:  print_herald
#   DESCRIPTION:  Simply print the script's herald defined above
#    PARAMETERS:  Implicit global, str_herald
#       RETURNS:  None
#===============================================================================
function print_herald {
	echo -e "$str_herald"
}

#===  FUNCTION  ================================================================
#          NAME:  exit_cherp
#   DESCRIPTION:  exit this script
#    PARAMETERS:  None
#       RETURNS:  None
#===============================================================================
function exit_cherp {
	# echo -e "$UND\0exit_cherp $1$OFF"
	$b_session_inited && save_session
	exit "$1"
}

#===  FUNCTION  ================================================================
#          NAME:  get_gitbranch
#   DESCRIPTION:  Echos the name of the current git branch
#    PARAMETERS:  None
#       RETURNS:  None
#===============================================================================
function get_gitbranch {
	git branch | grep '\*' | cut -d' ' -f2
}

#===  FUNCTION  ================================================================
#          NAME:  set_gitbranch
#   DESCRIPTION:  Set the branch of the git tree. Presents the user with a list
#                 of numbered git branches from which to choose.
#    PARAMETERS:  None
#       GLOBALS:  workdir
#                 gitbranch
#       RETURNS:  0 if new branch selected, 1 if user did not make a selection
#                 or if the selected branch could not be checked out.
#===============================================================================
function set_gitbranch {
	local index=1
	local linenumber
	local line
	local outline
	local hilite=
	local branchlistfile="$workdir"/branchlist

	echo
	echo -e "${MNU}Select the number of the branch you want to use or press $qstr$INF"
	echo -e "to leave the current selection highlighted below.$OFF"

	git branch > "$branchlistfile"

	while read -r line; do
		[ "${line:0:1}" = "*" ] && hilite="$MNU" || hilite="$INF"
		outline=$(printf "%s %2d %s $line\n" "$hilite" $index "$OFF")
		echo -e "$outline"
		((++index))
	done < "$branchlistfile"

	# echo -e "$brmsg"
	loop_range_q 1 $((index - 1)) linenumber || return 0

	gitbranch="$(ui_readline "$linenumber" "$branchlistfile" | tr -d [\*" "])"
	echo -e "${MNU}git checkout $STA$gitbranch$OFF"
	git am --abort --quiet >/dev/null 2>&1
	git checkout "$gitbranch" || {
		$b_cmdline && exit_cherp $exit_pending;
		return 1
	}

	git log --oneline -1
	getlasttag
	$b_cmdline && exit_cherp $exit_good || return 0
}

#===  FUNCTION  ================================================================
#          NAME:  git_set_subjectprefix
#   DESCRIPTION:  Set the subject prefix in .git/config
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
git_set_subjectprefix() {
	local newpfx
	newpfx="$(git config format.subjectprefix)"

	echo -e "$INF" \
"Just press ${STA}ENTER$INF to leave the current subject prefix unchanged.$OFF"
	getuser "${MNU}New subject prefix: $OFF" newpfx
	[ "$newpfx" ] || return
	git config format.subjectprefix "$newpfx"
}

# set_dir - set a directory variable and save it in the config file
#
# Arguments
#   $1 - string to be used in the prompt describing the directory
#   $2 - the config file key for the directory variable name
#   $3 - the current value of the directory variable. Will be updated
#        if the user changes the directory name.
#
set_dir() {
	local dirstr="$1"
	local dircfgkey="$2"
	local dir="${!3}"
	local b_msgshown=false
	local ndirmsg

	ndirmsg=$(
cat <<EOF
$INF
This directory has not yet been named.
You must provide a directory path for me to continue.
If the path does not exist, I will offer to create it
for you.
$OFF
EOF
)
	[ -n "$dir" ] && {
		echo -e "${INF}Current $STA$dirstr$INF directory : $STA$dir$OFF"
		echo -e "${INF}Type $qstr$INF to leave it as it is.$OFF"
	}

	# We can't accept a NULL directory name, so cycle until we get a name.
	#
	while :; do
		ui_getnewdir "${INF}New $STA$dirstr$INF directory : $OFF" dir

		if [ -n "$dir" ]; then
			[ -d "$dir" ] || mkdir -p "$dir"
			break
		else
			$b_msgshown || echo -e "$ndirmsg"
			b_msgshown=true
		fi
	done

	dir=$(realpath "$dir")
	set_cfg_item "$dircfgkey" "$dir"
	echo -e "$INF$dirstr directory is $STA$dir$OFF\n"
	eval "$3"="$dir"
}

#===  FUNCTION  ================================================================
#          NAME:  set_working_directory
#   DESCRIPTION:  Set the working directory for the script's output.
#    PARAMETERS:  none
#       GLOBALS:  workdir
#       RETURNS:  none
#===============================================================================
set_working_directory() {
	# echo -e "$UND\0set_working_directory$OFF"

	echo -e "${INF}The working directory is used for scratch by this script.$OFF"
	[ "$workdir" ] && echo -e "$STA$workdir$OFF"
	set_dir "working" "workdir" workdir
}

#===  FUNCTION  ================================================================
#          NAME:  set_upstream_directory
#   DESCRIPTION:  Set the upstream directory having the upstream repo
#    PARAMETERS:  none
#       GLOBALS:  updir
#                 upurl
#       RETURNS:  none
#===============================================================================
set_upstream_directory() {
	# echo -e "$UND\0set_upstream_directory$OFF"
	local newdir=

	echo -e "${INF}The upstream directory has the upstream repo.$OFF"
	[ "$updir" ] && echo -e "${INF}Current upstream dir: $STA$updir$OFF"
	set_dir "upstream" "updir" newdir

	[ "$newdir" == "$updir" ] || { [ "$uprepo" ] && git remote rm "$uprepo"; }
	updir="$newdir"

	cd "$updir" || { echo -e "${WRN}Unable to ${MNU}cd $updir$OFF"; return 1; }
	select_remrepo uprepo
	select_rembranch "$uprepo" upbranch
	upurl=$(show_remote_url "$uprepo")

	cd - || { echo -e "${WRN}Unable to ${MNU}cd -$OFF"; return 1; }
	[ "$uprepo" == "origin" ] && uprepo="upstream"
	set_cfg_item "uprepo"   "$uprepo"
	set_cfg_item "upurl"    "$upurl"
	set_cfg_item "upbranch" "$upbranch"
	git remote add "$uprepo" "$upurl"
	git fetch -p --all
	return 0
}

fetch_upstream_repo() {
	echo -e "${INF}Adding url: $UND$STA$upurl$OFF"
	echo -e "${INF}as \"upstream\""
	echo -e "${INF}Type: ${MNU}git branch -r | grep upstream$OFF"
	echo -e "${INF}to see the upstream remote and its branches$OFF"
	git remote add upstream "$upurl"
	git fetch upstream
}

#===  FUNCTION  ================================================================
#          NAME:  set_upstream_repo
#   DESCRIPTION:  Set the upstream directory having the upstream repo
#    PARAMETERS:  none
#       GLOBALS:  updir
#                 upurl
#       RETURNS:  none
#===============================================================================
set_upstream_repo() {
	local temp=
	local mypid
	local surmsg=$(
cat <<EOF
$INF
Default upstream repo is the linus main branch: $STA$UND
$upurl$OFF$INF
Press ENTER if this is ok, or enter a different upstream repo.
$OFF
EOF
)
	echo -e "$surmsg"
	read -r temp
	[ -n "$temp" ] && upurl="$temp"
	fetch_upstream_repo & mypid=$!
	ui_waitonproc_tty $mypid .05 "${INF}Fetching upstream repo$OFF"
}

show_remote_url() {
	local reponame="$1"
	local url
	[ -z "$reponame" ] && return
	url=$(grep -A1 "remote \"$reponame" .git/config | grep url | cut -d'=' -f2)
	echo "$url"
}

show_remotes() {
	local line
	local toks=()
	local gitcfgarray=()
	local remoteurl=
	local remote=

	gitcfgarray=("$(grep -w '\[remote' .git/config)")
	while read -r line; do
		ui_strtok "$line" '" ' toks
		remote="${toks[1]}"
		remote="${remote//]/}"
		remoteurl=$(show_remote_url "$remote")
		echo -e "$remote"
		echo -e "$remoteurl"
		echo
	done <<< "${gitcfgarray[@]}"
}

create_remote_array() {
	local -n remarray=$1
	local line
	local remote=
	local toks=()
	local gitcfgarray=()

	gitcfgarray=("$(grep -w '\[remote' .git/config)")
	while read -r line; do
		ui_strtok "$line" '" ' toks
		remote="${toks[1]}"
		remote="${remote//]/}"
		remarray+=("$remote")
	done <<< "${gitcfgarray[@]}"
}

select_remrepo() {
	local cur="${!1}"
	local remotes=()
	local num_of_remotes
	local stat

	create_remote_array remotes
	num_of_remotes=${#remotes[@]}

	case $num_of_remotes in
		0 ) echo -e "${WRN}No remotes could be detected in .git/config.$OFF"
		    return 1
		    ;;
		1 ) cur="${remotes[0]}"
		    stat=0
		    ;;
		* ) select_from_array remotes "remote repos" cur
		    stat=$?
	esac

	eval "$1"="$cur"
	return $stat
}

set_remote_url() {
	local reponame="$1"
	local url
	[ -z "$reponame" ] && return
	url=$(grep -A1 "remote \"$reponame" .git/config | grep url | cut -d'=' -f2)
	echo "$url"
}

select_rembranch() {
	local repo="$1"
	local cur="${!2}"
	local brstr=
	local brancharray=()

	# Get all the branches into one string
	brstr=$(git branch -r | grep "$repo" | cut -d'/' -f2)

	# Filter out lines with '-> in them, because they are not branches
	while read -r s; do [[ $s == *"->"* ]] || brancharray+=("$s"); done <<< "$brstr"

	if [ ${#brancharray[@]} -gt 1 ]; then
		select_from_array brancharray "remote branches in $repo" cur
	else
		cur=${brancharray[0]}
		echo -e "$INF Only one branch in this repo: $STA$cur$OFF"
		echo -e "$INF Nothing else to choose from.$OFF"
	fi

	eval "$2"="$cur"
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  set_upcommitsfile
#   DESCRIPTION:  Sets the name of the file that contains the commits to
#                 be cherrypicked.
#    PARAMETERS:  none
#       GLOBALS:  upcommitsfile - file containing the commits to be cherrypicked
#       RETURNS:  status of call to ui_getfilespec()
#===============================================================================
function set_upcommitsfile {
	local stat
	local prstr
	local commitsfilemsg
	local exitmsg
	local currentfile

	prstr=$(
cat <<EOF
$INF
Set the file containing the upstream commits to be cherry-picked$OFF
EOF
)
	commitsfilemsg=$(
cat <<EOF
$INF
You can create a file containing the upstream commits to be cherry-picked
using the following command.

  git log --oneline --reverse <commit-expression> [-- path] > <commits-file>

  Example:

  git log --oneline --reverse v4.12..HEAD -- drivers/usb/host > usb-commits.log
$OFF
\0
EOF
)
	exitmsg=$(
cat <<EOF
$INF
You pressed $qstr$INF without providing a file containing the upstream commits
to be cherry-picked, so we must exit.$OFF
\0
EOF
)
	currentfile=$(
cat <<EOF
${INF}The current file is $STA$upcommitsfile$INF.
Press $qstr$INF at the prompt to use this file.$OFF
EOF
)
	# echo -e "$UND\0set_upcommitsfile$OFF"

	[ "$upcommitsfile" ] && prstr="$prstr.\n$currentfile"
	ui_getfilespec "$prstr : " upcommitsfile
	stat=$?

	if [ $stat -ne 0 ]; then
		if [ "$upcommitsfile" ]; then
			echo -e "${INF}Keeping: $STA$upcommitsfile$OFF"
		else
			echo -e "$exitmsg"
			echo -e "$commitsfilemsg"
			exit 0
		fi
	fi

	upcommitsfile="$(realpath "$upcommitsfile")"
	set_cfg_item "upcommitsfile" "$upcommitsfile"
	return $stat
}

#===  FUNCTION  ================================================================
#          NAME:  pr_nohash_msg
#   DESCRIPTION:  Prints message indicating the hash can't be found in the file
#                 containing the upstream commits.
#    PARAMETERS:  $1 - hash
#       GLOBALS:  upcommitsfile - file of upstream commits to cherrypick
#       RETURNS:  none
#===============================================================================
pr_nohash_msg () {
	local hash="$1"
	local nohash_msg

	nohash_msg=$(
cat <<EOF
$INF
  Cannot find $STA$hash$INF as a commit or valid line number in $STA$upcommitsfile$INF
  Lines having a '$STA\0#$INF' as their first character are not listed or considered.
  Try again or type $qstr$INF to return to main menu.$OFF
EOF
)
	echo -e "$nohash_msg"
}

#===  FUNCTION  ================================================================
#          NAME:  lookup_hash
#   DESCRIPTION:  Find the given hash in the commits file
#    PARAMETERS:  $1 - hash
#                 $2 - will return the number of the line in the commits file
#                      that has the hash.
#       GLOBALS:  upcommitsfile - file of upstream commits to cherrypick
#       RETURNS:  nonzero if lookup fails
#===============================================================================
lookup_hash() {
	local hash=$1
	local counter
	local line

	[[ -f "$upcommitsfile" ]] || return 1

	counter=$(grep -m1 -n "^$hash" "$upcommitsfile" | cut -d':' -f1)

	[ -z "$counter" ] && return 1

	eval "$2"="$counter"
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  set_next_cherrypick
#   DESCRIPTION:  Select the starting commit from the upcommitsfile.
#    PARAMETERS:  none
#       GLOBALS:  upcommitsfile - file of upstream commits to cherrypick
#                 upcmtstartline- starting line for upcommitsfile
#                 currentupcommit - global storage for current upstream commit
#                 currentuphash - global storage for current upstream cmt hash
#                 tlines        - number of lines in the terminal window
#                 tcols         - number of columns in the terminal window
#                 qstr          - string with a boldfaced 'q'
#                 ignore_str    - string of comment chars in commits log
#       RETURNS:  none
#===============================================================================
set_next_cherrypick() {

	# echo -e "$UND\0set_next_cherrypick$OFF"
	$b_cmdline && init_cmdline_call

	local counter=0
	local line
	local linary
	local idx=0
	local stat
	local linecount
	local numwid=${#linecount}
	local cols=$((tcols - 2 - numwid))
	local selected

	linecount=$(iwc -l "$upcommitsfile")
	echo -e "\n${INF}Contents of upstream commits file: $STA$upcommitsfile$OFF"
	echo -e "$MNU\0NOTE:$INF Not showing lines starting with any of these chars:"\
	        "$STA$ignore_str$OFF\n"

	# Dump the contents of the upcommitsfile
	#
	while read -r line; do
		((++counter))
		[ "$(ui_strindex "$ignore_str" "${line:0:1}")" -ge 0 ] && continue
		line=$(printf "%s %${numwid}d %s%s%s" "$MNU" $((idx+1)) "$OFF" "$line")
		echo -e "${line:0:cols}$OFF"
		linary[$idx]=$counter
		((++idx))
	done < "$upcommitsfile"

	echo
	loop_range_q 1 "$idx" selected
	[ "$selected" = "q" ] || upcmtstartline=${linary[$((selected - 1))]}
	currentupcommit="$(ui_readline "$upcmtstartline" "$upcommitsfile")"
	# echo "currentupcommit: $currentupcommit"
	currentuphash=$(echo "$currentupcommit" | cut -d' ' -f1)
	$b_cmdline && exit_cherp $exit_good
}

#===  FUNCTION  ================================================================
#          NAME:  validate_last_upstream_hash
#   DESCRIPTION:  validates whether the hash stored in the project file is
#                 valid for this instance of cherp
#    PARAMETERS:  none
#       GLOBALS:  upcommitsfile - the cherry-pick commits file containing the
#                                 hashes of the commits to be backported.
#                 lasthashvalid - boolean indicating last hash was valid
#       RETURNS:  nonzero if the last stored hash is not valid
#===============================================================================
validate_last_upstream_hash() {

	lasthashvalid=true

	# If we don't have a commits file, show nothing
	#
	[[ -f $upcommitsfile ]] || lasthashvalid=false

	# If there is no hash saved in the config file, then show nothing.
	#
	[[ "$lastuphash" ]] || lasthashvalid=false

	# If the commit stored in the config file is not in the commits file
	# then show nothing.
	#
	grep -m1 -n "$lastuphash" "$upcommitsfile" >/dev/null 2>&1 || lasthashvalid=false

	$lasthashvalid && lastuplog=$(git log -n1 --oneline "$lastuphash")
	$lasthashvalid && return 0 || return 1
}

#===  FUNCTION  ================================================================
#          NAME:  getlasttag
#   DESCRIPTION:  Show dots while obtaining the latest git tag
#    PARAMETERS:  none
#       GLOBALS:  lasttagfile
#       RETURNS:  none
#===============================================================================
getlasttag() {
	local _mypid_
	echo -ne "$INF\0Getting last git tag..$OFF"
	git describe --tags --abbrev=0 > "$lasttagfile" &
	_mypid_=$!
	ui_waitonproc $_mypid_ .1
	echo
}

#===  FUNCTION  ================================================================
#          NAME:  get_next_cherrypick
#   DESCRIPTION:  Gets the next commit in the commits file that doesn't have a
#                 leading hash.
#    PARAMETERS:  none
#       GLOBALS:  upcommitsfile
#                 upcmtstartline
#                 currentuphash
#                 ignore_str
#       OUTPUTS:  echoes the hash of next upstream commit in the commits file
#       RETURNS:  1 if there are no more cherries to pick, else 0
#===============================================================================
get_next_cherrypick() {
	# local myname="get_next_cherrypick: "
	# echo -e "\n$UND$myname$OFF start line: $upcmtstartline"

	[[ -f "$upcommitsfile" ]] || return 1

	local idx
	local line
	local count

	count=$(wc -l "$upcommitsfile" | cut -d' ' -f1)

	# Find the first line that does NOT begin with one of the characters in the
	# string of characters indicating the line is to be ignored.
	#
	for ((idx=(upcmtstartline + 1); idx <= count; ++idx)); do
		line="$(ui_readline "$idx" "$upcommitsfile")"
		[ "$(ui_strindex "$ignore_str" "${line:0:1}")" -ge 0 ] || break
	done

	if [ "$idx" -gt "$count" ]; then
		echo -en "$STA${currentupcommit:0:$tcols}$OFF "
		echo -e "${INF}was the last upstream commit in file: $STA$upcommitsfile$OFF"
		return 1
	fi

	upcmtstartline=$idx
	currentupcommit="$line"
	currentuphash=$(echo "$line" | cut -d' ' -f1)
	set_cfg_item "upcmtstartline" "$upcmtstartline"

	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  get_current_cherrypick
#   DESCRIPTION:  Gets the current commit in the commits file indicated by the
#                 current upcmtstartline.
#
#                 Because get_next_cherrypick always pre-increments the
#                 upcmtstartline, this routine will decrement the upcmtstartline
#                 before calling get_next_cherrypick.
#
#    PARAMETERS:  none
#       GLOBALS:  upcmtstartline
#       OUTPUTS:  echoes the hash of next upstream commit in the commits file
#       RETURNS:  status of call to get_next_cherrypick
#===============================================================================
get_current_cherrypick() {
	# local myname="get_current_cherrypick:"
	# echo -e "$OFF\n$UND$myname upcmtstartline: $upcmtstartline$OFF"

	((--upcmtstartline))
	# echo "$myname startline: $upcmtstartline"
	get_next_cherrypick
	return $?
}

#===  FUNCTION  ================================================================
#          NAME:  show_next_cherrypick
#   DESCRIPTION:  Show the upstream commit we will be starting from
#    PARAMETERS:  $1 - if contains "status", then it's a status only call
#       GLOBALS:  upcommitsfile
#                 currentupcommit
#       RETURNS:  none
#===============================================================================
show_next_cherrypick() {
	# echo "\n${UND}show_next_cherrypick$OFF"

	local linecount
	local prstr
	local statstr
	local leadstr
	local cols=$((tcols - menupad))
	local show_next_cherrypick_str
	local eofstr

	eofstr=$(
cat <<EOF
$STA$currentuphash ${INF}was the last commit in file: $STA$upcommitsfile$OFF

EOF
)
	$b_cmdline && leadstr="    " || leadstr="$MNU c$OFF  "
	$b_conflict && statstr="${WRN}Current conflict         :$OFF" \
		    || statstr="Next cherrypick          :$OFF"

	get_current_cherrypick	&& prstr="$STA${currentupcommit:0:$cols}$OFF" \
				|| prstr="$eofstr"


	show_next_cherrypick_str=$(
cat <<EOF

$leadstr$statstr $prstr
EOF
)
	[ "$currentuphash" == "" ] || echo -e "$show_next_cherrypick_str"
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  show_select_next_cherrypick
#   DESCRIPTION:  Show option to select a commit from the upstream commits file.
#    PARAMETERS:  none
#       GLOBALS:  upcommitsfile
#       RETURNS:  none
#===============================================================================
show_select_next_cherrypick() {
	# echo -e "${UND}show_select_next_cherrypick$OFF"

	local selcmt_str

	selcmt_str=$(
cat <<EOF

$MNU S$INF  Select a different commit for next cherrypick$OFF
EOF
)
	[[ -f $upcommitsfile ]] || return 1
	echo -e "$selcmt_str"
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  show_most_recent_cherrypick
#   DESCRIPTION:  Show the Last Upstream Commit Picked, if it is valid
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
show_most_recent_cherrypick() {
	# echo -e "\n${UND}show_most_recent_cherrypick$OFF"

	local cols=$((tcols - menupad))
	local laststr

	laststr=$(
cat <<EOF

    Last Applied Commit      : $STA${lastuplog:0:$cols}$OFF
EOF
)
	$lasthashvalid && echo -e "$laststr"
}

#===  FUNCTION  ================================================================
#          NAME:  show_upsteam_commits_file
#   DESCRIPTION:  Show the Upstream Commit File
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
show_upsteam_commits_file() {
	# echo -e "${UND}show_upsteam_commits_file$OFF"

	local cmtfilestr

	cmtfilestr=$(
cat <<EOF

    File of upstream commits : $STA$upcommitsfile$OFF
EOF
)
	[ "$upcommitsfile" ] || return
	[ -f "$upcommitsfile" ] && echo -e "$cmtfilestr"
}

#===  FUNCTION  ===============================================================
#          NAME:  show_history
#   DESCRIPTION:  show history of applied patches in downstream branch
#    PARAMETERS:  none
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#       RETURNS:  none
#===============================================================================
show_history() {
	$b_cmdline && init_cmdline_call
	echo -en "$INF$(git log --oneline "$dnorighead"..HEAD)$OFF"
	$b_cmdline && exit 0
	return 0
}

#===  FUNCTION  ===============================================================
#          NAME:  show_status
#   DESCRIPTION:  show the current status
#    PARAMETERS:  $1 - If this argument is not empty, then forego the
#                      init_cmdline_call
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#       RETURNS:  none
#===============================================================================
show_status() {
	# echo -e "$UND\0show_status$OFF"

	local cols=$((tcols - menupad))
	local subjectprefix
	local lasttag
	local lastbrcmt
	local orighead
	local statstr
	local b_internal

	subjectprefix="$(git config format.subjectprefix)"
	[ "$1" ] && b_internal=true || b_internal=false

	$b_internal || init_cmdline_call

	# [ -f lasttagfile ] || git describe --tags --abbrev=0 > $lasttagfile
	# lasttag=$(cat $lasttagfile)
	lastbrcmt=$(git log -n1 --oneline)
	orighead=$(git log --oneline -n1 "$dnorighead")

	statstr=$(
cat <<EOF
$INF$(show_upsteam_commits_file)\
$INF$(show_most_recent_cherrypick)\
$INF$(show_next_cherrypick)
$INF    Current downstream branch: $STA$(get_gitbranch)
$INF    Current downstream head  : $STA${lastbrcmt:0:cols}
$INF    Original downstream head : $STA${orighead:0:cols}$OFF
\0
EOF
)
	echo -e "$statstr"
	git status
	$b_internal || exit 0
}

show_options() {
	local options

	options=$(
cat <<EOF
$MNU
        ${UND}Options          $OFF
    $MNU u $OFF Upstream status          : $STA$str_upstream$OFF
    $MNU z $OFF Bugzilla link            : $STA$str_bugzilla$OFF
    $MNU b $OFF Brew or build info       : $STA$str_brew$OFF
    $MNU t $OFF Test information         : $STA$str_test$OFF
    $MNU p $OFF Current subject prefix   : $STA$subjectprefix$OFF
    $MNU q $OFF Quit to main menu
\0
EOF
)
	echo -e "$options"
}

get_options() {
	local opt=

	show_options
	promptgetchar "${MNU}    Enter one of the above: $OFF" opt

	case $opt in
		z )	getuser "${MNU}Bugzilla link: $OFF" str_bugzilla
			set_cfg_item "str_bugzilla"  "$str_bugzilla"
			;;
		u )     getuser "${MNU}Upstream status: $OFF" str_upstream
			set_cfg_item "str_upstream"  "$str_upstream"
			;;
		b )	getuser "${MNU}Brew or build info: $OFF" str_brew
			set_cfg_item "str_brew"      "$str_brew"
			;;
		t )	getuser "${MNU}Testing info: $OFF" str_test
			set_cfg_item "str_test"      "$str_test"
			;;
		p )	git_set_subjectprefix
			;;
		q )	return 1
	esac

	return 0
}

options_loop() {
	while :; do
		get_options || return
	done
}



#===  FUNCTION  ===============================================================
#          NAME:  show_settings
#   DESCRIPTION:  show the current settings and present the menu options
#    PARAMETERS:  none
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#       RETURNS:  none
#===============================================================================
function show_settings {
	# echo -e "$UND\0show_settings$OFF"
	local cols=$((tcols - menupad))
	local subjectprefix
	local lasttag
	local lastbrcmt
	local orighead
	local settings

	subjectprefix="$(git config format.subjectprefix)"
	lasttag=$(cat $lasttagfile)
	lastbrcmt=$(git log -n1 --oneline)
	orighead=$(git log --oneline -n1 "$dnorighead")

	settings=$(
cat <<EOF
$MNU
    ${UND}Upstream Environment    $OFF
$MNU b$OFF  File of Backport Commits : $STA$upcommitsfile$OFF\
$(show_most_recent_cherrypick)\
$(show_next_cherrypick)
$MNU
    ${UND}Downstream Environment  $OFF
    Most recent tag          : $STA$lasttag$OFF
    Original Head            : $STA${orighead:0:cols}$OFF
    Current Head             : $STA${lastbrcmt:0:cols}$OFF
$MNU B $OFF Current git branch       : $STA$(get_gitbranch)$OFF
$MNU b $OFF Backport File            : $STA$upcommitsfile$OFF
$MNU w $OFF Working directory        : $STA$workdir$OFF
$MNU u $OFF Upstream directory       : $STA$updir$OFF
$MNU O $OFF Options menu
$MNU
    ${UND}Control                $OFF
$MNU N $OFF Start a New Session
$MNU P $OFF Pop 'n' commits
$MNU H $OFF Show History
$MNU r $OFF Run cherp
$MNU q $OFF Quit this script
$MNU h $OFF Help
$OFF
EOF
)
	echo -e "$settings"
}

#===  FUNCTION  ================================================================
#          NAME:  menu_parser
#   DESCRIPTION:  parse the user input at the menu prompt
#    PARAMETERS:  none, but lots of side effects
#       RETURNS:  rc_continue, used by menu_loop to determine whether to
#       	  continue looping.
#===============================================================================
function menu_parser {
	# echo -e "$UND\0menu_parser$OFF"

	local pops
	local setting=

	validate_last_upstream_hash
	show_settings
	promptgetchar "${MNU}Enter one of the above: $OFF" setting

	case $setting in

		B )	set_gitbranch
			;;
		w )	set_working_directory
			;;
		b )	set_upcommitsfile
			;;
		U )     set_upstream_directory
			;;
		c )	set_next_cherrypick
			;;
		N )	init_newsession
			;;
		H )	show_history
			;;
		P )     getuser "${MNU}Pop how many commits: $OFF" pops
			pop_commits "$pops"
			;;
		h )	less "$MYHLP"
			;;
		q )	exit_cherp $exit_good
			;;
		r )	run_me
			;;
		O )	options_loop
	esac
	return $rc_continue
}

#===  FUNCTION  ================================================================
#          NAME:  menu_loop
#   DESCRIPTION:  Infinite loop presenting the menu until user quits
#    PARAMETERS:  none, but lots of side effects
#       GLOBALS:  workdir
#                 cmtmsgfile
#                 upcommitsfile
#       RETURNS:  stat, which is the value returned by the call to menu_parser
#===============================================================================
function menu_loop {

	local stat=0

	cmtmsgfile="$workdir/.gcpgitlog"

	while :; do
		menu_parser
		stat=$?
		# echo "menu_parser_stat: $stat"
	done
	return $stat
}

#===  FUNCTION  ================================================================
#          NAME:  edit_commit
#   DESCRIPTION:  Loop through process to edit commit message until done
#    PARAMETERS:  none
#       GLOBALS:  cmtmsgfile
#       RETURNS:  none
#===============================================================================
edit_commit() {
	local yup

	while :; do
		# Display the git log message and inquire if it needs more
		# editing.
		#
		git log -n1 > "$cmtmsgfile"
		cat "$cmtmsgfile"
		echo
		getyn "Edit this commit message?" yup

		if $yup; then git commit --amend else break; fi
	done
}

#===  FUNCTION  ================================================================
#          NAME:  abort_cherp
#   DESCRIPTION:  Exit the script in an orderly fashion.
#    PARAMETERS:  $1 - true if command line call
#       GLOBALS:  none
#       RETURNS:  none
#===============================================================================
abort_cherp() {
	init_cmdline_call
	git cherry-pick --abort 2>/dev/null
	b_conflict=false
	exit_cherp $exit_good
}

#===  FUNCTION  ================================================================
#          NAME:  reset_cherp
#   DESCRIPTION:  Exit the script in an orderly fashion.
#    PARAMETERS:  $1 - exit code
#       GLOBALS:  dnorighead
#                 upcommitsfile
#                 dnappliedfile
#                 lastuplog
#       RETURNS:  none
#===============================================================================
reset_cherp() {
	local cols=$((tcols - 12))
	local orighead

	orighead=$(git log --oneline -n1 "$dnorighead")
	init_cmdline_call
	git cherry-pick --abort 2>/dev/null
	git reset --hard "$dnorighead"
	b_conflict=false
	upcmtstartline=0
	get_next_cherrypick
	exit_cherp $exit_reset
}

#===  FUNCTION  ================================================================
#          NAME:  run_continue
#   DESCRIPTION:  Continue the cherrypick loop after resolving conflicts and
#                 committing the changes externally to this script.
#    PARAMETERS:  none
#       GLOBALS:  none
#       RETURNS:  none
#===============================================================================
run_continue() {
	# echo -e "$UND\0run_continue$OFF"

	local statstr
	local gitstat

	statstr=$(
cat <<EOF
You have made changes that must be committed before using "cherp continue".
You can use "cherp commit" if you want cherp to make these commits for you.
EOF
)

	gitstat=$(git status --porcelain)
	[ "$gitstat" ] && { echo -e "$statstr"; git status; exit $exit_pending; }

	init_cmdline_call
	git cherry-pick --continue
	b_conflict=false
	get_next_cherrypick
	run_me
}

#===  FUNCTION  ================================================================
#          NAME:  run_commit
#   DESCRIPTION:  Return from resolving conflicts, but let the script commit
#                 your changes and create the commit log.
#    PARAMETERS:  none
#       GLOBALS:  none
#       RETURNS:  none
#===============================================================================
run_commit() {
	# echo -e "$UND\0run_commit$OFF"

	local gitstat

	gitstat=$(git status --porcelain)
	[ "$gitstat" ] || { git status && exit $exit_nothing; }

	init_cmdline_call
	b_conflict=true
	currentuphash=$lastuphash
	stage_commit

	exit_cherp $exit_good
	# get_next_cherrypick
	# run_me
}

#===  FUNCTION  ================================================================
#          NAME:  run_single
#   DESCRIPTION:  Just cherrypick one commit
#    PARAMETERS:  none
#       GLOBALS:  none
#       RETURNS:  none
#===============================================================================
run_single() {
	local stat

	echo -e "$UND\0run_single$OFF"
	b_single=true

	dnorighead=$(git log --oneline -1 | cut -d' ' -f1)
	set_cfg_item "dnorighead" "$dnorighead"
	set_cfg_item "lastuphash" "$currentuphash"

	cherrypick
	stat=$?
	exit $stat
}

#===  FUNCTION  ================================================================
#          NAME:  cherrypick
#   DESCRIPTION:  Given a commit, try to cherry pick it
#    PARAMETERS:  none
#       GLOBALS:  upcommitsfile
#                 commit
#                 tcols
#                 currentuphash
#                 lastuphash
#                 b_conflict
#                 b_single
#       RETURNS:  non-zero if something went wrong
#===============================================================================
cherrypick() {
	# echo -e "$UND\0cherrypick$OFF"

	local uphash=$currentuphash
	local gitstat
	local wcols=$((tcols - 10))
	local conflictmsg
	local bogusmsg

	conflictmsg=$(
cat <<EOF

$UND$WRN\0You have conflicts to fix.$OFF$INF

After fixing the conflicts, you can reenter cherp with the following commands.

$MNU\0cherp commit$INF   : if you have fixed the conflicts and want the script to stage
                 the commit and create the commit log for you.

$MNU\0cherp continue$INF : if you have fixed the conflicts and made the commit externally
                 and wish to continue with the next cherrypick.$OFF
EOF
)
	bogusmsg=$(
cat <<EOF
$WRN
Upstream commit hash $STA$uphash$WRN appears to be bogus.$INF
Make sure the hashes in $STA$upcommitsfile$INF are all valid.$OFF
\0
EOF
)
	commit=$(git log --oneline -n1 "$uphash")
	# echo "commit: $commit"
	echo -e "${INF}Processing : $STA${commit:0:$wcols}$OFF"

	if $b_nit; then
		git cherry-pick -n "$uphash"
	else
		git cherry-pick "$uphash"
	fi

	gitstat=$?

	# If cherry-pick returns with 128, the commit was invalid or
	# ambiguous.
	#
	[ $gitstat -eq 128 ] && { echo -e "$bogusmsg"; exit_cherp $exit_bogus; }

	if $b_nit && $b_single; then
		git reset	# unstage changes.
		git add -p	# select the hunks you want.
		b_nit=false
	else
		# If cherry-pick returns with nonzero other than 128, then a
		# conflict is indicated.
		#
		[ $gitstat -eq 0 ] || {
			b_conflict=true
			$b_single && git status && exit $exit_conflict
			echo -e "$conflictmsg"
			lastuphash=$uphash
			# echo -e "Saving: $BLD${commit:0:$wcols}$OFF"
			show_status internal
			exit_cherp $exit_conflict
		}
	fi

	stage_commit
	lastuphash=$uphash

	return 0;
}

#===  FUNCTION  ================================================================
#          NAME:  stage_commit
#   DESCRIPTION:  Given a commit, process it using the global variables
#    PARAMETERS:  none
#       GLOBALS:  b_conflict
#		  cmtmsgfile
#		  str_bugzilla
#		  str_upstream
#		  str_conflicts
#       RETURNS:  none
#===============================================================================
stage_commit() {

	local description
	local uphash=$currentuphash
	local commit

	commit=$(git log --oneline -n1 "$uphash")
	# echo -e "Committing: $BLD${commit:0:$wcols}$OFF"
	git commit -aC "$uphash"

	# Create the new commit message in a file consisting of ..
	#	The user of this script as author of the patch
	#	The current date
	#	Descriptor line, with leading whitespace trimmed
	#	Bugzilla and brew if available
	#	Upstream status if available
	#	Original commit message from cherry-picked commit
	#	Signed-off-by: line
	#
	echo -e "\n" > "$cmtmsgfile"
	description=$(git log -n1 "$uphash" | head -5 | tail -1)

	# Trim leading whitespace from description line and append
	# it to the commit message. Also append the standard commit
	# message.
	#
	description=$(echo -e "$description")
	echo -e "$description\n\n"'```'"\n" >> "$cmtmsgfile"
	[ -n "$str_bugzilla" ] && echo -e "Bugzilla: $str_bugzilla" >> "$cmtmsgfile"
	[ -n "$str_upstream" ] && echo -e "Upstream status: $str_upstream" >> "$cmtmsgfile"
	echo -e "\n" >> "$cmtmsgfile"

	$b_conflict && echo -e "$str_conflicts" >> "$cmtmsgfile"

	# Append the original commit message.
	#
	git log -n1 "$uphash" >> "$cmtmsgfile"

	# Amend the commit messsage with you as author, using the
	# commit message file we built in the previous few lines,
	# and a Signed-off-by: ("-s") line.
	#
	git commit -s --amend --reset-author --file="$cmtmsgfile"

	# If there are conflicts, give the user the option to edit
	# the commit log.
	#
	$b_conflict && edit_commit

	b_conflict=false
}

#===  FUNCTION  ================================================================
#          NAME:  pop_upcmtstartline
#   DESCRIPTION:  Backup the starting line in the upstream commits file
#       GLOBALS:  upcmtstartline
#    PARAMETERS:  $1 - number of commits to pop
#       RETURNS:  status from call to ui_readline
#===============================================================================
pop_upcmtstartline() {
	local -i pops=$1
	local line
	local stat

	while ((pops > 0 && upcmtstartline > 0)); do
		((--upcmtstartline))
		line="$(ui_readline $upcmtstartline "$upcommitsfile")"
		stat=$?
		[ $stat -ne 0 ] && return $stat
		[ "${line:0:1}" = "#" ] && continue
		((--pops))
	done

	return $stat
}

#===  FUNCTION  ================================================================
#          NAME:  pop_commits
#   DESCRIPTION:  Backup the current head of the downstream branch and modify
#                 the upcmtstartline accordingly
#       GLOBALS:  upcmtstartline
#                 b_cmdline
#    PARAMETERS:  $1 - number of commits to pop
#       RETURNS:  nonzero if attempting to pop more than has been committed
#===============================================================================
pop_commits() {
	$b_cmdline && init_cmdline_call

	local -i pops=$1
	local commits
	local popmsg

	commits=$(git log --oneline "$dnorighead"..HEAD | wc -l)
	popmsg=$(
cat <<EOF
${WRN}The number of pops you requested is greater than the number of commits that you
have made in this session.$INF
Commits this session : $STA$commits$INF
      Pops requested : $STA$pops$OFF

EOF
)
	((commits >= pops)) || {
		echo -e "$popmsg"
		$b_cmdline && exit_cherp $exit_bad
		ui_press_any
		return 1
	}

	pop_upcmtstartline "$pops"
	git reset --hard HEAD~"$pops"
	$b_cmdline && exit_cherp $exit_good
	return 0
}

# set_cfg_item key value
#
# Writes the value to the key offset in the .conf file
#
set_cfg_item() {
	cfg_write_key "$1" "$2"
}

# get_cfg_item key
#
# Echoes the value at the key offset in the .conf file
#
get_cfg_item() {
	cfg_read_key "$1"
}

#===  FUNCTION  ================================================================
#          NAME:  save_session
#   DESCRIPTION:  Save session's project variables to the project file.
#    PARAMETERS:  $1 is not empty if this is an status call
#       GLOBALS:  upcommitsfile
#                 upcmtstartline
#                 All the sticky project variables
#       RETURNS:  none
#===============================================================================
save_session() {
	# echo -e "$UND\0save_session$OFF"

	set_cfg_item "updir"          "$updir"
	set_cfg_item "uprepo"         "$uprepo"
	set_cfg_item "upbranch"       "$upbranch"
	set_cfg_item "upcmtstartline" "$upcmtstartline"
	set_cfg_item "dnorighead"     "$dnorighead"
	set_cfg_item "lastuphash"     "$lastuphash"
	set_cfg_item "workdir"        "$workdir"
	set_cfg_item "upcommitsfile"  "$upcommitsfile"
	set_cfg_item "b_conflict"     $b_conflict
	set_cfg_item "str_bugzilla"   "$str_bugzilla"
	set_cfg_item "str_upstream"   "$str_upstream"
	set_cfg_item "str_brew"       "$str_brew"
	set_cfg_item "str_test"       "$str_test"
}

#===  FUNCTION  ================================================================
#          NAME:  read_session
#   DESCRIPTION:  Read the variables stored in the .conf file
#                 Some project variables are updated elsewhere, and only need
#                 to be retrieved at init time and saved at exit time.
#    PARAMETERS:  none
#       GLOBALS:  workdir
#                 cmtmsgfile
#                 upcommitsfile
#                 workdir
#                 upcommits
#       RETURNS:  1 if any of the important conf values are missing
#                 0 otherwise
#===============================================================================
read_session() {
	# echo -e "$UND\0read_session$OFF"
	local configfile=
	local cfgtemplate=
	local temp

	ui_setbg temp
	temp=

	# Initialize the paths for the current working directory
	#
	configfile="$MYDATA/cherp.conf"
	cfgtemplate="$MYLIB/cherp.conf"

	cfg_start "$cfgtemplate" "$configfile"
	init_global_strings

	cfg_get_item "upurl" temp
	[ "$temp" ] && upurl="$temp"
	grep "upstream" .git/config || {
		fetch_upstream_repo & mypid=$!
		ui_waitonproc_tty $mypid .05 "${INF}Fetching upstream repo$OFF"
	}

	cfg_get_item "dnorighead" dnorighead
	[ "$dnorighead" ]     || dnorighead="HEAD"
	[ "$upcmtstartline" ] || return 1
	[ "$workdir" ]        || set_working_directory
	[ "$upcommitsfile" ]  || set_upcommitsfile
	[ "$updir" ]          || set_upstream_directory
	return 0
}

#===  FUNCTION  ===============================================================
#          NAME:  init_common
#   DESCRIPTION:  initialization common to all inits
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
init_common() {
	# echo -e "$UND\0init_common$OFF"

	$b_new && upcmtstartline=1
	[ -f "$upcommitsfile" ] && get_current_cherrypick

	b_session_inited=true
	b_new=false
}

#===  FUNCTION  ===============================================================
#          NAME:  init_cmdline_call
#   DESCRIPTION:  Check integrity of system if calling from the command line
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
init_cmdline_call() {
	# echo -e "$UND\0init_cmdline_call$OFF"

	local stat
	local newstr="${INF}Please type $MNU$MYNAME new$INF to start.$OFF\n"

	read_session || { echo -e "$newstr"; exit 1; }
	init_common
}

#===  FUNCTION  ================================================================
#          NAME:  init_session
#   DESCRIPTION:  Init the continuing session from the saved project variables
#    PARAMETERS:  none
#       GLOBALS:  All sesson variables are affected
#       RETURNS:  none
#===============================================================================
init_session() {
	# echo -e "$UND\0init_session$OFF"

	read_session
	init_common
	# $b_cmdline && exit_cherp $exit_good
}

#===  FUNCTION  ================================================================
#          NAME:  init_newsession
#   DESCRIPTION:  initialize a new session
#       GLOBALS:  All session variables are affected
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
init_newsession() {
	echo -e "\n$UND\0init_newsession$OFF"

	read_session
	set_working_directory
	set_upcommitsfile
	set_upstream_directory
	set_gitbranch
	[ "$uprepo" ] || set_upstream_directory

	dnorighead=$(git log --oneline -1 | cut -d' ' -f1)
	set_cfg_item dnorighead "$dnorighead"

	b_new=true
	init_common
	$b_cmdline && exit_cherp $exit_good
}

#===  FUNCTION  ================================================================
#          NAME:  run_me
#   DESCRIPTION:  Main program loop
#       GLOBALS:  upcommitsfile
#                 $b_cmdline
#    PARAMETERS:  none
#       RETURNS:  None
#===============================================================================
run_me() {
	# echo -e "$UND\0run_me$OFF"

	local uphash
	local stat

	$b_session_inited || { $b_cmdline && init_cmdline_call; }

	if $b_conflict; then
		echo -e "$BLD\0There is an unresolved conflict" \
			"cherrypicking: $OFF$currentuphash"
		show_status
		ui_press_any
		return
	fi

	while :; do

		cherrypick
		get_next_cherrypick
		stat=$?

		if [ $stat -ne 0 ];then
			echo -e "No more commits in $BLD$upcommitsfile$OFF"
			break
		fi

	done

	save_session

	if $b_cmdline; then exit_cherp $exit_good; else menu_loop; fi
}

# run if user hits control-c
#
ctrl_c() {
	echo
	validate_last_upstream_hash
	exit_cherp $CTLC_EXIT         # defined in lib/ui.source
}

check_command() {
	local cmd="$1"
	local lead="--"

	[ "${#cmd}" -eq 2 ] && eval "$2"="$cmd" && return 0
	[ "${cmd:0:2}" = "$lead" ] && eval "$2"="$cmd" && return 0

	[ "${cmd:0:1}" = "-" ] && cmd="-$cmd" || cmd="--$cmd"
	eval "$2"="$cmd"
	return 1
}

#############################
# Start of Script Execution
#############################

# trap keyboard interrupt (control-c)
#
trap ctrl_c SIGINT

init_session

# Determine if we're at the top of a git tree. If not, exit.
#
if ! [ -d .git ]; then
	echo -3 "$WRN"
	echo -e "The current directory... $STA$PWD$WRN"
	echo -e "\t ...is not the top of a git tree.$INF"
	echo "Please cd to the top of a git tree.$OFF"
	echo
	exit 1
fi

###########################################
# Command Line Options
###########################################

declare checked_cmd
declare infostr
infostr="Type \"$(basename "$0") -h\" for more info."
declare invoptstr="\nInvalid option.\n$infostr"
declare needcmtstr="\nMust supply commit hash with -p | pick\n$infostr"
declare shortopts="sp:h"
declare longopts="\
abort,\
branch,\
continue,\
commit,\
directory,\
hashlist,\
help,\
history,\
new,\
pick:,\
pop:,\
run,\
select,\
setup,\
status,\
version,\
"

# If there are no options, then just run the menu.
#
if [ $# -eq 0 ]; then
	b_cmdline=false
else
	b_cmdline=true

	check_command "$1" checked_cmd || shift

	# [ $# -gt 1 ] && checked_cmd="$checked_cmd ${@:2:$#}"

	opts=$(getopt --options $shortopts --long $longopts --name "$0" -- "$@")
	eval set -- "$opts"

	while :; do
	    case "$checked_cmd" in
		"--abort" )
			abort_cherp
			;;
		"--branch" )
			set_gitbranch
			;;
		"--commands" )
			show_commands
			;;
		"--commit" )
			run_commit
			;;
		"--continue" )
			run_continue
			;;
		-h | "--help" 	)
			less "$MYHLP"
			exit 0
			;;
		"--history" )
			show_history
			;;
		"--new" )
			init_newsession
			;;
		"--nit" )
			b_nit=true
			;& 		# fall through to pick
		-p | "--pick" )
			currentuphash=$2
			[ "$currentuphash" ] || { echo -e "$needcmtstr"; exit 1; }
			run_single
			;;
		"--pop" )
			pops=$2
			pop_commits "$pops"
			;;
		# "--reset" )
		#	reset_cherp
		#	;;
		-r | "--run" )
			run_me
			;;
		"--select" )
			set_next_cherrypick
			;;
		"--setup" )
			init_session
			menu_loop
			shift
			;;
		-s | "--status" )
			show_status
			;;
		"--version" )
			print_herald
			exit 0
			;;
		-- )	shift
			break
			;;
		* )	echo -e "$invoptstr"
			exit 1
			;;
	    esac
	done
fi

##############################################
# Main Program
##############################################

# Print the herald
#
print_herald

# Present the ui and get the parameters for the cherry-picks.
#
getlasttag
menu_loop

echo
exit_cherp $exit_good

