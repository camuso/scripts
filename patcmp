#!/bin/bash
#
# compare submitted patches with upstream

declare version="8.0"

declare MYDIR=
MYDIR="$(dirname "$(readlink -f "$0")")"
declare MYLIB="$MYDIR"/lib

[ "$ui_loaded" ]         || source "$MYLIB"/ui.source
[ "$patchutils_loaded" ] || source "$MYLIB"/patch-utils.source

declare -i code_ok=0
declare -i code_special_action=1
declare -i code_special_exit=2
declare -i code_parmcount_err=101
declare -i code_filecount_neq=102

declare -i stat		# general purpose return status variable

declare mldir		# dir with patches downloaded from email
declare usdir		# dir with upstream patches created from commits
             		# : from the files in mldir
declare missing_fixes	# file containing missing fixes, if any
declare -a usfiles	# array of the upstream patch file names

declare editor
declare zstr=
declare b_zstr=false

declare -i mlcount	# count of patch files downloaded from mail
declare -i uscount	# count of patch files in upstream directory
declare -i index=0	# running 0-based index of the current patch
declare -i maxindex	# highest attainable index (mlcount - 1)
declare -i tmpidx	# used for scratch calculations
declare valpatchlist	# a string of strings, list of valid submitted patches
declare upstream_dir=	# directory containing upstream repo optionally passed
			# : by caller

declare b_runmismatch=false
declare b_nomismatch=true
declare b_missing_fixes=false

declare mismatch_file		# file of filenames of patches conflicting with
				# : upstream. Passed by user with -m option.
declare -i first_mismatch=0	# number of first mismatched patch in series
declare -i last_mismatch=0	# number of last mismatched patch in series
declare -i previndex		# index of the last viewed patch, can be mm
declare -i bupnum		# number of the patch before the most recent seen
declare -i mmindex		# index into the mismatch array
declare -i prevmmindex		# previous index into the missmatch array (loop)
declare -i maxmmindex		# highest mismatch index
declare -i mismatch_count	# cardinal number of mismatches (maxmmindex + 1)
declare -a mismatch_array	# array of patch numbers in the series that
				# : conflict with upstream.
declare -a mlfiles
declare -a usfiles

declare lasttag=

declare b_selected=false
declare b_quiet=false
declare b_seen=false
declare b_lastseen=false

declare usagestr=

usagestr=$(
cat <<EOF

$(basename "$0") [options] dir-1 dir-2 editor commits-file

  Calls a diff editor to compare the patch files in the two directories.
  The directories must have the same number of ".patch" files.

  Required Arguments
  ------------------
  dir-1 - downstream patches
  dir-2 - upstream patches and scratch files, like missing_fixes

  editor - the editor to invoke for comparisons. One of ..
           vimdiff, emacs, or tkdiff

  commits-file - file that contains the commits that need to be compared

  -z zstr    - OPTIONAL special action string displayed for the 'z' menu
               item, which only appears when this option is nonzero.

  -m mm_file - OPTIONAL Mismatch file passed by the caller that
               contains a list of files generated by the patbatcmp
               script.

  -t         - OPTIONAL Last tag file, file that contains the last tag
               in the current branch.

  -b         - OPTIONAL Terminal background. If this value is one of
               tb_lite or tb_dark, as defined in lib/ui.source, then
	       colors will be used.

  -u         - OPTIONAL upstream directory for testing and formatting
               new upstream commits entered by user throgh 'p' menu
	       option.

  -q         - OPTIONAL Quiet operation, non-verbose output.

  -h         - This help text.

  Exit codes:
    0 - normal exit
    1 - wrong number of args
    2 - directories do not contain the same number of patch files
  130 - user typed control-c
        see http://www.tldp.org/LDP/abs/html/exitcodes.html
\0
EOF
)

is_interactive() {
	local caller

	caller="$(cat /proc/$PPID/comm)"

	if [ "$caller" == "bash" ] || [ "$caller" == "sshd" ]; then
		return 0
	else
		return 1
	fi
}

usage() {
	echo -e "$usagestr"
}

exit_patcmp() {
	[ -e /dev/shm/lasttag ] && rm -f /dev/shm/lasttag
	exit "$1"
}

# run if user hits control-c
#
control_c()
{
	echo -en "\nCtrl-c detected\nCleaning up and exiting.\n"
	exit_patcmp $CTLC_EXIT
}

# backup
#
# Globals
# 	b_runmismatch	- there are conflicts with upstream
# 	last_mismatch	- number of last mismatched patch in series
# 	maxindex	- highest attainable index (mlcount - 1)
# 	previndex	- index of the previously shown diff
# 			  : can be a mmindex or index
#
# Will run the selected editor's diff on the patch pair previous to the
# one that's about to be examined. Sequential calls to this routine will
# backup to the patch prvious to the one just examined.
#
# $1 - current index
# $2 - flag indicates the last patch pair was viewed by calling backup
# $3 - returns the correct back_one index
#
backup() {
	local curidx=$1
	local _bk_idx=$curidx
	local bk_max

	$b_runmismatch && bk_max=$last_mismatch || bk_max=$maxindex

# echo "curidx: $curidx previndex: $previndex  bk_max: $bk_max"
	((_bk_idx--))
	((previndex != bk_max)) && ((_bk_idx--))

	((_bk_idx <= 0)) && _bk_idx=0
# echo "_bk_idx: $_bk_idx"
	eval "$2"=$_bk_idx
}

# backup_wrapper - wraps the backup routine with globals
#
# Just want to keep the global crap isolated from the backup routine
#
# globals
#	index	-  the current index
#	mmindex -  the current mismatch index, if we are in mismatch mode
#
backup_wrapper() {
# echo "backup_wrapper: index: $index"

	if $b_runmismatch; then
		backup "$mmindex" mmindex
		index=${mismatch_array[$mmindex]}
	else
		backup "$index" index
	fi
# echo "index: $index"
# read
}

# get_patch_number
#
# globals:
# 	index
#	mmindex
#
get_patch_number() {
	local patnum
	local errstr="$INF Enter a different patch number or $qstr$INF to quit."

	echo -e "$INF""Type $qstr$INF to quit and pick up where you left off $OFF"

	while :; do
		getuser "Patch number: " patnum
		[ "$patnum" == "q" ] && return 1

		if ! [[ $patnum =~ ^-?[0-9]+$ ]]; then
			echo -e "$WRN$patnum is not a valid number.$OFF"
			echo -e "$errstr"
			continue
		fi

		if [ "$patnum" -lt 1 ]; then
			echo -e "\n$WRN$patnum < 1$errstr"
			continue
		fi

		if [ "$patnum" -gt "$mlcount" ]; then
			echo -e "\n$WRN$patnum > $mlcount$errstr"
			continue
		fi

		index=$((patnum - 1))
# echo "index: $index patnum: $patnum"
		break
	done
	return 0
}

# replace_commit
#
# Globals
#	index	     - the current index
#	previndex    - index of the most recently viewed patch pair.
#	uscommits    - passed to the script as parameter 4 from caller
#	upstream_dir - location of upstream repo, optionally passed by caller
#
replace_commit() {
	local patnum
	local locindex
	local commit=0
	local patcnt
	local pfx
	local stat=0
	local retstr=

	retstr=$(
cat <<EOF
${MNU}Enter $qstr$MNU to return to previous menu without changing anything.$OFF"
EOF
)
	locindex=$previndex
	patnum=$((locindex + 1))
# echo "locindex: $locindex patnum: $patnum  last_mismatch: $last_mismatch"

	pfx=$(printf "%04d" "$patnum")

	[ -f "$uscommits" ] || \
		ui_getfilespec "File containing the upstream commits: " uscommits

	echo -e "$retstr"
	[ -n "$upstream_dir" ] && { cd "$upstream_dir" || exit; }

	while :; do
		stat=0
		getuser "New upstream commit ID for patch $STA$patnum$INF : " commit

		if [ "$commit" == "q" ]; then
			echo -e "${INF}Nothing was changed.$OFF"
			[ -n "$upstream_dir" ] && { cd - > /dev/null || exit; }
			return 1
		fi

		if [ -n "$commit" ]; then
			git log --oneline -n1 "$commit" > /dev/null 2>&1
			stat=$?
		else
			echo -e "${WRN}No commit entered."
			echo -e "$retstr"
			continue
		fi

		if [ $stat -ne 0 ]; then
			echo -e "$WRN$commit$INF is an invalid commit."
			echo -e "$retstr"
			continue
		fi

		break
	done

# echo -e "${INF}removing: locindex: $STA$locindex$INF patch: $STA${usfiles[$locindex]}$OFF"
	rm -f "${usfiles[$locindex]}"
	echo -e "${INF}Replacing upstream commit for $STA$patnum$INF with commit: $STA$commit$OFF"
	ui_replaceline "$patnum" "$commit $patnum/$patcnt" "$uscommits"
	git format-patch --no-renames -1 -k --start-number $patnum $commit -o "$usdir"
	stat=$?
	# echo $stat

	# If we could not format the patch, then create an empty
	# patch with the bad commit id in it.
	#
	[ $stat -ne 0 ] && echo -e "\ninvalid commit: $commit\n" > "$usdir"/"$pfx"-inv.patch

	usfiles[$locindex]=$(ls "$usdir"/"$pfx"-*.patch)
	[ -n "$upstream_dir" ] && cd - > /dev/null || exit
	return 0
}

say_nomismatch() {
	echo -e "$INF *********************************************"
	echo -e     " *                                           *"
	echo -e " *    $STA There are no conflicting patches $INF     *"
	echo -e " *                                           *"
	echo -e " ********************************************* $OFF"
}

# show_mismatch() - display the mismatched patches to the screen
#
# Prints:
# 	conflict number. patch number: conflicting patch file
#
# Globals:
# 	mismatch_array
# 	mlfiles
#
show_mismatch() {
	local -i seqno		# sequence number of patch
	local -i confnum=1	# sequential conflict number
	local -i mlcount="${#mlfiles[@]}"	# total number of patch files
	local -i mlcountwid="${#mlcount}"	# field width of number of patch files
	local -i mmcount="${#mismatch_array[@]}"	# number of mismatches
	local -i mmcountwid="${#mmcount}"		# field width of mmcount

	echo -e "\n${MNU}Patches conflicting with upstream commits$INF"
	echo -e       "=========================================$OFF"
	echo -e "${INF}Conflict number. Patch number: Conflicting Patch file$OFF"
	for seqno in "${mismatch_array[@]}"; do
		printf "${MNU}%${mmcountwid}d. %${mlcountwid}d: ${STA}%s${OFF}\n" \
			"$confnum" "$((seqno + 1))" "${mlfiles[seqno]}"
		((confnum++))
	done
}

# init_mismatch()
#
# Globals:
# 	mismatch_file
# 	mismatch_array
# 	mismatch_count
# 	first_mismatch
# 	last_mismatch
# 	mmindex
#	maxmmindex
# 	mlfiles
#	index
#
init_mismatch() {
	local line	# loop var gets each line in the mismatch_file
	local verbosity	# level of verbosity in the mismatch_file
	local seqno	# sequence number of patch

	mmindex=0

	# Determine the verbose level of the mismatch_file
	#
	line=$(ui_readline 1 "$mismatch_file")
	verbosity=$(echo "$line" | cut -d':' -f2)

	# create the array of mismatched patched file indexes. The index is
	# 0-based, while the patch sequence number is 1-basd, so subtract 1
	# from each sequence number to get the index into the mlfiles and
	# usfiles arrays.
	#
	while read -r line; do
		[ "${line:0:6}" == "PATCH:" ] || continue
		((verbosity > 0)) && { [[ "$line" == *"!="* ]] || continue; }

		seqno=$(echo "$line" | cut -d':' -f2)
		mismatch_array[mmindex]=$((seqno - 1))

		((mmindex++))
	done < "$mismatch_file"

	[ ${#mismatch_array[@]} -gt 0 ] && show_mismatch

	mismatch_count=$mmindex
	maxmmindex=$((mismatch_count - 1))

	if [ "$mismatch_count" -gt 0 ]; then
		echo -e "\n${INF}Total number of conflicts with upstream:"\
			"$STA$mismatch_count$OFF"
		last_mismatch=${mismatch_array[$((mmindex-1))]}
		first_mismatch=${mismatch_array[0]}
		index=$first_mismatch
		# echo "mismatch_count; $mismatch_count max mmindex: $((mmindex-1))"
		b_nomismatch=false
		b_runmismatch=true
	else
		b_nomismatch=true
		b_runmismatch=false
		say_nomismatch
	fi
	mmindex=0
}

getlasttag() {

	echo -en "${INF}Getting last git tag..$OFF"
	git describe --tags --abbrev=0 > /dev/shm/lasttag &

	while true; do
		echo -n "."
		[ -f /dev/shm/lasttag ] && break
		sleep 1
	done

	echo
}

show_missing_fixes() {
	if $b_missing_fixes; then
		echo -en "$INF"
		missingfixes -a
		echo -e "$OFF"
		ui_press_any
	fi
}

menu_missing_fixes() {
	if $b_missing_fixes; then
		echo -e "\t${MNU}f$OFF - show missing fixes"
	fi
}

show_env() {
	echo -en "$MNU"
	echo -e  "\t    Last Tag :$STA $lasttag$MNU"
	echo -e  "\t    RHEL dir :$STA $mldir$MNU"
	echo -e  "\tUpstream dir :$STA $usdir$INF"
	$b_missing_fixes && echo -e "\n\t${CAU}There are missing fixes.$INF"
	$b_nomismatch || show_mismatch
}

vim_cmd() {
	vimdiff "$1" "$2"
}

emacs_cmd() {
	emacs --eval "(ediff-files \"$1\" \"$2\")" -geometry 160x40
}

tkdiff_cmd() {
	tkdiff "$1" "$2"
}

# get_color - if terminal_background is set, color is on.
#
# Globals
# 	terminal_background - defined in lib/ui.source
# 	b_color - defined in lib/ui.source
#
get_color() {
	local tb=$1

	[ -z "$tb" ] || [ "$tb" -eq 0 ] && return 1

	terminal_background=$tb
	b_color=true
	ui_set_colors
	return 0
}

list_patches() {
	local dir="$1"
	find "$dir" -maxdepth 1 -type f -name "*.patch"
}

#############################################
# Initialization
############################################

# Trap for control-c
#
trap control_c SIGINT

for arg in "$@"; do

    if [ "${arg:0:1}" == '-' ]; then
	    opt="${arg:1}"
    else
	    continue
    fi

    case "$opt" in

	z ) zstr="$2"
	    b_zstr=true
	    shift 2
	    ;;
	m ) mismatch_file="$2"
	    b_runmismatch=true
	    shift 2
	    ;;
	b ) [ -n "$2" ] && get_color "$2"
	    shift 2
	    ;;
	u ) upstream_dir="$2"
	    shift 2
	    ;;
	q ) b_quiet=true
	    shift
	    ;;
	h ) usage
	    ;;
	* ) echo "unrecognized option"
	    echo -e "$usagestr"
	    exit 127
    esac
done

[ $# -eq 4 ] || usage $code_parmcount_err

##############################
# Herald
#############################

# Only print the herald if we're interactive.

is_interactive && \
echo -e "${MNU}patcmp $STA$version$INF - Compare submitted patches with upstream$OFF"

# Get the input arguments
#
mldir="$1"
usdir="$2"
editor="$3"
uscommits="$4"
missing_fixes="$usdir/missing_fixes"

if [ -s "$missing_fixes" ] && grep -q 'WARNING' "$missing_fixes"; then
	b_missing_fixes=true
else
	b_missing_fixes=false
fi

case "$editor" in
    "vimdiff" )	editcmd=vim_cmd
		;;
    "emacs"   )	editcmd=emacs_cmd
		;;
    "tkdiff"  )	editcmd=tkdiff_cmd
		;;
    *         )	echo -e "$STA$editor$WRN is not a supported editor.$OFF"
		exit_patcmp 1
		;;
esac

# It is not really required that the two directories have the same number
# of files, because we will simply stop processing when we run out of files
# in one directory or the other. However, it could lead to confusion, since
# we are comparing a patch set. Both directories containing the patch set
# must therefore have the same number of patch files.

patlist=$(list_patches "$mldir" | sort -V)
create_patchlist "$patlist" valpatchlist

mlcount=$( wc -w <<< "$valpatchlist")
uscount=$(list_patches "$usdir" | wc -l)

if ((mlcount != uscount)); then
	echo
	echo -e "${WRN}The two directories must have the same number of files.$OFF"
	echo -e "\t$STA$usdir$INF has $STA$uscount$INF entries.\n"
	echo -e "\t$STA$mldir$INF has $STA$mlcount$INF entries.\n"
	echo -e "${INF}Exiting ...$OFF"
	echo
	exit $code_filecount_neq
fi
maxindex=$((mlcount - 1))

echo
echo -e "${INF}Local patches in $STA$mldir$INF will be compared with"
echo -e        "upstream commits in $STA$usdir$OFF"
echo -e "${INF}Diff editor of choice is $STA$editor$OFF"

echo -e "\n${INF}Building the index of patch files$OFF"
echo -e   "${INF}=================================$OFF"
IFS=" " read -ra mlfiles <<< "$valpatchlist"
for pf in "${mlfiles[@]}"; do
	if $b_quiet; then
		ui_clearline
		echo -n "$pf"
	else
		echo "$pf"
	fi
done
set +x
$b_quiet && echo

echo -e "\n${INF}Building the index of upstream commits$OFF"
echo -e   "${INF}======================================$OFF"
mapfile -t usfiles < <(list_patches "$usdir" | sort -V)
for uf in "${usfiles[@]}"; do
	if $b_quiet; then
		ui_clearline
		echo -n "$uf"
	else
		echo "$uf"
	fi
done
$b_quiet && echo
echo

# PS4='+(${BASH_SOURCE}:${LINENO}): '
# set -x

[ -f "$mismatch_file" ] && init_mismatch || b_runmismatch=false
$b_runmismatch && index=$first_mismatch || index=0
previndex=$index

# echo "Starting with patch: $((index + 1))"

# If the lasttag file does not exist, then go create it with a
# call to getlasttag().
#
[ -f /dev/shm/lasttag ] || getlasttag
lasttag=$(cat /dev/shm/lasttag)

declare anystr="\t${MNU}    Any other key displays the diff for patch "

$b_missing_fixes && echo -e "\n${CAU}There are missing fixes."

#############################################
# Main program Loop
############################################

while :; do

	declare answer=	# User menu selection

	if [ $index -lt 0 ] || [ $index -gt $maxindex ]; then
		echo -e "${INF}There is no patch number:$STA $((index + 1))$OFF."
		if $b_runmismatch; then
			mmindex=0
			index=${mismatch_array[$mmindex]}
		else
			index=0
		fi
		echo -e "${INF}Starting with patch number:$STA $((index + 1))$OFF\n"
	fi

	if ($b_runmismatch && [ $index -gt 0 ] && [ $index -lt $maxindex ]); then
		if ui_inarray $index mismatch_array[@]; then
			index=${mismatch_array[$mmindex]}
		else
			index=${mismatch_array[0]}
		fi
	fi

	echo -e "\n${MNU}$STA$editor$MNU will diff local patches with upstream commits"
	echo -e   "${INF}--------------------------------------------------------------------"

	if $b_seen; then
	echo -en "${MNU}Seen Patch $STA$((previndex + 1))$INF of $STA$((maxindex + 1))$INF "
	echo -e  "The most recent patch viewed in $STA$editor$OFF"
	fi
	echo -e "${MNU}Next Patch $STA$((index + 1))$INF of $STA$((maxindex + 1))$OFF"

	if [ $index -ge $maxindex ] && $b_lastseen; then
		echo -e "${INF}*******************************************"
		printf        "Patch$STA %d$INF is the last patch in the series.\n" \
			$((maxindex + 1))
		echo -e   "*******************************************$OFF"
	fi

	echo -e "${INF}Diff Local:$STA $mldir/$(basename "${mlfiles[$index]}")"
	echo -e "${INF}v Upstream:$STA $usdir/$(basename "${usfiles[$index]}")$OFF"

	if $b_runmismatch; then
	  echo -e "${WRN}Conflict$INF :$STA $((mmindex+1)) ${INF}of$STA $mismatch_count$OFF"
	  if [ $index -eq $last_mismatch ] && $b_lastseen; then
	    echo -e  "${INF}**********************************************"
	    printf "Patch$STA %d${INF} is the last$WRN conflict$INF in the series.\n" \
		    $((last_mismatch + 1))
	    echo -e "**********************************************$OFF"
	  fi
	fi

	echo -e "${INF}--------------------------------------------------------------------$OFF"

	if $b_runmismatch; then	# mismatch case

	([ $mmindex -ge $maxmmindex ] && $b_lastseen) \
		&& tmpidx=$((mismatch_array[maxmmindex] + 1)) || tmpidx=$((previndex + 1))
	$b_seen && \
	echo -e  "\t${MNU}p$OFF - use a different upstream commit for$STA Patch $tmpidx$OFF"
	[ $mmindex -gt 0 ] && $b_seen && \
	echo -e  "\t${MNU}r$OFF - re-display$STA Patch $tmpidx$OFF"
	[ $mmindex -gt 1 ] && \
	echo -e  "\t${MNU}b$OFF - backup to$STA Patch $bupnum$OFF"

	else	# no mismatch case

	([ $index -ge $maxindex ] && $b_lastseen) && tmpidx=$((index+1)) || tmpidx=$index
	$b_seen && \
	echo -e  "\t${MNU}p$OFF - use a different upstream commit for$STA Patch $tmpidx$OFF"
	[ $index -gt 0 ] && $b_seen && \
	echo -e  "\t${MNU}r$OFF - re-display$STA Patch $tmpidx$OFF"
	[ $index -gt 1 ] && \
	echo -e  "\t${MNU}b$OFF - backup to$STA Patch $bupnum$OFF"

	fi

	echo -e  "\t${MNU}n$OFF - prompt for a number for a specific patch$OFF"
	echo -e  "\t${MNU}c$OFF - show conflicting patches"
	echo -e  "\t${MNU}m$OFF - only examine patches conflicting with upstream:$STA $b_runmismatch"
	menu_missing_fixes
	echo -e  "\t${MNU}s$OFF - show contents of conflicts log"
	echo -e  "\t${MNU}e$OFF - show environment, directories, last tag, etc.$OFF"
	echo -e  "\t${MNU}C$OFF - run batch file comparison to find conflicts with upstream$OFF"
	echo -e  "\t${MNU}q$OFF - quit and return to previous execution environment"
	$b_zstr && echo -e  "\t${MNU}z$OFF - $zstr"
	echo -e  "$anystr$STA$((index + 1))$MNU of $STA$((maxindex + 1))$MNU.$OFF"
	promptgetchar "\n\t${MNU}Your choice : $OFF" answer
	echo

	case $answer in
		q )	break
			;;
		b )	if $b_runmismatch; then tmpidx=$mmindex; else tmpidx=$index; fi
			((tmpidx > 1)) || continue
			echo
			backup_wrapper
			;;
		n )	if get_patch_number; then b_selected=true; else continue; fi
			;;
		p )	replace_commit || continue
			;&
		r )	if $b_runmismatch && ((mmindex > 0)); then
				index=$previndex
				mmindex=$prevmmindex
			elif ((index > 0)); then
				if $b_lastseen; then
					index=$maxindex;
				else
					index=$previndex;
				fi
			fi
			;;
		z )	$b_zstr && exit $code_special_action
			;;

		m )	# Unless a mismatch file exists, this option is meaningless.
			#
			if ! $b_nomismatch; then
				ui_toggle b_runmismatch
				if $b_runmismatch; then
					mmindex=0
					index=${mismatch_array[0]}
				fi
				echo
				continue
			fi
			;;

		s )	# Only works when there is a mismatch file
			#
			if ! $b_nomismatch; then
				less "$mismatch_file"
				echo
				read -r -n1 -p "Press any key to continue... "
				echo
				continue;
			fi
			;;

		e )	show_env
			continue
			;;

		C )	patbatcmpmgr -R "$mldir" -U "$usdir" -o "$usdir"/mm.log
			mismatch_file="$usdir"/mm.log
			b_runmismatch=true
			init_mismatch
			echo
			continue
			;;

		c )	if ((${#mismatch_array[@]} > 0)); then
				show_mismatch
			else
				say_nomismatch
			fi
			continue
			;;
		f )	show_missing_fixes
			continue
			;;
	esac
# echo "mlfiles[$index]: ${mlfiles[$index]}"
# echo "usfiles[$index]: ${usfiles[$index]}"
# read
	$editcmd "${mlfiles[$index]}" "${usfiles[$index]}"

	b_seen=true
	previndex=$index
	prevmmindex=$mmindex

	if $b_runmismatch; then

		[ $mmindex -ge $maxmmindex ] && b_lastseen=true || b_lastseen=false
		[ $mmindex -ge 1 ] && bupnum=$((mismatch_array[mmindex-1] + 1))

		# If the user selected a specific patch, then find the next
		# highest patch number in the mismatch_array.
		# Else if the mmindex is less than the number of elements
		# in the array, simply increment the mmindex.
		# Else the mmindex is already at its max value.
		#
		if $b_selected; then
			ui_nextinarray $index mismatch_array[@] mmindex
			b_selected=false
		else
			ui_inarray $index mismatch_array[@] mmindex \
			&& [ $mmindex -lt $((mismatch_count - 1)) ] \
			&& ((mmindex++))
		fi

		# Set the index into the commit log files to the element
		# indexed by mmindex in the mismatch_array
		#
		index=${mismatch_array[$mmindex]}
# echo "Forward mmindex: $mmindex index: $index"
	else
		[ $index -ge 1 ] && bupnum=$index

		[ $index -ge $maxindex ] && b_lastseen=true || b_lastseen=false
		[ $index -lt $maxindex ] && ((index++))
# echo "Forward index: $index maxindex: $maxindex"
	fi

# if $b_runmismatch; then
# 	echo "mismatch_array: ${mismatch_array[@]}"
# 	echo "mmindex: $mmindex  bupnum: $bupnum"
# 	echo
# else
# 	echo "index: $index  bupnum: $bupnum"
# fi

done
exit $code_ok
