#!/bin/bash
#
# commitcmp
#

[ "$MYDIR" ] || declare MYDIR=$(dirname $(which $(basename $0)))
[ "$MYLIB" ] || declare MYLIB=$MYDIR/lib

[ "$ui_loaded" ]            || source $MYLIB/ui.source
[ "$configmanager_loaded" ] || source $MYLIB/config-manager.source

# Other exit codes
declare -i EXIT_OK=0
declare -i EXIT_INVARG=1
declare -i EXIT_INVFIL=2
declare -i EXIT_INVDIR=3

declare -a exitmsgary=(
""
"Invalid number of arguments."
" is an invalid filename."
" is an invalid directory name."
)

exitme() {
	local exitval=$1
	local strarg=""
	local exitmsg

	if ([ $exitval -ne $EXIT_OK ] && [ $exitval -ne $CTLC_EXIT ]); then
		[ $# -eq 2 ] && strarg=$2
		[ ${#exitmsgary[@]} -gt $exitval ] \
			&& exitmsg="${exitmsgary[$exitval]}"

		echo -e "$BLD$strarg$exitmsg$OFF"

		[ $exitval -ne 0 ] && echo -e \
			"Type$BLD commitcmp -h$OFF for help."
	fi

	exit $exitval
}

# run if user hits control-c
#
control_c()
{
	echo -en "
Ctrl-c detected
Cleaning up and exiting.
"
	exitme $CTLC_EXIT
}


declare -i optcount=0
declare uplog="upstream.log"
declare dnlog="downstream.log"
declare chlog="cherp.log"
declare outdir=
declare upcmt=
declare dncmt=
declare upbr=
declare dnbr=
declare subsys=
declare remote_dir=
declare remote_repo=
declare remote_branch=


declare usagestr=$(
cat <<EOF

$(basename $0) -uc upcmt -ub upbr -dc dncmt -db dnbr -o dir [sybsys]

Create a cherp input file by doing the following.
- If it doesn\'t already exist, creates file $uplog with the following
  command
  $ gitnice -r -c -d upcmt > outdir/$uplog

- If it doesn\'t already exist, creates file $dnlog with the following
  command.
  $ extup -r dncmt > outdir/$dnlog

- Compares the contents of $uplog and $dnlog and creates a cherp file
  with all the upstream commits, but with the ones already backported
  marked with a leading hash #.
  The output file will be called $chlog

NOTE:
Requires the use of scripts gitnice and extup to create the file
inputs for this script.

Example:
  $(basename $0) \\\

        -uc v4.18 -ub linus \\\

        -dc RHEL-8.0.0 -db rh8.3 \\\

        -o ../backport/8.3/ipmi/ \\\

        drivers/char/ipmi/

Options:

  -h        - this help text

  -uc upcmt - Create upstream logfile starting at given upstream commit
              to current upstream HEAD.
              output file will be named $uplog

  -dc dncmt - Create downstream logfile starting at given downstream
              commit to current downstream HEAD.
              Output file will be named $dnlog

  -ub upbr  - Upstream branch containing the upstream commit.

  -db dnbr  - Downstream branch containing the downstream commit.

  -o dir    - Directory for ouput files.

Arguments:

  subsys - Optional subsystem for which to obtain the commits, e.g.
           drivers/char/ipmi
\0
EOF
)

usage() {
	echo -en "$usagestr"
	exitme 0
}

# parseops() - parse the input options
#
# Needed multicharacter optionis, but didn't want to use longopts.
#
# Inputs: $@, the whole command line
#
# Globals:
# 	optcount
# 	upcmt
# 	dncmt
# 	upbr
# 	dnbr
# 	usagestr
#
parseops() {
	local arg=
	local opt=

	for arg in $@; do
	    if [ ${arg:0:1} == '-' ]; then
		opt="${arg:1}"
		case "$opt" in
		    h  ) usage
		         let ++optcount
		         ;;
		    uc ) shift
			 upcmt="$1"
			 shift
		         optcount=$((optcount + 2))
		         ;;
		    ub ) shift
			 upbr="$1"
			 shift
		         optcount=$((optcount + 2))
		         ;;
		    dc ) shift
			 dncmt="$1"
			 shift
		         optcount=$((optcount + 2))
		         ;;
		    db ) shift
			 dnbr="$1"
			 shift
		         optcount=$((optcount + 2))
		         ;;
		    o  ) shift
			 outdir="$1"
			 shift
		         optcount=$((optcount + 2))
		         ;;
		    *  ) echo "unrecognized option -$1"
		         echo -e "$usagestr"
		         exit 127
		esac
	    fi
	done
}

# cmpstr() - compare strings
#    Compare the commits from the upstream and downstream commit logs
#    to identify those the ones that have already been backported.
#    Output all commit lines to the cherp.log file, marking the ones
#    that werre already backported with a leading #
#
# GLOBALS
#	chlog - output commits file
#	uplog - upstream commits file
#	dnlog - downstream commits file
#	outdir - directory for all the commit log files
#
cmpstr() {
	local uppath="$outdir/$uplog"
	local dnpath="$outdir/$dnlog"
	local chpath="$outdir/$chlog"
	local savedifs="$IFS"
	local upstr=
	local rhstr=
	local up	# one line from the upstream log
	local rh	# one line from the rhel log
	local tmp
	local b_match=false
	local j		# upstr index
	local k		# rhstr index

	# Instead of reading from the file, which limmits our debug
	# capabilites, create an array out of the lines in the file.
	# Set IFS to newline and then restore it after createing the
	# string arrays.
	#
	IFS=$'\n'
	upstr=($(< $uppath))
	rhstr=($(< $dnpath))
	IFS="$savedifs"

	# Zero the cherp log file.
	> $chpath

	for ((j = 0; j < ${#upstr[@]}; ++j)); do
		up=${upstr[j]}
		upcmt="${up:0:9}"

		for ((k = 0; k < ${#rhstr[@]}; ++k)); do
			tmp=$(echo "${rhstr[k]}" | cut -d' ' -f2)
			rhcmt="${tmp:0:9}"

			[[ "$rhcmt" == "$upcmt" ]] && {
				b_match=true
				break
			}
		done

		$b_match && echo "# $up" >> $chpath || echo "$up" >> $chpath
		$b_match && echo "# $up" || echo "$up"
		b_match=false
	done
}

set_cfg_item() {
	cfg_write_key $1 $2
}

get_cfg_item() {
	cfg_read_key $1
}

set_colors() {
	local ans
	while :; do
		ui_use_colors
		background=$terminal_background
		set_cfg_item background $terminal_background
		echo -en "${INF}You chose "

		case $terminal_background in
			1) echo -e "${STA}light$INF background$OFF\n";;
			2) echo -e "${STA}dark$INF background$OFF\n";;
		esac

		loop_yn_ro "Is that what you want? (y/n) : "
		[ $? -eq 0 ] && return || continue
	done
}

# set_remotedir - name the directory where the upstream remotes are
#
# GLOBALS
# 	remote_dir
#
set_remotedir() {
	local stat
	local b_exists=false

	echo -e "\n$INF Set the directory that contains the remote repo to" \
		"search for missing fixes.$OFF"

	if [ -n "$remote_dir" ]; then
		echo -e "$INF Your current remote directory is: $STA$remote_dir"
		prstr=$(echo "$INF Enter a new remote directory or press " \
			"$qstr$INF to leave it unchanged : $OFF")
		b_exists=true
	else
		prstr="$INF Enter a new remote directory : $OFF"
		b_exists=false
	fi

	while :; do
		ui_getnewdir "$prstr" remote_dir
		stat=$?

		if ($b_exists && [ $stat -eq 3 ]); then
			return
		else
			if [ $stat -ne 3 ]; then
				break
			else
				echo -e \
				    "${WRN}You must provide an upstream directory.$OFF"
			fi
		fi
	done

	# get the full pathname of the remote directory.
	# If there is no git repo in it, print the tutor to the screen
	# and exit gracefully.
	#
	remote_dir=$(realpath $remote_dir)
	[ -d $remote_dir/.git ] || {
		echo -e "${WRN}No git repo detected in $MNU$remote_dir$OFF"
		echo -e "${INF}This script will exit now."
		exit_me 1
	}

	# Changing the remote directory means changing the remote
	# origin/branch, too.
	#
	remote_repo=
	remote_branch=
	set_cfg_item "remote_repo" "$remote_repo"
	set_cfg_item "remote_branch" "$remote_branch"
	set_cfg_item "remote_dir" "$remote_dir"
}

# set_remote_seek() - set the remote origin and branch to seek
#
# Sets up the remote origin/branch global fields to use when seeking
# missing fixes.
#
# GLOBALS:
# 	remote_repo
# 	remote_branch
#
set_remote_seek() {
	local remotes=
	local b_set=true
	local remrepo_msg=$(
cat <<EOF
$INF
 Set the upstream origin/branch in: $STA$remote_dir$INF
 to search for any missing fixes.$OFF
EOF
)
	[ -n "$remote_dir" ] || set_remotedir
	echo -e "$remrepo_msg"

	if ([ -n "$remote_repo" ] && [ -n "$remote_branch" ]); then
		remotes="$remote_repo/$remote_branch"
		echo -e "$INF Your current remote repo/branch is: $STA$remotes"
		loop_yn "$MNU Do you want to change this? (y/n) : $OFF" b_set
	fi

	if $b_set; then
		cd $remote_dir
		select_remrepo remote_repo && select_rembranch "$remote_repo" remote_branch
		cd - > /dev/null 2>&1
		set_cfg_item "remote_repo" "$remote_repo"
		set_cfg_item "remote_branch" "$remote_branch"
	fi
}

init_env() {
	b_color=true	# from lib/ui.source

	local b_tf

	MYDATA=$(realpath ./.data)
	[ -d "$MYDATA" ] || mkdir -p $MYDATA

	configfile="$MYDATA/cmpcommit.conf"
	cfgtemplate="$MYLIB/cmpcommit.conf"
	[ -f "$configfile" ] || cp $cfgtemplate $configfile

	cfg_set_template "$cfgtemplate"
	cfg_set_configfile "$configfile"
	cfg_init

	# If color hasn't already been set up, then query the user for terminal
	# background color and init the color engine.
	# Else just init the terminal_background variable from the config global.
	#
	if [ -z "$background" ] || (( background < 1 || background > 2 )); then
		set_colors
	else
		terminal_background=$background
		ui_set_colors
	fi

	if [ -d "$remote_dir" ]; then
		echo -e "${INF}Current remote directory is: $STA$remote_dir$OFF"
		loop_yn "{$INF}Keep it? ${MNU}y/n : $OFF" b_tf
		$b_tf || set_remotedir
	else
		set_remotedir
	fi

	([ -z "$remote_repo" ] || [ -z "$remote_branch" ])
}

main() {
        # Trap for control-c
        trap control_c SIGINT

	parseops $@
	[ $optcount -lt 10 ] && exitme $EXIT_INVARG

	shift $optcount
	subsys="$1"

	init_env

	ui_testdir "$outdir" outdir
	echo

	[ -f $outdir/$uplog ] && {
		echo -e "$BLD$outdir/$uplog$OFF exists."
		echo "It will be overwritten if you continue."
	}
	echo -e "Create upstream commit log  : $BLD$outdir/$uplog$OFF"

	[ -f $outdir/$dnlog ] && {
		echo -e "$BLD$outdir/$dnlog$OFF exists."
		echo "It will be overwritten if you continue."
	}
	echo -e "Create downstream commit log: $BLD$outdir/$dnlog$OFF"
	echo

	printf "Upstream Branch: $BLD%-12s$OFF Downstream Branch: $BLD%-12s$OFF\n" $upbr $dnbr
	printf "Upstream Commit: $BLD%-12s$OFF Downstream Commit: $BLD%-12s$OFF\n" $upcmt $dncmt

	echo
	echo -n "Press any key to proceed or CTRL-C to exit..."
	read -n1

	git checkout $upbr
	gitnice -r -c -d "$upcmt..HEAD" $subsys 2>&1 | tee $outdir/$uplog
	echo
	git checkout $dnbr
	echo "$dnbr checked out"
	extup -r "$dncmt..HEAD" "$subsys" 2>&1 | tee $outdir/$dnlog

	cmpstr

	exitme $EXIT_OK
}

main $@

exitme $EXIT_OK

