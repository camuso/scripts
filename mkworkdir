#!/bin/bash
#
# mkworkdir

MYDIR="$(dirname "$(which "$(basename "$0")")")"
MYLIB="$MYDIR"/lib
# source "$MYLIB"/ui.source

declare usagestr=$(
cat <<EOF

$(basename $0) 

Description:
	Remove and recreate home directory with smaller size and create
	a /work logical volume with a size large enough to do actual work.

Arguments:
	help : print this text to the screen.

\0
EOF
)

usage() {
	echo -e "$usagestr"
	exit 1
}

declare warning=$(
cat <<EOF

 Be sure you have backed-up or moved everything in your /home directory,
 because it will be destroyed.

 Press ctrl-c NOW if you need to do that first.
 Press any other key to continue.
\0
EOF
)

declare homemnt= 	# extracted from fstab
declare workmnt=	# same as homemnt but with work in place of home
declare homedir=	# extracted from homemnt
declare workdir=	# same as homedir but with work in place of home
declare worksiz=	# size of work directory input by user
declare newhomesiz=	# user input for new size of homedir

declare -i aok=0
declare -i novg=1
declare -i novfree=2

declare -a errmsg=(
""
"Cannot find VG in vgs fields."
"Cannot find VFree in vgs fields."
)

# exitme
#
# Arguments
#   $1 - exit code
#   $2 - optional message
#
exitme() {
	local -i code="$1"
	local msg="$2"

	((code == 0)) && exit "$code"
	echo -e "$msg"
	usage
	exit "$code"
}

update_fstab() {
	local dir="$1"
	local map="$2"
	local fstr
	local uid
	local fline

	uid="$(blkid "$map" | tr -d \" | awk -F" " '{print $2}')"
	fstr="$uid $dir                   xfs     defaults        0 0"
	fline="$(grep -n "[[:space:]]$dir[[:space:]]" /etc/fstab | cut -d: -f1)"

	# If the line already exists in the fstab, delete it, because
	# we're going to replace it.
	[ -n "$fline" ] && sed -i.bak "$fline"d /etc/fstab

	echo "$fstr" >> /etc/fstab
}

main() {
        # The following line will single step through this script.
        # Use the # to comment it out.
        # trap 'read -p "$(printf "%$((${#BASH_SOURCE[0]}+8))s" "")" \
	#	line && eval "$line" || exit $?' DEBUG

	local homesiz	# size of the home directory extracted from lvs
	# /dev/mapper names
	local homemap	# e.g. /dev/mapper/rhel_dell--per440--01-home
	local workmap	# e.g. /dev/mapper/rhel_dell--per440--01-work
	# uuid extracted from blkid
	local homeid	# uuid of /dev/mapper/rhel_dell--per440--01-home
	local workid	# uuid of /dev/mapper/rhel_dell--per440--01-work
	# fstab entries
	local homefs	# fstab entry for /home
	local workfs	# fstab entry for /work
	local line

	[[ "$1" == *"h"* ]] && usage

	# If not the root, exit with an error code.
	(( $(id -u) == 0 )) || exitme 1 "Must be root user to run this script"

	# Find which logical volume is the home directory
	#
	homemnt=$(awk '$2=="/home" { print }' /etc/fstab)

	[ $? -eq 0 ] || {
		exitme 1 "Can't find \'home\' in /etc/fstab"
	}

	# Create temporary workmnt by replacing 'home' with 'work'
	# in the home string grepped from /etc/fstab
	#
	workmnt="${homemnt//home/work}"

	homedir=$(awk '$2=="/home" { print $2 }' /etc/fstab)
	workdir="/work"

	# 1. Get the device backing /home from fstab
	homemap="$(awk '$2=="/home" { print $1 }' /etc/fstab)"

	# 2. Derive the VG name by stripping “-home” off the mapper basename
	vgname="$(basename "$homemap")"
	vgname="${vgname%-home}"

	homemap="/dev/mapper/${vgname}-home"
	workmap="/dev/mapper/${vgname}-work"

	# 3. Pull the /home LV size (in GB, integer)
	homesiz="$(
	  lvs --noheadings --units g \
	      -o lv_size "${vgname}/home" \
	    | awk '{ print int($1) }'
	)"

	# 4. Compute new sizes
	newhomesiz=$(( homesiz / 2 ))
	worksiz=$(( homesiz - newhomesiz ))

	# 5. Debug output
	echo "VG name:      $vgname"
	echo "Current size: ${homesiz}G"
	echo "New /home:    ${newhomesiz}G"
	echo "/work:        ${worksiz}G"

	umount -v -l "$homedir"
	lvremove -v /dev/"$vgname"/home
	lvcreate -v -L "${newhomesiz}"G -n home "$vgname"
	lvcreate -v -L "${worksiz}"G -n work "$vgname"

	mkfs.xfs "$homemap"
	mkfs.xfs "$workmap"
	[ -d /home ] || mkdir /home
	[ -d /work ] || mkdir /work

	update_fstab "/home" "$homemap"
	update_fstab "/work" "$workmap"

	systemctl daemon-reload
	mount /home
	mount /work
	mount -a

	restorecon -R /work
	restorecon -R /home
}

main $@

exit 0

