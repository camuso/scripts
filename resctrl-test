#!/usr/bin/env bash
set -euo pipefail

# === Global variables ===
declare MONITOR_HUMAN=""
declare MONITOR_JSON=""
declare has_cmt="no"
declare has_mbm="no"
declare has_l3cat="no"
declare has_mba="no"
declare mba_num_cos=""
declare mba_ctrl=""

# User options (defaults)
declare opt_samples=1
declare opt_interval=2

# === Utility functions ===

hr() {
    printf '%*s\n' "${COLUMNS:-80}" '' | tr ' ' -
}

log() {
    local msg="$1"
    printf '[%s] %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" "$msg"
}

usage() {
    cat <<EOF
Usage: resctrl-test [options]

Options:
  --samples N     Number of samples to collect (default: 1)
  --interval N    Interval length in seconds for each sample (default: 1)
  --help          Show this help message and exit

Monitor RDT sample fields:
  TIME      Wall‑clock timestamp when the sample was taken.
  ELAPSED   Duration of the measurement window in seconds.
  CORE      Logical CPU core ID being monitored.
  IPC       Instructions Per Cycle  ratio of retired instructions to CPU cycles.
  MISSES    Last‑Level Cache misses during the interval (in thousands).
  LLC_KB    Last‑Level Cache occupancy attributed to the core (in kilobytes).
EOF
}

# === Capability detection ===
detect_capabilities() {
    local pqos_out
    pqos_out=$(pqos -s 2>&1 || true)

    has_cmt="no"
    has_mbm="no"
    has_l3cat="no"
    has_mba="no"
    mba_num_cos=""
    mba_ctrl=""

    if echo "$pqos_out" | grep -q "CMT"; then
        has_cmt="yes"
    fi
    if echo "$pqos_out" | grep -q "MBM"; then
        has_mbm="yes"
    fi
    if echo "$pqos_out" | grep -q "L3CA"; then
        has_l3cat="yes"
    fi
    if echo "$pqos_out" | grep -q "MBA"; then
        has_mba="yes"
        # Grab the first integer on the MBA COS line
        mba_num_cos=$(echo "$pqos_out" | grep -m1 "MBA COS" | grep -oE '[0-9]+' | head -n1)
        [[ -z "$mba_num_cos" ]] && mba_num_cos="unknown"
        if echo "$pqos_out" | grep -q "CTRL"; then
            mba_ctrl="supported"
        else
            mba_ctrl="unsupported"
        fi
    fi
}

# === Run one sample ===
run_one_sample() {
    local interval="$1"
    local start_time end_time elapsed
    local time_val human json
    local core ipc misses llc_kb

    # temp file for pqos output
    local tmpfile
    tmpfile=$(mktemp)

    start_time=$(date +%s)
    # run pqos for the requested interval
    pqos -I os -m "all:0" -i "$interval" -t "$interval" >"$tmpfile" 2>&1
    end_time=$(date +%s)
    elapsed=$((end_time - start_time))

    time_val=$(date '+%Y-%m-%d %H:%M:%S')

    # grab the last non-header, non-NOTE line
    read -r core ipc misses llc_kb < <(
        awk '!/^CORE/ && !/^TIME/ && $1 ~ /^[0-9]+$/ {line=$0} END{print line}' "$tmpfile"
    )

    rm -f "$tmpfile"

    human="TIME = ${time_val}\nELAPSED = ${elapsed}s\n"
    human+="  CORE = ${core}, IPC = ${ipc}, MISSES = ${misses}, LLC_KB = ${llc_kb}\n"

    json="{\"TIME\":\"${time_val}\", \"ELAPSED\":\"${elapsed}s\", \"cores\":["
    json+="{\"CORE\":\"${core}\",\"IPC\":\"${ipc}\",\"MISSES\":\"${misses}\",\"LLC_KB\":\"${llc_kb}\"}]}"

    printf '%s\n---SPLIT---\n%s' "$human" "$json"
}

# === Monitor workload ===
monitor_rdt() {
    log "Running monitor_rdt workload..."

    local i
    local human_all=""
    local json_all="["

    for ((i=1; i<=opt_samples; i++)); do
        local result human json
        result=$(run_one_sample "$opt_interval")
        human="${result%%---SPLIT---*}"
        json="${result##*---SPLIT---}"

        human_all+="$human"
        json_all+="$json,"
    done

    MONITOR_HUMAN="$human_all"
    MONITOR_JSON="${json_all%,}]"
}

# === Print JSON summary ===
print_json() {
    hr
    echo "=== JSON summary ==="
    cat <<EOF
{
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "monitoring": {
        "cmt": "$has_cmt",
        "mbm": "$has_mbm",
        "pmu": "n/a"
    },
    "l3cat": {
        "present": "$has_l3cat"
    },
    "mba": {
        "present": "$has_mba",
        "num_cos": "$mba_num_cos",
        "ctrl": "$mba_ctrl"
    },
    "monitor_rdt": $MONITOR_JSON
}
EOF
}

# === Main ===
main() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --samples)
                opt_samples="$2"
                shift 2
                ;;
            --interval)
                opt_interval="$2"
                shift 2
                ;;
            -h|-help|--help|help)
                usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    hr
    log "Testing kernel exposure of capabilities..."
    detect_capabilities

    log "Monitoring counters appear supported."
    log "L3 CAT: $has_l3cat"
    log "MBA: $has_mba (Num COS: $mba_num_cos, CTRL: $mba_ctrl)"
    hr

    monitor_rdt

    echo "Monitor RDT last sample(s):"
    printf "%b" "$MONITOR_HUMAN"

    print_json
    log "Tests complete."
}

# Entry point
main "$@"
