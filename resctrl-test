#!/usr/bin/env bash
set -euo pipefail

# === Global variables ===
declare MONITOR_HUMAN=""
declare MONITOR_JSON=""
declare has_cmt="no"
declare has_mbm="no"
declare has_l3cat="no"
declare has_mba="no"
declare mba_num_cos=""
declare mba_ctrl=""

# User options (defaults)
declare opt_samples=1
declare opt_interval=2

# === Utility functions ===

hr() {
    printf '%*s\n' "${COLUMNS:-80}" '' | tr ' ' -
}

log() {
    local msg="$1"
    printf '[%s] %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" "$msg"
}

usage() {
    cat <<EOF
Usage: $0 [OPTIONS]

Options:
  --samples N       Number of most recent samples to report (default: 1)
  --interval SEC    Sample interval in seconds (default: 2)
  -h, -help,
  --help, help      Show this help message and exit

Description:
  This script tests Intel RDT (Resource Director Technology) capabilities
  exposed by the kernel and collects monitoring data using 'pqos'.
  It reports the last N samples in both human-readable and JSON formats.
EOF
}

# === Capability detection ===
detect_capabilities() {
    local pqos_out
    pqos_out=$(pqos -s 2>/dev/null || true)

    # Reset globals
    has_cmt="no"
    has_mbm="no"
    has_l3cat="no"
    has_mba="no"
    mba_num_cos=""
    mba_ctrl=""

    # Monitoring capabilities
    if echo "$pqos_out" | grep -q "CMT"; then
        has_cmt="yes"
    fi
    if echo "$pqos_out" | grep -q "MBM"; then
        has_mbm="yes"
    fi

    # L3 CAT
    if echo "$pqos_out" | grep -q "L3CA"; then
        has_l3cat="yes"
    fi

    # MBA
    if echo "$pqos_out" | grep -q "MBA"; then
        has_mba="yes"
        # Extract number of COS if present
        mba_num_cos=$(echo "$pqos_out" | awk '/MBA COS/ {print $3; exit}')
        # Extract CTRL support if present
        if echo "$pqos_out" | grep -q "CTRL"; then
            mba_ctrl="supported"
        else
            mba_ctrl="unsupported"
        fi
    fi
}

# === Monitor workload ===
monitor_rdt() {
    hr
    log "Running monitor_rdt workload..."

    local human_lines=""
    local mon_fields=""
    local start_time end_time elapsed
    local last_time_line block time_val
    local -a values

    start_time=$(date +%s)

    pqos -I os -m "all:0" -i "$opt_interval" -t "$opt_interval" -o monitor.log

    end_time=$(date +%s)
    elapsed=$((end_time - start_time))

    if [ -f monitor.log ]; then
        local lines
        lines=$(grep -n '^TIME' monitor.log | tail -n "$opt_samples" | cut -d: -f1)

        human_lines=""
        mon_fields=""

        for ln in $lines; do
            block=$(sed -n "${ln},\$p" monitor.log | awk 'NR==1{print; next} /^TIME/{exit} {print}')
            time_val=$(echo "$block" | head -n1 | cut -d' ' -f2-)

            human_lines+="TIME = ${time_val}\nELAPSED = ${elapsed}s\n"
            mon_fields+="{\"TIME\":\"${time_val}\", \"ELAPSED\":\"${elapsed}s\", \"cores\":["

            while read -r line; do
                [ -z "$line" ] && continue
                if echo "$line" | grep -q 'CORE'; then
                    continue
                fi
                read -ra values <<< "$line"
                human_lines+="  CORE = ${values[0]}, IPC = ${values[1]}, MISSES = ${values[2]}, LLC_KB = ${values[3]}\n"
                mon_fields+="{\"CORE\":\"${values[0]}\",\"IPC\":\"${values[1]}\",\"MISSES\":\"${values[2]}\",\"LLC_KB\":\"${values[3]}\"},"
            done <<< "$(echo "$block" | tail -n +3)"

            mon_fields="${mon_fields%,}]},"
        done

        mon_fields="[${mon_fields%,}]"
    fi

    MONITOR_HUMAN="$human_lines"
    MONITOR_JSON="$mon_fields"
}

# === Print JSON summary ===
print_json() {
    hr
    echo "=== JSON summary ==="
    cat <<EOF
{
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "monitoring": {
        "cmt": "$has_cmt",
        "mbm": "$has_mbm",
        "pmu": "n/a"
    },
    "l3cat": {
        "present": "$has_l3cat"
    },
    "mba": {
        "present": "$has_mba",
        "num_cos": "$mba_num_cos",
        "ctrl": "$mba_ctrl"
    },
    "monitor_rdt": $MONITOR_JSON
}
EOF
}

# === Main ===
main() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --samples)
                opt_samples="$2"
                shift 2
                ;;
            --interval)
                opt_interval="$2"
                shift 2
                ;;
            -h|-help|--help|help)
                usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    hr
    log "Testing kernel exposure of capabilities..."
    detect_capabilities

    log "Monitoring counters appear supported."
    log "L3 CAT: $has_l3cat"
    log "MBA: $has_mba (Num COS: $mba_num_cos, CTRL: $mba_ctrl)"

    monitor_rdt

    echo "Monitor RDT last sample(s):"
    printf "%b" "$MONITOR_HUMAN"

    print_json
}

# Entry point
main "$@"
