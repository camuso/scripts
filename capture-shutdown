#!/bin/bash
#
# capture-shutdown
#
# Captures kernel messages and dmesg output during shutdown
# and saves them to a persistent location for bootstat to read
#

[ -n "$MYDIR" ] || {
	declare MYDIR=
	MYDIR="$(dirname "$(readlink -f "$0")")"
}

# Script-level variable declarations
declare shutdown_log_dir="/var/log/shutdown-traces"
declare -i max_traces=10

declare usagestr="$(
cat <<EOF
$(basename "$0") [-h|--help] [-d|--dir DIR] [-m|--max N]

Captures kernel messages and dmesg output during shutdown and saves them to a
persistent location for bootstat to read.

Options:
  -h, --help     Show this help message
  -d, --dir DIR  Directory to save traces (default: $shutdown_log_dir)
  -m, --max N    Maximum number of traces to keep (default: $max_traces)

This script should be run as a systemd service during shutdown.
See capture-shutdown.service for systemd unit file.

EOF
)"

#** usage: print usage information
#*
usage() {
	echo -e "$usagestr"
}

#** control_c: control-c trap
#*
control_c() {
	echo -e "\nCtrl-c detected\nCleaning up and exiting."
	exitme 1
}

#** exitme: exit with code and optional message
#*
# Arguments
#   $1 - exit code
#   $2 - optional message
#*
exitme() {
	local -i code="$1"
	local msg="$2"

	((code == 0)) && exit "$code"
	[[ -n "$msg" ]] && echo -e "$msg" >&2
	usage
	exit "$code"
}

#** capture_shutdown_traces: Capture dmesg and kernel messages
#*
# Arguments
#   $1 - log directory path
#*
capture_shutdown_traces() {
	local log_dir="$1"
	local timestamp
	local trace_file
	local dmesg_output
	# Pattern for actual kernel panics/oops/BUGs, not firmware warnings
	# Exclude "[Firmware Bug]" and similar informational messages
	# Match various BUG formats: "kernel BUG at", "BUG:", "BUG at", etc.
	local critical_pattern="(Call Trace:|Oops:|Kernel panic|kernel BUG|BUG at|BUG:|^[[:space:]]*BUG:|WARNING:|WARN_ON|WARN\(|RIP:|general protection fault|page fault|NULL pointer dereference)"
	
	timestamp=$(date '+%Y%m%d-%H%M%S')
	trace_file="${log_dir}/shutdown-${timestamp}.log"
	
	# Create log directory if it doesn't exist
	mkdir -p "$log_dir" 2>/dev/null || {
		exitme 1 "Error: Cannot create directory $log_dir"
	}
	
	# Create the log file immediately so background process can write to it
	touch "$trace_file" 2>/dev/null || {
		exitme 1 "Error: Cannot create log file $trace_file"
	}
	
	# Start reading from /proc/kmsg IMMEDIATELY in background
	# This must start BEFORE we do anything else to catch messages during reboot
	local kmsg_pid=""
	if [[ -r /proc/kmsg ]]; then
		# Start reading from /proc/kmsg immediately and write to log file
		# This will capture messages including the BUG trace during reboot
		(
			saw_reboot=0
			saw_bug=0
			lines_after_reboot=0
			lines_after_bug=0
			while IFS= read -r line <&3 2>/dev/null || true; do
				# Break if read fails (end of stream)
				[[ -z "$line" ]] && break
				# Write immediately to log file
				echo "$line" >> "$trace_file" 2>/dev/null || break
				# Track if we saw reboot messages
				if echo "$line" | grep -qE "reboot:.*Restarting|reboot:.*machine.*restart"; then
					saw_reboot=1
					lines_after_reboot=0
				fi
				# Track if we saw a BUG trace
				if echo "$line" | grep -qiE "kernel BUG|BUG at|BUG:|Oops:"; then
					saw_bug=1
					lines_after_bug=0
				fi
				# After seeing reboot, keep reading to catch the BUG trace and full stack
				if [[ "$saw_reboot" -eq 1 ]]; then
					lines_after_reboot=$((lines_after_reboot + 1))
					# If we saw a BUG, keep reading for full stack trace
					if [[ "$saw_bug" -eq 1 ]]; then
						lines_after_bug=$((lines_after_bug + 1))
						# Read up to 300 lines after BUG to get full stack trace
						if [[ "$lines_after_bug" -gt 300 ]]; then
							# Got full trace, stop
							break
						fi
					fi
					# If we haven't seen BUG yet, keep reading up to 500 lines after reboot
					if [[ "$saw_bug" -eq 0 ]] && [[ "$lines_after_reboot" -gt 500 ]]; then
						# No BUG found after 500 lines, stop
						break
					fi
				fi
			done 3< /proc/kmsg
		) >> "$trace_file" 2>&1 &
		kmsg_pid=$!
	fi
	
	# Capture dmesg output (while /proc/kmsg is reading in background)
	# Try multiple times with small delays to catch messages that arrive during shutdown
	dmesg_output=$(dmesg -T 2>/dev/null || dmesg 2>/dev/null)
	# Wait a moment and capture again to catch any messages that arrived during capture
	sleep 0.5
	local dmesg_output2
	dmesg_output2=$(dmesg -T 2>/dev/null || dmesg 2>/dev/null)
	# Merge outputs, keeping the longer one (more complete)
	if [[ ${#dmesg_output2} -gt ${#dmesg_output} ]]; then
		dmesg_output="$dmesg_output2"
	fi
	# One more capture after a longer delay to catch messages during reboot sequence
	sleep 1
	local dmesg_output3
	dmesg_output3=$(dmesg -T 2>/dev/null || dmesg 2>/dev/null)
	# Use the longest output (most complete)
	if [[ ${#dmesg_output3} -gt ${#dmesg_output} ]]; then
		dmesg_output="$dmesg_output3"
	fi
	
	# Start writing the log file early so we don't lose data if script is killed
	# Write header and dmesg output first
	{
		echo "=== Shutdown Trace Capture ==="
		echo "Timestamp: $(date)"
		echo "Boot ID: $(cat /proc/sys/kernel/random/boot_id 2>/dev/null || echo 'unknown')"
		echo ""
		
		# First, show critical errors (panics, oops, BUGs) if any
		# Exclude "[Firmware Bug]" and similar informational messages
		local critical_errors
		critical_errors=$(echo "$dmesg_output" | grep -iE "$critical_pattern" | grep -vE "\[Firmware Bug\]|Firmware Bug:" | head -1)
		if [[ -n "$critical_errors" ]]; then
			echo "=== CRITICAL ERRORS DETECTED (Panics/Oops/BUGs) ==="
			# Extract full trace blocks for critical errors
			echo "$dmesg_output" | awk -v pattern="$critical_pattern" '
				{
					lines[NR] = $0
				}
				END {
					max_lines = NR
					last_printed = 0
					for (i = 1; i <= max_lines; i++) {
						# Match pattern but exclude firmware bug messages
						if (lines[i] ~ pattern && lines[i] !~ /\[Firmware Bug\]|Firmware Bug:/ && i > last_printed) {
							# Show 50 lines of context around critical errors
							start = (i - 10 > 1) ? i - 10 : 1
							end = (i + 50 < max_lines) ? i + 50 : max_lines
							for (j = start; j <= end; j++) {
								print lines[j]
							}
							print "---"
							last_printed = end
						}
					}
				}
			'
			echo ""
		fi
		
		echo "=== Full dmesg output ==="
		echo "$dmesg_output"
		echo ""
		
		# Also check kernel log files for recent critical errors
		for logfile in /var/log/kern.log /var/log/messages; do
			if [[ -f "$logfile" ]] && [[ -r "$logfile" ]]; then
				local file_critical
				file_critical=$(tail -200 "$logfile" 2>/dev/null | grep -iE "$critical_pattern" | grep -vE "\[Firmware Bug\]|Firmware Bug:" | head -5)
				if [[ -n "$file_critical" ]]; then
					echo "=== Critical errors in $logfile (last 200 lines) ==="
					tail -200 "$logfile" 2>/dev/null | grep -iEA 30 "$critical_pattern" | grep -vE "\[Firmware Bug\]|Firmware Bug:"
					echo ""
				fi
			fi
		done
		
		# Note: /proc/kmsg reading started earlier in background
		echo "=== Messages from /proc/kmsg (captured during shutdown/reboot) ==="
		echo "(Reading from /proc/kmsg in background - messages will appear below)"
	} > "$trace_file" 2>&1
	
	# The /proc/kmsg reader is already running in background from above
	# Give it time to capture messages during shutdown
	# Don't wait for it - let it continue reading even if script continues
	
	# Append final sections to log file
	{
		echo ""
		
		# Final dmesg capture attempt (in case messages arrived after reading /proc/kmsg)
		# This should include messages from the reboot sequence
		echo "=== Final dmesg capture (after reading /proc/kmsg) ==="
		# Capture dmesg one more time after reading /proc/kmsg
		local final_dmesg
		final_dmesg=$(dmesg -T 2>/dev/null || dmesg 2>/dev/null)
		# Use the longest output (most complete)
		if [[ ${#final_dmesg} -gt ${#dmesg_output} ]]; then
			echo "$final_dmesg"
		else
			echo "$dmesg_output"
		fi
		echo ""
		
		echo "=== Recent kernel messages from journalctl (last 200 lines) ==="
		journalctl -k --no-pager -n 200 2>/dev/null || echo "Journal not available"
		echo ""
		echo "=== End of capture ==="
	} >> "$trace_file" 2>&1
	
	if [[ -f "$trace_file" ]] && [[ -s "$trace_file" ]]; then
		echo "Shutdown trace captured: $trace_file"
		# Check if we captured any critical errors (excluding firmware bug messages)
		# Check the entire file including /proc/kmsg output
		local has_critical
		has_critical=$(grep -iE "$critical_pattern" "$trace_file" 2>/dev/null | grep -vE "\[Firmware Bug\]|Firmware Bug:" | head -1)
		if [[ -n "$has_critical" ]]; then
			echo "WARNING: Critical errors (panics/oops/BUGs) detected in capture!"
		fi
		return 0
	else
		exitme 1 "Error: Failed to capture shutdown trace"
	fi
}

#** cleanup_old_traces: Remove old trace files, keeping only the most recent N
#*
# Arguments
#   $1 - log directory path
#   $2 - maximum number of traces to keep
#*
cleanup_old_traces() {
	local log_dir="$1"
	local -i max_traces="$2"
	
	if [[ ! -d "$log_dir" ]]; then
		return 0
	fi
	
	# Remove old traces, keeping only the most recent ones
	# Sort by modification time (newest first) and remove excess
	find "$log_dir" -name "shutdown-*.log" -type f -printf '%T@ %p\n' 2>/dev/null | \
		sort -rn | \
		tail -n +$((max_traces + 1)) | \
		cut -d' ' -f2- | \
		xargs -r rm -f 2>/dev/null
}

#** main
#*
main() {
	# Trap for control-c
	trap control_c SIGINT

	local log_dir="$shutdown_log_dir"
	local -i max_traces_val="$max_traces"
	
	# Parse arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-h|--help|help)
				usage
				exit 0
				;;
			-d|--dir)
				[[ -z "$2" ]] && exitme 1 "Error: --dir requires a directory argument"
				log_dir="$2"
				shift 2
				;;
			-m|--max)
				[[ -z "$2" ]] && exitme 1 "Error: --max requires a number argument"
				[[ "$2" =~ ^[0-9]+$ ]] || exitme 1 "Error: --max requires a positive integer"
				max_traces_val="$2"
				shift 2
				;;
			*)
				exitme 1 "Unknown option: $1"
				;;
		esac
	done
	
	# Capture shutdown traces
	capture_shutdown_traces "$log_dir"
	
	# Cleanup old traces
	cleanup_old_traces "$log_dir" "$max_traces_val"
	
	exitme 0
}

main "$@"

