#!/bin/bash
#
# ipmikmod
#

declare MYDIR=
declare MYLIB=
declare MYDATA=
declare background=
declare optcount=0

MYDIR="$(dirname "$(which "$(basename "$0")")")"
MYLIB="$MYDIR"/lib
MYDATA=$(realpath ./.data)
[ -d "$MYDATA" ] || mkdir -p "$MYDATA"

source "$MYLIB"/ui.source

declare kmodlog="$MYDATA"/kmod.log
declare kmodparms="$MYDATA"/kmodparms.log
declare ipmidir="./drivers/char/ipmi"
declare -A msgparmtable
declare -A siparmtable

# control_c: run if user hits control-c
#
# Global
#   CTLC_EXIT - bash environment variable
#
control_c() {
	echo -e "\nCtrl-c detected\nCleaning up and exiting."
	exit $CTLC_EXIT
}

# exitme
#
# Globals
#   configfile
#   All vars in configfile
exitme() {
	local -i code=$1
	local artifact="$2"

	ui_exit $code "$artifact"
}

find_parms() {
	local -n list="$1"
	local kmod="$2"

	mapfile -t list < <(find /sys/module -type f | \
			    grep "$kmod" | grep 'parameters')
}

extract_parms() {
	local -n list=$1
	local -n table=$2
	local -i idx
	local key
	local val

	table[dir]="$(dirname "${list[0]}")"

	for ((idx = 0; idx < ${#list[@]}; idx++)); do
		file="${list[idx]}"

		# Assume the parm does not have read permission.
		# If we determine that we can read it, then extract its val.
		#
		val="Does not have read permission"
		[[ $(stat -c "%A" $file) =~ "r" ]] && val="$(cat "$file")"

		key="$(basename "$file")"
		table["$key"]="$val"
	done
}

show_parms() {
	local key

	echo -e "\n $MNU${UND}ipmi_msghandler parameters$OFF"
	echo -e "$INF Directory :$OFF ${msgparmtable[dir]}/"
	for key in "${!msgparmtable[@]}"; do
		[ "$key" == "dir" ] && continue
		printf "$INF %-28s :$OFF %s\n" "$key" "${msgparmtable["$key"]}"
	done

	echo -e "\n $MNU${UND}ipmi_si parameters$OFF"
	echo -e "$INF Directory :$OFF ${siparmtable[dir]}/"
	for key in "${!siparmtable[@]}"; do
		[ "$key" == "dir" ] && continue
		printf "$INF %-20s :$OFF %s\n" "$key" "${siparmtable["$key"]}"
	done
	echo -en "$OFF"
}

get_parms() {
	local -a msgparms
	local -a siparms

	find_parms msgparms ipmi_msghandler
	find_parms siparms ipmi_si

	extract_parms msgparms msgparmtable
	extract_parms siparms siparmtable
}

# init
#
# GLOBALS
#   background
#
init() {
	ui_setbg background

	# If the kmodlog is empty, then get the currently loaded
	# ipmi kmmods.
	#
	[ -s "$kmodlog" ] || lsmod | grep 'ipmi' > "$kmodlog"

	get_parms
}

help_screen() {
	local usagestr

	usagestr=$(
cat <<EOF
$MNU
$(basename "$0") cmd [parameters]
$UND
Commands$OFF

$MNU make$INF : make the kmods

$MNU load kmod [local | booted]$INF : loads the ipmi kmod from local build or
                              booted kernel
                              default is booted

$MNU reload [local | booted]$INF : reload all ipmi kmods from local build or
                           booted kernel
                           default is booted

$MNU setparm kmod parm value$INF : set the kmod parameter value and reload
                           the kmod with it.

$MNU showparm [parm]$INF : show the value of the specific parm
                   default is to show all

$MNU showmods$INF : show the list of kmods loaded with the native kernel

$MNU help$INF : show this help text
$OFF
EOF
)
	echo -e "$usagestr"
}

parsecmd() {
	local cmd="$1"

	shift

	case "$cmd" in
	"make"     ) echo -e "$WRN make not implemented$OFF"
		     ;;
	"load"     ) load "$@"
		     ;;
	"reload"   ) reload "$@"
		     ;;
	"setparm"  ) echo "setparm"
		     ;;
	"showparm" ) show_parms
		     ;;
	"showmods" ) echo "showmods"
		     ;;
	"-h"       ) ;&
	"--help"   ) ;&
	"help"     ) help_screen
	             exitme $ui_exit_ok
	             ;;
	*          ) exitme $ui_err_invcmd "$cmd"
		     ;;
	esac
}

reload() {
	local targ="booted"
	local modcmd="modprobe"
	local inscmd="insmod"
	local mods

	(($# == 1)) && targ="$1"

	[ "$USER" == "root" ] || \
		{ modcmd="sudo modprobe"; inscmd="sudo insmod"; }

	mods="$(cat "$kmodlog" | cut -d' ' -f1)"

	if [ "$targ" == "booted" ]; then
		"$modcmd" -a $mods
		lsmod | grep 'ipmi'
		return $?
	elif [ "$targ" == "local" ]; then

		"$modcmd" -ra $mods

		# Reverse the order, so that the kmod with the most dependencies
		# loads first.
		#
		mods="$(tac "$kmodlog" | cut -d' ' -f1)"

		# We don't build acpi_ipmi in drivers/char/ipmi, so exclude it
		# from the local load. The load of ipmi_si will pull in the
		# booted version of acpi_ipmi.
		#
		for mod in ${mods//acpi_ipmi/}; do
			"$inscmd" "$ipmidir"/"$mod".ko
		done

		lsmod | grep 'ipmi'
		return $?
	else
		exitme $ui_err_invcmd_arg "$targ"
	fi

	return 0
}

# parseopts
#
# Globals
#
parseopts() {
	local arg=
	local opt=

	for arg in $@; do

	    if [ "${arg:0:1}" == "-" ]; then
		opt="${arg:1}"
		shift
		((optcount++))

		case "$opt" in
		h ) echo -e "$usagestr"
		    exit 0
		esac
	    fi
	done
}

main() {
	init
	parsecmd "$@"

	exitme $ui_exit_ok
}

main "$@"
