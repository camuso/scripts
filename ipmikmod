#!/bin/bash
#
# ipmikmod
#

declare MYDIR=
declare MYLIB=
declare MYDATA=
declare background=
declare optcount=0

MYDIR="$(dirname "$(which "$(basename "$0")")")"
MYLIB="$MYDIR"/lib
MYDATA=$(realpath ./.data)
[ -d "$MYDATA" ] || mkdir -p "$MYDATA"

source "$MYLIB"/ui.source

declare configfile=
source "$MYLIB"/config-manager.source

declare kmodlog="$MYDATA"/kmod.log
declare kmodparms="$MYDATA"/kmodparms.log
declare ipmidir="./drivers/char/ipmi"

#** lsmod header fields
#
declare -i modfld=1
declare -i sizfld=2
declare -i usefld=3
declare -i byfld=4
#*

# control_c: run if user hits control-c
#
# Global
#   CTLC_EXIT - bash environment variable
#
control_c() {
	echo -e "\nCtrl-c detected\nCleaning up and exiting."
	cfg_update_configfile
	exit $CTLC_EXIT
}

# exitme
#
# Globals
#   configfile
#   All vars in configfile
exitme() {
	local -i code=$1
	local artifact="$2"

	cfg_update_configfile
	ui_exit $code "$artifact"
}

# init
#
# GLOBALS
#   background
#   configfile
#
init() {
	local bgtemp
	local cfgtemplate

	ui_setbg bgtemp

	configfile="$MYDATA"/ipmikmod.conf
	cfgtemplate="$MYLIB"/ipmikmod.conf
	cfg_start "$cfgtemplate" "$configfile"

	background=$bgtemp
	cfg_set_item "background" "$background"

	# If the kmodlog is empty, then get the currently loaded
	# ipmi kmmods.
	#
	[ -s "$kmodlog" ] || lsmod | grep 'ipmi' > "$kmodlog"
}

help_screen() {
	local usagestr

	usagestr=$(
cat <<EOF
$MNU
$(basename "$0") cmd [cmd parameters]
$UND
Commands$OFF

$MNU make$INF : make the kmods

$MNU reload [local | booted ]$INF : reload kmods from local build or booted kernel
                            default is booted

$MNU setparm <kmod> <parm> <value>$INF : set the kmod parms

$MNU showparm [parm]$INF : show the value of the specific parm
                   default is to show all

$MNU showmods$INF : show the list of kmods loaded with the native kernel

$MNU help$INF : show this help text
$OFF
EOF
)
	echo -e "$usagestr"
}

parsecmd() {
	local cmd="$1"

	shift

	case "$cmd" in
	"make"     ) echo -e "$WRN make not implemented$OFF"
		     ;;
	"reload"   ) reload "$@"
		     ;;
	"setparm"  ) echo "setparm"
		     ;;
	"showparm" ) echo "showparm"
		     ;;
	"showmods" ) echo "showmods"
		     ;;
	"-h"       ) ;&
	"--help"   ) ;&
	"help"     ) help_screen
	             exitme $ui_exit_ok
	             ;;
	*          ) exitme $ui_err_invcmd "$cmd"
		     ;;
	esac
}

reload() {
	local targ="booted"
	local modcmd="modprobe"
	local inscmd="insmod"
	local mods

	(($# == 1)) && targ="$1"

	[ "$USER" == "root" ] || \
		{ modcmd="sudo modprobe"; inscmd="sudo insmod"; }

	mods="$(cat "$kmodlog" | cut -d' ' -f1)"

	if [ "$targ" == "booted" ]; then
		"$modcmd" -a $mods
		lsmod | grep 'ipmi'
		return $?
	elif [ "$targ" == "local" ]; then

		"$modcmd" -ra $mods

		# Reverse the order, so that the kmod with the most dependencies
		# loads first.
		#
		mods="$(tac "$kmodlog" | cut -d' ' -f1)"

		# We don't build acpi_ipmi in drivers/char/ipmi, so exclude it
		# from the local load. The load of ipmi_si will pull in the
		# booted version of acpi_ipmi.
		#
		for mod in ${mods//acpi_ipmi/}; do
			"$inscmd" "$ipmidir"/"$mod".ko
		done

		lsmod | grep 'ipmi'
		return $?
	else
		exitme $ui_err_invcmd_arg "$targ"
	fi

	return 0
}

# parseopts
#
# Globals
#
parseopts() {
	local arg=
	local opt=

	for arg in $@; do

	    if [ "${arg:0:1}" == "-" ]; then
		opt="${arg:1}"
		shift
		((optcount++))

		case "$opt" in
		h ) echo -e "$usagestr"
		    exit 0
		esac
	    fi
	done
}

main() {
	init
	parsecmd "$@"

	exitme $ui_exit_ok
}

main "$@"
