#!/bin/bash
#
# missingfixes

declare MYDIR=
MYDIR="$(dirname "$(readlink -f "$0")")"
declare MYLIB="$MYDIR"/lib
[ "$ui_loaded" ] || source "$MYLIB"/ui.source
[ "$configmanager_loaded" ] || source "$MYLIB"/config-manager.source
MYDATA="$(realpath ./.data)"

declare configfile="$MYDATA/patchreview.conf"
declare remote_dir=
declare outdir=
declare missing_file=
declare usagestr=

usagestr=$(
cat <<EOF

$(basename "$0") [-a] | [upstream-tag]

Description:

  Parses the missing_fixes generated by patchreview for fixes that were made
  before the given upstream-tag.

  NOTE:
       Must be executed in a git repo directory that has executed the
       patchreview script.

Arguments:
  upstream-tag - Any valid upstream tag.

Options:
  -a : Show all the missing fixes detected. Tag will be ignored.

\0
EOF
)

usage() {
	echo -en "$usagestr"
	exit 1
}

check_repo() {
	[ -d ./.git ] && return 0
	echo -e "$STA$PWD$WRN is not a git repository.$OFF"
	return 1
}

check_configfile() {
	[ -f "$configfile" ] && return 0
	echo -e "$STA$PWD$WRN does not have a $STA$configfile$WRN file."
	echo -e "${INF}You must run patchreview before running this script.$OFF"
	return 1
}

check_outdir() {
	[ -d "$outdir" ] && return 0
	echo -e "${WRN}There is no patchreview output directory."
	echo -e "${INF}You must run patchreview before running this script.$OFF"
	return 1
}

check_remote_dir() {
	[ -d "$remote_dir" ] && return 0
	echo -e "${WRN}There is no directory named for the upstream repo."
	echo -e "${INF}You must run patchreview before running this script.$OFF"
	return 1
}

check_missingfile() {
	[ -f "$missing_file" ] && return 0
	echo -e "${WRN}There is no $outdir/missing_fixes file."
	echo -e "${INF}You must run patchreview before running this script.$OFF"
}

init() {
	# Config manager stuff
	check_configfile || usage
	cfg_init_ready "$configfile"

	terminal_background=$(cfg_read_key "background")
	ui_set_colors

	check_repo || usage

	outdir=$(cfg_read_key "outdir")
	outdir=$(realpath "$outdir")
	check_outdir || usage

	remote_dir="$(cfg_read_key "remote_dir")"
	remote_dir="$(realpath "$remote_dir")"
	check_remote_dir || usage

	missing_file="$outdir/missing_fixes"
	missing_file="$(realpath "$missing_file")"
	check_missingfile || usage
}

extract_number() {
	str="$1"
	str=$(echo "$str" | sed 's/[^0-9]*//g')
	echo "${str:0:3}"
}

show_all() {
	while read -r line; do
		echo "$line" | grep -q Missing || continue
		echo "$line" | cut -d' ' -f5-
	done < "$missing_file"

	exit 0
}

commit_in_tag() {
	local commit="$1"
	local tag="$2"

	git rev-list "$tag" | grep -m1 "$(git rev-parse "$commit")" > /dev/null 2>&1
	return $?
}

main() {
	local utag="$1"
	local mypid

	[ ${#@} -ge 1 ] || usage

	init

	[ "$1" == "-a" ] && show_all

	cd "$remote_dir" || {
		echo -e "$WRN$remote_dir does not seem to exist"
		exit 1
	}

	git tag | grep -q -x "$utag" || {
		echo -e "${WRN}Tag $utag is not in this upstream kernel branch.$OFF"
		cd - > /dev/null 2>&1 || exit 1
		exit 1
	}

	while read -r line; do
		echo "$line" | grep -q Missing || continue
		commit=$(echo "$line" | cut -d' ' -f5)

		commit_in_tag "$commit" "$utag" &
		mypid=$!
		ui_waitonproc_tty $mypid .05 || continue

		echo -en "${INF}Missing fix from $STA$utag$INF : "
		echo -e "$line$OFF" | cut -d' ' -f5-
	done < "$missing_file"

	echo -en "$OFF"

	cd - > /dev/null 2>&1 || exit 1
}

main "$@"

exit 0

