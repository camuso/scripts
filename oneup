#!/bin/bash
#
# oneup - Extract the upstream commit hash from a downstream commit
#
# Parses the commit message of a downstream (RHEL) commit to find the
# referenced upstream commit. Looks for "commit <hash>" or "cherry-picked
# from commit <hash>" patterns.
#
# This file uses shdoc-style annotations. See: https://github.com/reconquest/shdoc
#
# Common annotations:
#   @description  - Function/script description
#   @arg          - Function argument: @arg $1 type description
#   @set          - Global variable set: @set varname type description
#   @exitcode     - Exit code: @exitcode 0 description
#   @stdout       - Standard output description
#   @example      - Usage example
#
# Use 'docscript -f funcname <scriptname>' to view function documentation.
#
# Usage:
#   oneup abc123def    # Get upstream commit for downstream abc123def
#   oneup HEAD~5       # Get upstream commit for 5 commits ago

[ -n "$MYDIR" ] || {
	declare MYDIR=
	MYDIR="$(dirname "$(readlink -f "$0")")"
}
declare dncmt
declare -a argv=()
declare -i argc=1

declare usagestr="$(
cat <<EOF

$(basename "$0") dncmt

Extracts the upstream commit from the git log of the given downstream
commit.

Arguments
---------
   dncmt : downstream commit from which to extract the upstream commit

\0
EOF
)"

# usage
# @description Display usage information
#
# Effects:
# @stdout Usage text
#
usage() {
	echo -e "$usagestr"
}

# control_c
# @description Handle Ctrl-C interrupt
#
# Returns:
# @exitcode 130 SIGINT exit code
#
control_c() {
	echo -e "\nCtrl-c detected\nCleaning up and exiting."
	exit $CTLC_EXIT
}

# exitme
# @description Exit with code and optional message
#
# Arguments:
# @arg $1 int Exit code
# @arg $2 string Optional error message
#
# Returns:
# @exitcode As specified by $1
#
exitme() {
	local -i code="$1"
	local msg="$2"

	((code == 0)) && exit "$code"
	echo -e "$msg"
	exit "$code"
}

# check_arg
# @description Check if argument is valid (not a switch)
#
# Arguments:
# @arg $1 string Argument to check
#
# Globals:
# @set argv array Appends valid argument
#
# Returns:
# @exitcode 0 Valid argument (added to argv)
# @exitcode 1 Invalid (starts with hyphen)
#
check_arg() {
	local arg="$1"

	# If 1st char is a hyphen, then invalid switch
	[ "${arg:0:1}" == "-" ] && return 1

	# Otherwise, add the arg to the argary
	argv+=("$arg")
	return 0
}

# parseopts
# @description Parse command line options
#
# Globals:
# @set argv array Command line arguments
#
# Returns:
# @exitcode 0 Success
#
parseopts() {
	while (($# > 0)); do
		case "$1" in
			-h | --help )
				echo -e "$usagestr"
				exit 0
				;;
			* )
				argv+=("$1")
				;;
		esac
		shift
	done
	return 0
}

# main
# @description Main entry point - extract upstream commit from downstream
#
# Arguments:
# @arg $@ string Command line arguments (expects downstream commit)
#
# Effects:
# @stdout The upstream commit hash
#
# Returns:
# @exitcode 0 Success - upstream commit found and printed
# @exitcode 1 No upstream commit found in the downstream commit log
#
main() {
	local dnlog
	local upcmt

	# Trap for control-c
	trap control_c SIGINT

	parseopts "$@"
	dncmt="${argv[0]}"

	# Get the downstream log less the downstream commit header
	dnlog="$(git log -1 "$dncmt" | tail -n +2)"

	# Strip all leading spaces
	dnlog="$(echo "$dnlog" | sed -e 's/^ *//g')"

	# Extract the upstream commit from the downstream log
	upcmt="$(echo "$dnlog" | grep -E -m1 '^commit')"

	# If it didn't start with commit, see if it started with cherry-picked
	[ -n "$upcmt" ] || upcmt="$(echo "$dnlog" | grep -E -m1 'cherry-picked from')"

	# If we can't find a corresponding upstream commit, exit now.
	[ -n "$upcmt" ] || exitme 1 "Could not find an upstream commit for $dncmt"

	# Get just the commit hash and print it.
	upcmt="$(awk '{print $NF}' <<< "$upcmt")"
	# Remove trailing parenthesis if present (from cherry-picked format)
	upcmt="${upcmt%)}"
	echo "$upcmt"

	exitme 0
}

main "$@"
