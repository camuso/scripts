#!/bin/bash
#
# commitcmp
#

declare MYDIR=
MYDIR="$(dirname "$(which "$(basename "$0")")")"
declare MYLIB="$MYDIR"/lib

[ "$ui_loaded" ]            || source "$MYLIB"/ui.source
[ "$configmanager_loaded" ] || source "$MYLIB"/config-manager.source

declare -i background=

# Other exit codes
declare -i exit_ok=0
declare -i exit_invarg=1
declare -i exit_invpath=2	# invalid path
declare -i exit_invdir=3
declare -i exit_disfil=4	# directory name is a file
declare -i exit_nooutd=5	# directory name is empty

declare -a exitmsgary=

exitmsgary=(
""
"Invalid number of arguments."
" path does not exist."
" is an invalid directory name."
" is a file, not a directory."
"You did not provide an output directory path:$MNU -o <outdir>$OFF"
)

exitme() {
	local -i exitval=$1
	local strarg=""
	local exitmsg

	if [ "$exitval" -ne $exit_ok ] && [ "$exitval" -ne $CTLC_EXIT ]; then
		[ $# -eq 2 ] && strarg=$2
		[ ${#exitmsgary[@]} -gt "$exitval" ] \
			&& exitmsg="${exitmsgary[$exitval]}"

		echo -e "$WRN$strarg$exitmsg$OFF"

		[ "$exitval" -ne 0 ] && echo -e \
			"${INF}Type$MNU commitcmp -h$INF for help.$OFF"
	fi

	exit "$exitval"
}

# run if user hits control-c
#
control_c()
{
	echo -en "
	${WRN}Ctrl-c detected$INF
Cleaning up and exiting.$OFF
"
	exitme $CTLC_EXIT
}

declare -i optcount=0
declare uplog="upstream.log"
declare dnlog="downstream.log"
declare chlog="backport.log"
declare outdir=
declare updir=
declare upcmt=
declare dncmt=
declare searchstr=
declare path=

usage() {
	local usagestr

	usagestr=$(
cat <<EOF
$MNU
$(basename "$0") -dc dncmt -o outdir [-ud updir] [path-1 path-2 ... path-n]
$OFF
Uses scripts ${STA}gitnice$OFF and ${STA}extup$OFF to create a list of commits
to backport. Commits that have already been backported will have
a leading # to effectively comment them out to processing scripts, like
git-backport.

This must be run in the downstream repo directory.

Creates the following files in the <outdir>.
  $STA$uplog$OFF   - contains the upstream commits since <upcmt>
  $STA$dnlog$OFF - contains the downstream commits since <dncmt>
  $STA$chlog$OFF   - contains the upstream commits that have not yeat been
                   backported downstream.

  Optionally, if a search string was provided with the$STA -S$OFF option, another
  $STA$chlog$OFF file in the same directory but with the first field in the search
  string prepended to its name.
$MNU
Options:$OFF$MNU
  -h$OFF         - this help text$MNU
  -ud ${OFF}updir  - OPTIONAL directory with the upstream repo, default is ./$MNU
  -dc ${OFF}dncmt  - starting from the given downstream commit$MNU
  -o  ${OFF}outdir - Directory for ouput files.
               Upstream file will be named $STA$uplog$OFF
               Downstream file will be named $STA$dnlog$OFF
               Backport file will be named $STA$chlog$MNU

  -p ${OFF}paths  - space separated list of subsystem directories or filenames.$MNU
  -S ${OFF}string - comma separated list of search strings
	      A $STA$chlog$OFF file will be created for each search string
	      with the first field of the string prepended to its name.
	      The file(s) will contain commit hashes that contain the
	      string(s).$MNU
Example:$OFF
  $(basename "$0") \\\

        -ud /work/upstream/kernel \\\

        -dc kernel-5.14.0-87.el9 \\\

        -p drivers/char/ipmi include/linux/ipmi.h include/linux/ipmi_smi.h \\\

        -o ../backport/9.2/ipmi/ \\\

        -S ipmi_msg,kcs
$OFF
\0
EOF
)
	echo -en "$usagestr"
	exitme 0
}

get_pathopt() {
	local path=$1
	local -n optname="$2"

	[ -e "$path" ] || exitme $exit_invpath
	optname=$(realpath "$path")
}

get_varopt() {
	local var="$1"
	local -n varname="$2"

	varname="${var//,/ }"
}

test_help() {
	local opt="$1"

	shopt -s nocasematch
	[[ $opt =~ (h|help) ]] && { usage; exitme $exit_ok; }
	shopt -u nocasematch
}

# parseops() - parse the input options
#
# Needed multicharacter optionis, but didn't want to use longopts.
#
# Inputs: $@, the whole command line
#
# Globals:
# 	optcount
# 	upcmt
# 	dncmt
# 	usagestr
# 	searchstr
# 	path
#
parseops() {
	local arg=
	local opt=
	local -i argc=$#
#set -x
	while (($# > 0)); do
	    arg="$1"

	    if [ "${arg:0:1}" == '-' ]; then
		opt="${arg:1}"

		shift
		case "$opt" in
		    ud ) get_pathopt "$1" updir
			 ;;
		    dc ) get_varopt "$1" dncmt
			 ;;
		    S  ) get_varopt "$1" searchstr
			 ;;
		    o  ) get_pathopt "$1" outdir
			 ;;
		    *  ) echo "unrecognized option -$1"
			 echo -e "$usagestr"
			 exit 127
		esac
	    else
		if [ -e "$arg" ]; then
		    path="$path $arg"
		else
		    echo -e "$MNU$path : $WRN${exitmsgary[exit_invpath]}$OFF"
		    echo -e "${INF}and will not be included in the search.$OFF"
		fi
	    fi
	    shift
	done
#set +x
}

# compare_strings() - compare strings
#    Compare the commits from the upstream and downstream commit logs
#    to identify those the ones that have already been backported.
#    Output all commit lines to the cherp.log file, marking the ones
#    that werre already backported with a leading #
#
# GLOBALS
#	chlog - output commits file
#	uplog - upstream commits file
#	dnlog - downstream commits file
#	outdir - directory for all the commit log files
#
compare_strings() {
	local uppath="$outdir/$uplog"
	local dnpath="$outdir/$dnlog"
	local chpath="$outdir/$chlog"
	local savedifs="$IFS"
	local upstr=
	local rhstr=
	local up	# one line from the upstream log
	local tmp
	local b_match=false
	local j		# upstr index
	local k		# rhstr index

	# Instead of reading from the file, which limmits our debug
	# capabilites, create an array out of the lines in the file.
	# Set IFS to newline and then restore it after createing the
	# string arrays.
	#
	IFS=$'\n'
	upstr=($(< "$uppath"))
	rhstr=($(< "$dnpath"))
	IFS="$savedifs"

	# Zero the backport log file.
	:> "$chpath"

	for ((j = 0; j < ${#upstr[@]}; ++j)); do
		up=${upstr[j]}
		upcmt="${up:0:9}"

		for ((k = 0; k < ${#rhstr[@]}; ++k)); do
			tmp=$(echo "${rhstr[k]}" | cut -d' ' -f2)
			rhcmt="${tmp:0:9}"

			[[ "$rhcmt" == "$upcmt" ]] && {
				b_match=true
				break
			}
		done

		$b_match && echo "# $up" >> "$chpath" || echo "$up" >> "$chpath"
		$b_match && echo "# $up" || echo "$up"
		b_match=false
	done
}

init_env() {
	local bgtemp

	ui_setbg bgtemp

	MYDATA=$(realpath ./.data)
	[ -d "$MYDATA" ] || mkdir -p "$MYDATA"

	configfile="$MYDATA/mkbackportlog.conf"
	cfgtemplate="$MYLIB/mkbackportlog.conf"
	[ -f "$configfile" ] || cp "$cfgtemplate" "$configfile"

	cfg_start "$cfgtemplate" "$configfile"
	background="$bgtemp"
	cfg_set_item "background" "$background"
}

check_log() {
	log="$1"

	echo -e "${INF}Create : $STA$log$OFF"

	[ -f "$log" ] && {
		echo -en "$WRN$log exists.$OFF "
		echo -e "${INF}It will be overwritten if you continue.$OFF"
	}
}

get_mainbranch() {
	local line=
	local pline=
	local ary=()

	while read -r line; do
		if [[ $line == *"remote = origin"* ]]; then
			break
		else
			pline="$line"
		fi
	done < .git/config

	ui_strtok "$pline" '"' ary
	echo "${ary[1]}"
}

seek_str() {
	local prepend=
	local outfile=
	local commit
	local str

	[ -d "$updir" ] && { cd "$updir" || exitme $exit_invdir; }

	for str in $searchstr; do
		prepend=$(echo "$str" | cut -d' ' -f1)
		outfile="$outdir/$prepend-$chlog"

		echo -e "\n${STA}Creating $outfile$INF"
		: > "$outfile"
		while read -r line; do
			[ "${line:0:1}" == "#" ] && continue
			commit=$(echo "$line" | cut -d' ' -f1)
			git show "$commit" | grep -q -m1 "$str" || continue
			echo "$line" | tee -a "$outfile"
		done < "$outdir/$chlog"
	done
	cd - > /dev/null 2>&1 || exitme $exit_invdir
}

main() {
	local mainbranch
	local -a tmpary=()

	init_env

        # Trap for control-c
        trap control_c SIGINT

	[ -f .git/config ] || {
		echo -e "${WRN}Not a repo directory!"
		echo -e "${INF}You must be in a repo directory."
		exit 1
	}
	mainbranch=$(get_mainbranch)

	test_help "$1"

	parseops "$@"

	[ -n "$outdir" ] || exitme $exit_nooutd

	echo

	check_log "$outdir/$uplog"
	check_log "$outdir/$dnlog"
	check_log "$outdir/$chlog"

	# Extract the upstream commit from the submitted RHEL commit, which is
	# the most recent RHEL commit under consideration, entered with the
	# -dc option.
	tmpary=($(extup -1 -r -n -u "$updir" "$dncmt"))
	upcmt="${tmpary[1]}"

	echo -e "${INF}Upstream repo     : $STA${updir}origin/master $OFF"
	echo -e "${INF}Upstream commit   : $STA$upcmt$OFF"
	echo -e "${INF}Downstream branch : $STA$mainbranch$INF"

	if [ -n "$path" ]; then
		# If there's more than one path, show them all.
		if (($(wc -w <<< "$path") > 1)); then
			echo -e "${INF}Paths:$OFF"
			# shellcheck complains about vars without quotes, but
			# sometimes, it's what you really want.
			printf "  %s\n" $path
		else
			echo -e "${INF}Path:$OFF $path"
		fi
	fi

	echo
	echo -n "Press any key to proceed or CTRL-C to exit..."
	read -r -n1

	echo -e "$STA"
	[ -d "$updir" ] && { cd "$updir" || exitme $exit_invdir; }
	pwd
	echo -e "${STA}Creating $outdir/$uplog$INF"

	# Get the list of upstream commits starting from the one extracted from
	# the submitted RHEL commit with the -dc option.
	gitnice -r -c -d --no-merges "$upcmt..HEAD" $path 2>&1 | tee "$outdir/$uplog"
	echo

	echo -e "$STA"
	cd - || exitme $exit_invdir
	echo -e "${STA}Creating $outdir/$dnlog$INF"
	extup -r -n -u "$updir" "$dncmt..HEAD" $path 2>&1 | tee "$outdir/$dnlog"

	echo
	echo -e "${STA}Creating $outdir/$chlog$INF"
	compare_strings

	[ -n "$searchstr" ] && seek_str
	echo -e "$OFF"

	exitme $exit_ok
}

main "$@"

exitme $exit_ok

