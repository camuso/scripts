#!/bin/bash

# Script-level variables
declare config_file="$HOME/.config/lab/lab.toml"
declare token=""
declare state=""
declare project_filter=""
declare regex_filter=""
declare -i b_count_only=0
declare usagestr="$(
cat <<EOF
$(basename "$0") [-s state] [-p project] [-r regex] [-c]

List GitLab merge requests authored by you.

By default, all MRs are returned. Use filters to narrow the results.

Switches (all optional, can be combined):
  -s state    Filter by state: open, merged, or closed
  -p project  Filter by project name (partial match, case-insensitive)
  -r regex    Filter by regex pattern (matches project, title, or URL)
  -c          Print only the count of MRs matching the filter(s)
  -h          Show this help message

Examples:
  $(basename "$0")
      List all MRs (open, merged, and closed)

  $(basename "$0") -s merged
      List only merged MRs

  $(basename "$0") -s open -p kernel
      List open MRs in projects containing "kernel"

  $(basename "$0") -p rhel -r "usb|xhci"
      List all MRs in "rhel" projects matching "usb" or "xhci"

  $(basename "$0") -s merged -c
      Print only the count of merged MRs

  $(basename "$0") -s open -p kernel -r "net" -c
      Count open MRs in "kernel" projects matching "net"

EOF
)"

#** usage: print usage information
#*
usage() {
	echo -e "$usagestr"
}

#** exitme: exit with code and optional message
#*
# Arguments
#   $1 - exit code
#   $2 - optional message
#*
exitme() {
	local -i code="$1"
	local msg="$2"

	((code == 0)) && exit "$code"
	[[ -n "$msg" ]] && echo -e "$msg" >&2
	usage
	exit "$code"
}

#** control_c: control-c trap
#*
control_c() {
	echo -e "\nCtrl-c detected\nCleaning up and exiting."
	exitme 1
}

#** check_jq: check if jq is installed, offer to install if not
#*
check_jq() {
	command -v jq &>/dev/null && return 0

	echo "jq is required but not installed."
	read -rp "Would you like to install jq now? (y/n): " response
	if [[ "$response" =~ ^[Yy] ]]; then
	    echo "Installing jq..."
	    sudo dnf install -y jq || exitme 1 "Failed to install jq"
	    echo "jq installed successfully."
	else
	    exitme 1 "jq is required to run this script."
	fi
}

#** check_lab: check if lab is installed, offer to install if not
#*
check_lab() {
	local repo_file="/etc/yum.repos.d/_copr:copr.fedorainfracloud.org:bmeneguele:rhkernel-devtools.repo"

	command -v lab &>/dev/null && return 0

	echo "lab is required but not installed."

	if [[ ! -f "$repo_file" ]]; then
	    echo -e "\nThe rhkernel-devtools COPR repo is not configured."
	    echo "To install lab, you need to add the repo first:"
	    echo ""
	    echo "  sudo dnf copr enable bmeneguele/rhkernel-devtools"
	    echo ""
	    echo "Then run this script again."
	    exitme 1 "Missing required repo for lab installation."
	fi

	read -rp "Would you like to install lab now? (y/n): " response
	if [[ "$response" =~ ^[Yy] ]]; then
	    echo "Installing lab..."
	    sudo dnf install -y lab || exitme 1 "Failed to install lab"
	    echo "lab installed successfully."
	else
	    exitme 1 "lab is required to run this script."
	fi
}

#** check_labconfig: check if lab.toml exists
#*
check_labconfig() {
	if [[ ! -f "$config_file" ]]; then
	    echo "lab configuration file not found at: $config_file"
	    echo ""
	    echo "Please run 'lab' once to configure it with your GitLab token."
	    exitme 1 "Missing lab configuration."
	fi
}

#** get_token: extract token from lab.toml (robust)
#*
get_token() {
	token=$(
	    awk -F'=' '
		/^[[:space:]]*(token|api_token)[[:space:]]*=/ {
		    val=$2
		    gsub(/^[[:space:]]+|[[:space:]]+$/, "", val)
		    gsub(/#.*/, "", val)
		    gsub(/^"[[:space:]]*|[[:space:]]*"$/, "", val)
		    gsub(/^'\''[[:space:]]*|[[:space:]]*'\''$/, "", val)
		    if (val != "") { print val; exit }
		}
	    ' "$config_file"
	)

	if [[ -z "$token" ]]; then
	    exitme 1 "Error: Could not extract token from $config_file"
	fi
}

#** list_mrs: list merge requests with filters
#*
# Globals used:
#   state          - state filter (open, merged, closed) or empty for all
#   project_filter - project name filter (partial match)
#   regex_filter   - regex filter for project/title/url
#   b_count_only   - if 1, only output the count
#*
list_mrs() {
	local -i page=1
	local -a all_results=()
	local api_url="https://gitlab.com/api/v4/merge_requests?scope=created_by_me&per_page=100"

	# Add state filter to API call if specified
	if [[ -n "$state" ]]; then
		api_url+="&state=$state"
	else
		# Fetch all states by using 'all'
		api_url+="&state=all"
	fi

	while true; do
		local response
		response=$(curl -s --header "PRIVATE-TOKEN: $token" \
			"${api_url}&page=$page")

		local -i count
		count=$(echo "$response" | jq 'length')

		if (( count == 0 )); then
			break
		fi

		# Build jq filter based on provided options
		local jq_filter='.[] | {
			project: (.references.full // .web_url),
			title: .title,
			merged_at: .merged_at,
			url: .web_url
		}'

		# Add project filter if specified
		if [[ -n "$project_filter" ]]; then
			jq_filter+=" | select((.project // \"\") | test(\"$project_filter\"; \"i\"))"
		fi

		# Add regex filter if specified
		if [[ -n "$regex_filter" ]]; then
			jq_filter+=" | select(
				((.project // \"\") | test(\"$regex_filter\"; \"i\")) or
				((.title // \"\") | test(\"$regex_filter\"; \"i\")) or
				((.url // \"\") | test(\"$regex_filter\"; \"i\"))
			)"
		fi

		# Collect results
		local page_results
		page_results=$(echo "$response" | jq "$jq_filter")

		if [[ -n "$page_results" ]]; then
			all_results+=("$page_results")
		fi

		((page++))
	done

	# Output results
	if (( b_count_only )); then
		# Count the number of JSON objects in all results
		local -i total=0
		for result in "${all_results[@]}"; do
			local -i cnt
			cnt=$(echo "$result" | jq -s 'length')
			((total += cnt))
		done
		echo "$total"
	else
		# Print all results
		for result in "${all_results[@]}"; do
			echo "$result"
		done
	fi
}

#** parse_args: parse command line arguments
#*
parse_args() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-h|--help)
				usage
				exit 0
				;;
			-s)
				shift
				if [[ -z "$1" || "$1" == -* ]]; then
					exitme 1 "Error: -s requires a state argument (open, merged, closed)"
				fi
				case "$1" in
					open|opened|merged|closed)
						state="$1"
						;;
					*)
						exitme 1 "Error: Invalid state '$1'. Use: open, merged, or closed"
						;;
				esac
				;;
			-p)
				shift
				if [[ -z "$1" || "$1" == -* ]]; then
					exitme 1 "Error: -p requires a project filter string"
				fi
				project_filter="$1"
				;;
			-r)
				shift
				if [[ -z "$1" || "$1" == -* ]]; then
					exitme 1 "Error: -r requires a regex pattern"
				fi
				regex_filter="$1"
				;;
			-c)
				b_count_only=1
				;;
			*)
				exitme 1 "Error: Unknown option '$1'"
				;;
		esac
		shift
	done
}

#** main: entry point
#*
main() {
	trap control_c SIGINT

	parse_args "$@"

	# Check dependencies
	check_jq
	check_lab
	check_labconfig

	get_token
	list_mrs
}

main "$@"

