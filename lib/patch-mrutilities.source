#!/bin/bash
#
# lib/patch-mrutilities.source
#
# This source file provides routines common to both patchreview and
# patchdevelop scripts.
#
# The following source files must be included before this one.
#

# Get the directory defaults if they don't already exist
#
[ "$MYDIR" ] || declare MYDIR=$(dirname $(which $(basename $0)))
[ "$MYLIB" ] || declare MYLIB=$(cd $(dirname ${BASH_SOURCE[0]}); pwd)

[ "$ui_loaded" ] || source $MYLIB/ui.source
[ "$patchcommon_loaded" ] || source $MYLIB/patch-common.source
[ "$configmanager_loaded" ] || source $MYLIB/config-manager.source

patchmrutilities_loaded=true

b_ui_int_first_getyn=false	# For lib/ui.source

# Enable extglob for more specific directory actions
#
shopt -s extglob

#######################################
# Global variables
#######################################
declare -i opmode
declare -i opmode_mr=0
declare -i opmode_email=1
declare -i opmode_states=2
declare prj_opmode

declare current_mr=
declare b_mrflag=false
declare b_reviewed=false
declare b_acked=false
declare b_nacked=false
declare mergelist_filter=
declare mergelist_author=
declare mergelist_file=$MYDATA/mergelist.log
declare gl_projid=24118165	# gitlab project ID

declare -i mr_val=0	# valid mr
declare -i mr_inv=1	# invalid mr
declare -i mr_nop=2	# no patches found
declare -i mr_norev=3	# skip the review
declare -a mr_errs=(
""
"${WRN}Merge Request not found$OFF"
"${WRN}No patches found for Merge Request$OFF"
)

# show_init - display the init menu option
#
# Globals:
# 	current_mr
#
show_init() {
	echo -n "Init to defaults"
	if [ "$current_mr" ]; then
		echo -en " and clear MR $STA$current_mr$OFF and its files"
	fi
	echo
}

# show_mrcomments - display ON or OFF depening on mrcomments state
#
# Globals
#     mrcomments
#
show_mrcomments() {
	$b_mrcomments && echo "ON" || echo "OFF"
}


# show_mrfilter - show the merge list filter
#
# Globals
# 	mergelist_filter
# 	mergelist_author
#
show_mrfilter() {
	[ -n "$mergelist_filter" ] && \
		echo -en "${INF}String:$OFF $STA$mergelist_filter$OFF"
	[ -n "$mergelist_author" ] && \
		echo -en "${INF}Author:$OFF $STA$mergelist_author$OFF"
}

# grep_mrlist() - grep or filter the mr list
#
# Globals:
# 	mergelist_filter
#
grep_mrlist() {
	$b_mrflag || return

	local promptstr=$(
cat <<EOF
Enter grep string or just press$STA Enter$INF to clear it and return: 
EOF
)
	getuser "$promptstr" mergelist_filter
	set_cfg_item "mergelist_filter" $mergelist_filter
	[ -n "$mergelist_filter" ] || return 1
	select_merge_request
	return $?
}

# change_opmode - change the operating mode of the script
#
# Certain global variables need to be flipped for Merge Request
# and Email operation modes.
#
# Globals
# 	opmode
# 	opmode_mr
# 	opmode_email
# 	opmode_states
# 	cmpmode
# 	cmpmode_batch
# 	applymode
# 	applymode_off
# 	applymode_norm
# 	b_rename_files
# 	b_fmt_upstream
#
change_opmode() {
	ui_cycle_state opmode $opmode_states
	set_cfg_item "opmode" $opmode

	case $opmode in
	$opmode_mr    ) b_mrflag=true
			b_rename_files=false
			b_fmt_upstream=true
			cmpmode=$cmpmode_batch
			applymode=$applymode_off
			;;
	$opmode_email ) b_mrflag=false
			b_rename_files=false
			b_fmt_upstream=true
			cmpmode=$cmpmode_batch
			applymode=$applymode_norm
			;;
	esac
}

# show_opmode - display whether we're in Merge Request or Email Mode
#
# Globals:
# 	opmode
# 	opmode_mr
# 	opmode_email
# 	prj_opmode
#
show_opmode() {
	case $opmode in
		$opmode_mr    ) echo "Merge Request Mode" ;;
		$opmode_email ) echo "Email Patch Mode" ;;
	esac
}

# show_mrstatus- display the current mr and its status
#
# Globals:
# 	current_mr
# 	b_reviewed
# 	b_acked
# 	b_nacked
#
show_mrstatus() {
	local ackstr

	[ -n "$current_mr" ] || return 1
	[ "$current_mr" == "q" ] && return 1

	( $b_acked || $b_nacked ) && {
		$b_acked && ackstr="${STA}ACKED$OFF" \
			  || $ackstr="${WRN}NACKED$OFF"
	} || {
		ackstr=
	}

	echo -e "\n    Merge Request           : $STA$current_mr $ackstr"
	[ -s "$missing_fixes" ] && echo -e \
		"   $WRN There are missing fixes listed in $STA$missing_fixes$OFF"
}

# query_acknack - ask the user if they want to respond to the MR
#
# Globals
# 	b_mrflag
# 	current_mr
# 	b_reviewed
# 	b_acked
# 	b_nacked
#
query_acknack() {
	$b_mrflag || return 1
	local cmt=
	local response
	local b_yes=false
	local actstr=
	local b_newmr=false
	local acknackmenu=$(
cat <<EOF

$MNU For MR $STA$current_mr$MNU, you want to ...
$MNU a$STA  ACK$OFF
$MNU A$STA  ACK$OFF with comment
$MNU n$WRN  NACK$OFF
$MNU N$WRN  NACK$OFF with comment
$MNU c$OFF  Comment only
$MNU q$OFF  Skip this step$OFF
\0
EOF
)
	[ -z "$current_mr" ] && {
		getuser "Enter a merge request number or $qstr$INF to exit: " current_mr
		b_newmr=true
		b_reviewed=false
		b_acked=false
		b_nacked=false
		[ "$current_mr" == "q" ] && {
			current_mr=
			return
		}
	}

	$b_reviewed && ( $b_acked || $b_nacked ) && {
		$b_acked && actstr="${STA}ACKED$OFF" \
			 || actstr="${WRN}NACKED$OFF"
		local donestr="\
${INF}Merge Request: $STA$current_mr$INF has already been $actstr"
		echo -e "$donestr"
		return
	}

	while :; do
		echo -e "$acknackmenu"
		promptgetchar ""$MNU"Enter one of the above: $OFF" response
		[[ qnaNAc =~ $response ]] && break
	done

	case "$response" in
		q ) return 1
		    ;;
		A ) cmt="--with-comment --force-linebreak "
		    ;&
		a ) b_acked=true
		    b_reviewed=true
		    actstr=""$STA"ACK$OFF"
		    ;;
		N ) cmt="--with-comment --force-linebreak "
		    ;&
		n ) b_nacked=true
		    b_reviewed=true
		    actstr=""$WRN"NACK$OFF"
		    ;;
		c ) b_nacked=false
		    b_acked=false
		    b_reviewed=true
		    lab mr note --force-linebreak $current_mr
		    return 0
		    ;;
	esac

	local querystring="\
"$INF"Are you sure you want to $actstr Merge Request \
$STA$current_mr$INF (y/n)? $OFF"
	loop_yn "$querystring" b_yes

	if $b_yes; then
		$b_acked && lab mr approve $cmt $current_mr
		$b_nacked && lab mr unapprove $cmt $current_mr
	else
		b_acked=false
		b_nacked=false
	fi

	return 0
}

# call_lab_mr_list - worker function to create the mr list
#
# Inputs:
# 	$1 - outfile that will contain the list
#
call_lab_mr_list() {
	local outfile="$1"
	local specifier="$2"
	local srtcmd="sort -t ! -k2 -h"
	local labcmd="lab mr list $specifier"

	$labcmd | $srtcmd > $outfile
}

# refresh_mergelist - refresh the file containing the list of merge requests
#
# Globals:
# 	$mergelist_file
#
refresh_mergelist() {
	rm -f "$mergelist_file"
	select_merge_request
	return 0
}

# show_comments - display the view comments menu option
#
# Globals
# 	current_mr
#
show_comments() {
	if [ -n "$current_mr" ]; then
		echo "View comments for MR $STA$current_mr$OFF"
	else
		echo "View comments for a specific MR"
	fi
}

# view_comments - view the comments only for a specific MR
#
# Globals
# 	current_mr
#
view_comments() {
	[ -n "$current_mr" ] && { lab mr show --comments $current_mr; return; }
	get_merge_request "comments"
}

# get_mrlist_specifier - which mr list specifier does the user want
#
# Outputs
#     $1 - specifier string is returned in $1
#
get_mrlist_specifier() {
	local spec=
	local author=
	local targbranch=
	local specmenu=$(
cat <<EOF
$MNU
     ${UND}Specify the MR list content   $OFF
 $MNU a$OFF  All MRs on the project
 $MNU o$OFF  Open MRs
 $MNU r$OFF  Ready MRs
 $MNU d$OFF  Draft MRs
 $MNU n$OFF  No-conflicts, can be merged
 $MNU c$OFF  Conflicts, cannot be merged
 $MNU m$OFF  Merged MRs
 $MNU A$OFF  Author of MRs
 $MNU C$OFF  Closed MRs
 $MNU t$OFF  Specify a Target Branch
 $MNU q$OFF  Quit and return to main menu
\0
EOF
)
	echo -e "$specmenu"

	while :; do
		promptgetchar "${MNU}Select a MR list specifier: $OFF" spec
		case $spec in
			q ) current_mr= ; return 1 ;;
			a ) spec="--state all --all";  break ;;
			o ) spec="--state opened --all"; break ;;
			d ) spec="--draft --all"; break ;;
			r ) spec="--ready --all"; break ;;
			n ) spec="--no-conflicts --all"; break ;;
			c ) spec="--conflicts --all"; break ;;
			m ) spec="--state merged --all"; break ;;
			C ) spec="--state closed --all"; break ;;
			A ) getuser "Enter the Author's name: " author
			    spec="--state all --all --author $author"
			    break
			    ;;
			t ) getuser "Enter Target Branch: " targbranch
			    spec="--state all --all -t $targbranch"
			    break
			    ;;
		esac
	done

	eval $1='$spec'
	return 0
}

# show_mrlist - display the list of MRs obtained by call_lab_mr_list
#
#  Globals
#	current_mr
#	mergelist_file
#
show_mrlist() {
	local -n mrarray=$1	# pass array by reference
	local mr=
	local mrnum=
	local mrsub=

	while read mr; do
		[[ $mr == *$mergelist_filter* ]] || continue
		mr=$(echo ${mr:1})
		mrnum=$(echo $mr | cut -d' ' -f1)
		mrsub=$(echo $mr | cut -d' ' -f2-)
		mrarray+=("$mrnum")
		echo -e " $MNU$mrnum$OFF $mrsub"
	done < $mergelist_file

	getuser "Enter a merge request number or $qstr$INF to exit: " current_mr

}

# select_merge_request - select a MR from a list
#
#  Presents a list of Merge Requests for the user to select one.
#  The selected merge request is checked-out into its own branch
#  for review.
#
# Globals
# 	mergelist_file
# 	current_mr
#
# Inputs: none
#
select_merge_request() {
	local mrs=()
	local mr=
	local mrnum=
	local mrsub=
	local select=
	local mypid=
	local specifier=

	[ -s "$mergelist_file" ] || {
		get_mrlist_specifier specifier
		[ $? -eq 0 ] || return 1
		call_lab_mr_list "$mergelist_file" "$specifier" & mypid=$!
		ui_waitonproc_tty $mypid .05 \
		""$INF"Please wait while we get the list of merge requests.$OFF"
	}

	while :; do
		show_mrlist mrs
		[ "$current_mr" == "q" ] && { current_mr= ; return 1; }
		echo ${mrs[@]} | grep -w $current_mr > /dev/null 2>&1

		if [ $? -eq 0 ]; then
			get_merge_request_patches "$current_mr"
			[ $? -eq 0 ] && break || continue
		fi

		echo -e "$STA$current_mr$WRN is not in the current list of Merge Requests."
		getuser "Enter a different MR or press $qstr$INF to quit: " current_mr
	done

	return 0
}

# get_merge_request - check-out a specific MR
#
# The entered MR will be checked-out into its own branch for review.
#
# Inputs:
#	$1 - if it exists, then don't get the patches
#
# Globals:
# 	us_commits
# 	current_mr
#
get_merge_request() {
	$ui_b_debug && echo -e "${STA}get_merge_request$OFF"
	local comments_only="$1"
	local stat=0

	getuser "Enter a merge request number or $qstr$INF to quit: " current_mr
	while :; do
		[ "$current_mr" == "q" ] && { current_mr=; return 1; }
		if [ -n "$comments_only" ]; then
			lab mr show --comments $current_mr;
			stat=$?
		else
			get_merge_request_patches "$current_mr" "get_merge_request"
			stat=$?
		fi
		[ $stat -eq 0 ] && break
		[ $stat -lt $mr_norev ] && {
			echo -e "$WRN${mr_errs[$stat]}$INF : $STA$current_mr$OFF"
		} || return $mr_norev

		getuser "Enter a different MR or $qstr$INF to quit: " current_mr
	done

	return 0
}


# get_mrcommits_git - create the global bpcommits file for the given MR
#
# Globals
#      patchcount - number of patches in the patch series
#      bp_commits - file that will contain the backported commits
#
get_mrcommits_git() {
	local mr="$1"		# MR, the Merge Reqest
	local mrbranch="$2"
	local basecmt		# base commit of the MR
	local mmbr		# "main" or "master" for origin

	# mmbr=$(git branch | grep master >& /dev/null && echo master || echo main)
	mmbr=$(grep -B1 'remote = origin' .git/config | head -1 | cut -d'"' -f2)
	lab mr checkout -b $mrbranch $mr 2> /dev/null
	basecmt=$(lab mr show $mr | \
		grep -m 1  "^Labels" | \
		awk -F "Dependencies::" ' { print $2 }' | \
		cut -d',' -f1 | xargs)

	[ -n "$basecmt" ] && echo -e "\nbasecmt: $basecmt"

	if [ -z "$basecmt" ] || [ "$basecmt" == "OK" ]; then
		patchcount=$(lab mr show -p $mr | grep '^Author:' | wc -l)
		# patchcount=$(mrpatcount.py $gl_projid $mr)
	else
		patchcount=$(git rev-list --count $basecmt..HEAD)
	fi

	echo -e "\npatchcount: $patchcount"

	git log --reverse -p HEAD~$patchcount.. | grep  -i ^commit | cut -d' ' -f2 > $bp_commits
	git checkout -q $mmbr 2> /dev/null
	git branch -q -D $mrbranch 2> /dev/null
}

# get_mrcommits_cki - create the global bpcommits file for the given MR
#
# Globals
#      patchcount - number of patches in the patch series
#      bp_commits - file that will contain the backported commits
#
# Other ways to extract patchcount:
#
#   lab mr show -p 621 | grep '^Author:' | grep 'redhat\.com' | wc -l
#
get_mrcommits_cki() {
	local mr="$1"	# MR, the Merge Reqest
	local mrbranch="$2"
	local basecmt	# base commit of the MR
	local mmbr	# "main" or "master" for origin

	# mmbr=$(git branch | grep master >& /dev/null && echo master || echo main)
	mmbr=$(grep -B1 'remote = origin' .git/config | head -1 | cut -d'"' -f2)
	patchcount=$(lab mr show --comments $mr \
		| grep 'Total number of commits analyzed' \
		| tail -1 \
		| cut -d'*' -f3)

	[ -z "$patchcount" ] && get_mrcommits_git $mr "$mrbranch"

	lab mr checkout -b $mrbranch $mr 2> /dev/null
	git log --reverse -p HEAD~$patchcount.. | grep  -i ^commit | cut -d' ' -f2 > $bp_commits
	git checkout -q -f $mmbr
	git branch -q -D $mrbranch
}

# get_mrcommits_pat - create the global bpcommits file for the given MR
#
# Globals
#      patchcount - number of patches in the patch series
#      bp_commits - file that will contain the backported commits
#
get_mrcommits_pat() {
	local mr="$1"
	local mrbranch="$2"
	local mmbr	# "main" or "master" for origin

	mmbr=$(grep -B1 'remote = origin' .git/config | head -1 | cut -d'"' -f2)
	patchcount=$(lab mr show -p $mr | grep '^Author:' | wc -l)

	lab mr checkout -b $mrbranch $mr 2> /dev/null
	git log --reverse -p HEAD~$patchcount.. | grep  -i ^commit | cut -d' ' -f2 > $bp_commits
	git checkout -q -f $mmbr
	git branch -q -D $mrbranch
}

# get_mrcommits_pyapi - create the global bpcommits file for the given MR
#
# Globals
#      patchcount - number of patches in the patch series
#      bp_commits - file that will contain the backported commits
#      gl_projid  - gitlab project ID
#
get_mrcommits_pyapi() {
	local mr="$1"
	local mrbranch="$2"
	local mmbr	# "main" or "master" for origin

	mmbr=$(grep -B1 'remote = origin' .git/config | head -1 | cut -d'"' -f2)
	patchcount=$(mrpatcount.py $gl_projid $mr)

	lab mr checkout -b $mrbranch $mr 2> /dev/null
	git log --reverse -p HEAD~$patchcount.. | grep  -i ^commit | cut -d' ' -f2 > $bp_commits
	git checkout -q -f $mmbr
	git branch -q -D $mrbranch
}

# get_merge_request_patches - extract the patches from a merge request
#
# Inputs:
# 	$1 - MR ID number
#
# Returns
#	0 - after extracting patches from the MR
#	1 - if user does not want to get the patches
#
# Globals:
#	b_mrflag
# 	b_rename_infiles
#	b_fmt_upstream
#	b_reviewed
#	b_acked
#	b_nacked
#	prj_applymode
#	prj_b_fmt_upstream
#	prj_b_rename_infiles
#	current_mr
# 	valpatchlist
#	bp_commits
#	indir
#	missing_fixes
#
get_merge_request_patches() {
	$ui_b_debug && echo -e "${STA}get_merge_request_patches$OFF"
	local mr="$1"
	local b_yes=false
	local mypid
	local stat
	local patches=$(ls $indir/*.patch 2>/dev/null)
	local mrcomments=/dev/shm/mrcomments.log
	local ackcount=
	local brname=
	local stridx
	local idx=0

	current_mr=$mr

	b_mrflag=true
	b_reviewed=false
	b_acked=false
	b_nacked=false
	b_fmt_upstream=true
	b_rename_infiles=false
	b_already_acked=false
	b_has_3_acks=false

	applymode=$applymode_off
	set_cfg_item "applymode" $applymode
	set_cfg_item "b_rename_infiles" $b_rename_infiles
	set_cfg_item "b_fmt_upstream" $b_fmt_upstream

	> $missing_fixes
	valpatchlist=

	lab mr show --comments $mr > $mrcomments
	stat=$?
	[ $stat -eq 1 ] && return $mr_inv

	# create a unique branchname based on the 'Branches" in the comment
	#
	brname="$(grep 'Branches:' "$mrcomments" | cut -d' ' -f2)"
	stridx=$(ui_strindex "$brname" "->")
	[ $stridx -eq -1 ] && stridx=${#brname}
	brname="reviewing-${brname:0:$stridx}"

	# If there's already a branch with that name, change it.
	#
	while git branch | grep "$brname"; do
		let ++idx
		brname="$brname-$idx"
	done

	ackcount=$(grep '^Approved By' $mrcomments | cut -d':' -f2- | wc -w)
	less $mrcomments

	grep '^Approved By' $mrcomments | grep $USER
	if [ $? -eq 0 ]; then
		b_already_acked=true
		echo -e "${INF}You have already ACKed MR $STA$mr$INF."
	fi

	if [ $ackcount -ge 3 ]; then
		b_has_3_acks=true
		echo -e "${INF}MR $STA$mr$INF already has 3 ACKs."
	fi

	loop_yn "${MNU}Continue with review? y/n: " b_yes
	$b_yes || return $mr_norev

	if [ -n "$patches" ]; then
		echo -e "${INF}There are already RHEL patch files in $STA$indir$OFF."
		getyn "Do you want to replace them? " b_yes

		if $b_yes; then
			rm -f $indir/* 2>/dev/null
			rm -f $outdir/* 2>/dev/null
		else
			return 0
		fi
	fi

	get_mrcommits_git $mr "$brname" & mypid=$!
	ui_waitonproc_tty $mypid .05 ""$INF"Getting patches from MR $STA$current_mr$OFF"

	git_file2patchset $bp_commits $indir $b_verbose
	stat=$?
	[ $stat -ne 0 ] && return $mr_nop || return 0
}
