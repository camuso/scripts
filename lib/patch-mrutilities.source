#!/bin/bash
#
# lib/patch-mrutilities.source
#
# This source file provides routines common to both patchreview and
# patchdevelop scripts.
#
# The following source files must be included before this one.
#

# Get the directory defaults if they don't already exist
#
[ "$MYDIR" ] || {
	declare MYDIR=
	MYDIR="$(dirname "$(which "$(basename "$0")")")"
}
[ "$MYLIB" ] || {
	declare MYLIB=
	MYLIB="$(cd "$(dirname "${BASH_SOURCE[0]}")" || exit 1; pwd)"
}

[ "$ui_loaded" ] || source "$MYLIB"/ui.source
[ "$patchcommon_loaded" ] || source "$MYLIB"/patch-common.source
[ "$configmanager_loaded" ] || source "$MYLIB"/config-manager.source

patchmrutilities_loaded=true

# Enable extglob for more specific directory actions
#
shopt -s extglob

#######################################
# Global variables
#######################################
declare -i opmode
declare -i opmode_mr=0
declare -i opmode_email=1
declare -i opmode_states=2

declare current_mr=
declare mrcomments=
declare b_mrflag=false
declare b_reviewed=
declare b_acked=
declare b_nacked=
declare mergelist_filter=
declare mergelist_file=
declare gl_projid=24118165	# gitlab project ID
declare origin=			# the principal remote in a git repo

declare -i mr_val=0	# valid mr
declare -i mr_inv=1	# invalid mr
declare -i mr_nop=2	# no patches found
declare -i mr_norev=3	# skip the review
declare -a mr_errs=(
""
"${WRN}Merge Request not found$OFF"
"${WRN}No patches found for Merge Request$OFF"
)

# init_mr - initialize the environment for this
init_mr() {

	# Get the origin of this repo to use in 'lab mr' calls
	origin="$(grep -m1 'remote' .git/config)"
	origin="${origin:8}"
	origin="${origin//[^[:alnum:]]}"

	mergelist_file=$MYDATA/mergelist.log
	mrcomments="$outdir"/mrcomments.log
}

# show_init - display the init menu option
#
# Globals:
# 	current_mr
#
show_init() {
	echo -n "Init to defaults"
	if is_validnumber "$current_mr"; then
		echo -en " and clear MR $STA$current_mr$OFF and its files"
	fi
	echo
}

# show_mrcomments - display ON or OFF depening on mrcomments state
#
# Globals
#     mrcomments
#
show_mrcomments() {
	$b_mrcomments && echo "ON" || echo "OFF"
}


# show_mrfilter - show the merge list filter
#
# Globals
# 	mergelist_filter
#
show_mrfilter() {
	cfg_get_item "mergelist_filter" mergelist_filter
	[ -n "$mergelist_filter" ] && \
		echo -en "${INF}String:$OFF $STA$mergelist_filter$OFF"
}

# grep_mrlist() - grep or filter the mr list
#
# Globals:
# 	mergelist_filter
#
grep_mrlist() {
	$b_mrflag || return
	local promptstr=

	promptstr=$(
cat <<EOF
Enter grep string or just press$STA Enter$INF to clear it and return: 
EOF
)
	getuser "$promptstr" mergelist_filter
	set_cfg_item "mergelist_filter" "$mergelist_filter"
	[ -n "$mergelist_filter" ] || return 1
	select_merge_request
	return $?
}

# change_opmode - change the operating mode of the script
#
# Certain global variables need to be flipped for Merge Request
# and Email operation modes.
#
# Globals
# 	opmode
# 	opmode_mr
# 	opmode_email
# 	opmode_states
# 	cmpmode
# 	cmpmode_batch
# 	applymode
# 	applymode_off
# 	applymode_norm
# 	b_rename_files
# 	b_fmt_upstream
#
change_opmode() {
	ui_cycle_state opmode $opmode_states
	set_cfg_item "opmode" "$opmode"

	case $opmode in
	"$opmode_mr"    ) b_mrflag=true
			  b_rename_files=false
			  b_fmt_upstream=true
			  cmpmode=$cmpmode_batch
			  applymode=$applymode_off
			  ;;
	"$opmode_email" ) b_mrflag=false
			  b_rename_files=false
			  b_fmt_upstream=true
			  cmpmode=$cmpmode_batch
			  applymode=$applymode_norm
			;;
	esac
}

# show_opmode - display whether we're in Merge Request or Email Mode
#
# Globals:
# 	opmode
# 	opmode_mr
# 	opmode_email
# 	prj_opmode
#
show_opmode() {
	case $opmode in
		"$opmode_mr"    ) echo "Merge Request Mode" ;;
		"$opmode_email" ) echo "Email Patch Mode" ;;
	esac
}

# show_mrstatus- display the current mr and its status
#
# Globals:
# 	current_mr
# 	b_acked
# 	b_nacked
#
show_mrstatus() {
	local ackstr

	cfg_get_item "current_mr" current_mr

	is_validnumber "$current_mr" || return 1
	cfg_get_item "b_acked" b_acked
	cfg_get_item "b_nacked" b_nacked

	if $b_acked || $b_nacked; then
		if $b_acked; then
			ackstr="${STA}ACKED$OFF"
		else
			ackstr="${WRN}NACKED$OFF"
		fi
	else
		ackstr=
	fi

	echo -e "\n    Merge Request            : $STA$current_mr $ackstr"

	[ -s "$missing_fixes" ] && {
		grep -q 'WARNING:' "$missing_fixes" && echo -e \
		"   $WRN There are missing fixes listed in $STA$missing_fixes$OFF"
		show_missing_fixes
	}
}

# display_acknack_menu - ask the user how they want to respond to the MR results
#
# Globals
# 	b_mrflag
# 	current_mr
# 	b_reviewed
# 	b_acked
# 	b_nacked
#
display_acknack_menu() {
	$b_mrflag || return 1
	local cmt=
	local _dak_response
	local acknackmenu

	acknackmenu=$(
cat <<EOF

   $MNU For MR $STA$current_mr$MNU, you want to ...
   $MNU a$STA  ACK$OFF
   $MNU A$STA  ACK$OFF with comment
   $MNU n$WRN  NACK$OFF
   $MNU N$WRN  NACK$OFF with comment
   $MNU c$OFF  Comment only
   $MNU v$OFF  View description and comments for $STA$current_mr
   $MNU M$OFF  Review another Merge Request
   $MNU m$OFF  Display a list of Merge Requests
   $MNU q$OFF  Quit and return to main menu$OFF
EOF
)
	while :; do
		echo -e "$acknackmenu"

		if $b_reviewed && [[ $b_acked || $b_nacked ]]; then
			if $b_acked; then
				actstr="${STA}ACKED$OFF"
			else
				actstr="${WRN}NACKED$OFF";
			fi
			echo -e "$INF   Merge Request: $STA$current_mr $INF" \
			        "has already been ${actstr}\n"
		fi

		promptgetchar "$MNU   Enter one of the above: $OFF" _dak_response
		[[ qnaNAcvMm =~ $_dak_response ]] && break
	done

	eval "$1"="$_dak_response"
}

get_acknack() {
	cfg_get_item "current_mr" current_mr
	cfg_get_item "b_acked" b_acked
	cfg_get_item "b_nacked" b_nacked
	cfg_get_item "b_reviewed" b_reviewed
}

set_acknack() {
	cfg_set_item "b_acked" "$b_acked"
	cfg_set_item "b_nacked" "$b_nacked"
	cfg_set_item "b_reviewed" "$b_reviewed"
}

query_acknack() {
	local choice
	local actstr=
	local wcomment=
	local querystring=

	while :;do
		actstr=
		wcomment=

		get_acknack
		display_acknack_menu choice

		case "$choice" in
			q ) return 0
			    ;;
			A ) cmt="--with-comment --force-linebreak "
			    wcomment="$INF with comments"
			    ;&
			a ) b_acked=true
			    b_nacked=false
			    b_reviewed=true
			    actstr="${STA}ACK$OFF"
			    set_acknack
			    ;;
			N ) cmt="--with-comment --force-linebreak "
			    wcomment="$INF with comments"
			    ;&
			n ) b_nacked=true
			    b_acked=false
			    b_reviewed=true
			    actstr="${WRN}NACK$OFF"
			    set_acknack
			    ;;
			c ) echo -e "$INF   Comment on $STA$current_mr$INF ...$OFF"
			    lab mr note "$origin" "$current_mr" --force-linebreak
			    continue
			    ;;
			v ) get_merge_request -c
			    continue
			    ;;
			M ) if get_merge_request -u; then return $rc_run; \
			    else continue; fi
			    ;;
			m ) if select_merge_request; then return $rc_run; \
			    else continue; fi
			    ;;
		esac

		querystring="$INF   Are you sure you want to $actstr$INF Merge "
		querystring+="Request $STA$current_mr$wcomment$MNU (y/n)? $OFF"

		if loop_yn "$querystring"; then
			$b_acked && lab mr approve "$origin" $cmt "$current_mr"
			$b_nacked && lab mr unapprove "$origin" $cmt "$current_mr"
		fi

		continue
	done

	return 0
}

# call_lab_mr_list - worker function to create the mr list
#
# Inputs:
# 	$1 - outfile that will contain the list
#
call_lab_mr_list() {
	local outfile="$1"
	local specifier="$2"
	local srtcmd="sort -t ! -k2 -h"
	local labcmd="lab mr list $origin $specifier"

	$labcmd | $srtcmd > "$outfile"
}

# refresh_mergelist - refresh the file containing the list of merge requests
#
# Globals:
# 	$mergelist_file
#
refresh_mergelist() {
	local stat
	rm -f "$mergelist_file"
	select_merge_request
	stat=$?
	return $stat
}

# show_comments - display the view comments menu option
#
# Globals
# 	current_mr
#
show_comments() {
	if is_validnumber "$current_mr"; then
		echo "View comments for MR $STA$current_mr$OFF"
	else
		echo "View comments for a specific MR"
	fi
}

# get_mrlist_specifier - which mr list specifier does the user want
#
# Outputs
#     $1 - specifier string is returned in $1
#
get_mrlist_specifier() {
	local -n gmr_spec="$1"
	local spec=
	local mnu=
	local author=
	local targbranch=
	local specmenu=

	specmenu=$(
cat <<EOF
$MNU
     ${UND}Specify the MR list content   $OFF
 $MNU a$OFF  All MRs on the project
 $MNU o$OFF  Open MRs
 $MNU r$OFF  Ready MRs
 $MNU d$OFF  Draft MRs
 $MNU n$OFF  No-conflicts, can be merged
 $MNU c$OFF  Conflicts, cannot be merged
 $MNU m$OFF  Merged MRs
 $MNU A$OFF  Author of MRs
 $MNU C$OFF  Closed MRs
 $MNU t$OFF  Specify a Target Branch
 $MNU q$OFF  Quit and return to main menu
\0
EOF
)
	echo -e "$specmenu"

	while :; do
		promptgetchar "${MNU}Select a MR list specifier: $OFF" mnu
		case $mnu in
			q ) return 1 ;;
			a ) spec="--state all --all";  break ;;
			o ) spec="--state opened --all"; break ;;
			d ) spec="--draft --all"; break ;;
			r ) spec="--ready --all"; break ;;
			n ) spec="--no-conflicts --all"; break ;;
			c ) spec="--conflicts --all"; break ;;
			m ) spec="--state merged --all"; break ;;
			C ) spec="--state closed --all"; break ;;
			A ) getuser "Enter the Author's name: " author
			    spec="--state all --all --author $author"
			    break
			    ;;
			t ) getuser "Enter Target Branch: " targbranch
			    spec="--state all --all -t $targbranch"
			    break
			    ;;
		esac
	done

	gmr_spec="$spec"
	return 0
}

# show_mrlist - display the list of MRs obtained by call_lab_mr_list
#
#  Globals
#	current_mr - indirectly by call to get_new_mr
#	mergelist_file
#
show_mrlist() {
	local -n mrarray=$1	# pass array by reference
	local mr=
	local mrnum=
	local mrsub=

	while read -r mr; do
		[[ $mr == *$mergelist_filter* ]] || continue
		mr="${mr:1}"
		mrnum=$(echo "$mr" | cut -d' ' -f1)
		mrsub=$(echo "$mr" | cut -d' ' -f2-)
		mrarray+=("$mrnum")
		echo -e " $MNU$mrnum$OFF $mrsub"
	done < "$mergelist_file"
}

# select_merge_request - select a MR from a list
#
#  Presents a list of Merge Requests for the user to select one.
#  The selected merge request is checked-out into its own branch
#  for review.
#
# Globals
# 	mergelist_file
# 	current_mr
#
# Inputs: none
#
select_merge_request() {
	local mrs=()
	local mr=
	local mrnum=
	local mrsub=
	local mypid=
	local specifier=
	local response

	[ -s "$mergelist_file" ] || {
		get_mrlist_specifier specifier || return 1
		call_lab_mr_list "$mergelist_file" "$specifier" & mypid=$!
		ui_waitonproc_tty $mypid .05 \
		"${INF}Please wait while we get the list of merge requests.$OFF"
	}

	while :; do
		show_mrlist mrs
		get_new_mr || return 1

		if echo "${mrs[@]}" | grep -q -w "$current_mr"; then

			if get_merge_request_patches "$current_mr"; then
				break
			else
				continue
			fi
		fi

		echo -e "$STA$current_mr$WRN is not in the current list of Merge Requests."
	done

	return 0
}

# update_current_mr
#
#  If the provided mr is a valid number, update the global mr and
#  save it with cfg_set_item. With a new MR, alll associasted
#  booleans will also be reinitialized.
#
#  GLOBALS
#    current_mr:
#    b_reviewed
#    b_acked
#    b_nacked
#
update_current_mr() {
	local cmr="$1"

	if is_validnumber "$cmr"; then
		((cmr == current_mr)) && return 1
		current_mr="$cmr"
		b_reviewed=false
		b_acked=false
		b_nacked=false
		cfg_set_item "current_mr" "$current_mr"
		cfg_set_item "b_reviewed" "$b_reviewed"
		cfg_set_item "b_acked" "$b_acked"
		cfg_set_item "b_nacked" "$b_nacked"
		return 0
	fi
	return 1
}

get_new_mr() {
	local querystr
	local response

	querystr="Enter a Merge Request or press ${MNU}ENTER$INF "

	if is_validnumber "$current_mr"; then
		querystr+="to keep$STA $current_mr$INF : "
	else
		querystr+="to return : "
	fi

	getuser "$querystr" response
	update_current_mr "$response" || return 1

	return 0
}

# is_valid_mrcomments
#
# See if the comments file is valid and is for the current_mr
#
# GLOBALS
#   mrcomments
#   current_mr
#
is_valid_mrcomments() {
	local line
	local mr

	if [ -f "$mrcomments" ] && [ -s "$mrcomments" ]; then
		line="$(ui_readline_raw 1 "$mrcomments")"
		mr="$(cut -d' ' -f1 <<< "$line")"
		mr="${mr:1}"
		((mr == current_mr)) && return 0
	fi
	return 1
}

# get_merge_request - check-out a specific MR
#
# The entered MR will be checked-out into its own branch for review.
#
# Inputs:
#	$1 - if it exists, then don't get the patches
#
# Globals:
# 	us_commits
# 	current_mr
#
get_merge_request() {
	$ui_b_debug && echo -e "${STA}get_merge_request$OFF"
	local b_comments=false
	local b_newmr=false
	local stat=0

	while [ "${1:0:1}" == "-" ]; do
		opt="$1"
		case $opt in
			"-c" ) b_comments=true; shift 1;;
			"-u" ) b_newmr=true; shift 1;;
		esac
	done

	$b_newmr && { get_new_mr || return 1; }

	while :; do
		if $b_comments; then
			is_valid_mrcomments || {
				lab mr show "$origin" "$current_mr" --comments > "$mrcomments"
			}

			echo -e "$INF   View comments for $STA$current_mr$INF ...$OFF"
			less "$mrcomments"
			return 0
		fi

		if get_merge_request_patches "$current_mr"; then
			return 0
		else
			stat=$?
			((stat < mr_norev)) &&
				echo -e "$WRN${mr_errs[$stat]}$INF : $STA$current_mr$OFF"
			return $stat
		fi
	done

	return 0
}

# get_mrcommits_labmr
#
# Arguments
# 	$1 - the MR
# 	$2 - baseline commit from which to extract the commits from this MR
#
# Globals
#      origin - the baseline commit of the main branch
#      patchcount - number of patches in the patch series
#      bp_commits - file that will contain the backported commits
#
get_mrcommits_labmr() {
	local mr=$1
	local bascmt=$2
	local lcnt
	local tfil=/dev/shm/tempcommitsfile

	lab mr show "$mr" -p --reverse | grep '^commit ' | cut -d ' ' -f2 > "$bp_commits"

	# If there is a base commit for a dependency, then it won't be the
	# same as the origin commit, so remove its patches from the commits
	# file.
	[ "$bascmt" == "$origin" ] || {
		lcnt=$(grep -n -m1 "$bascmt" "$bp_commits" | cut -d':' -f1)
		[ -n "$lcnt" ] && {
			head -$((lcnt - 1)) "$bp_commits" > "$tfil"
			mv -f "$tfil" "$bp_commits"
			rm -f "$tfil"
		}
	}

	patchcount=$(wc -l < "$bp_commits")
	echo -e "\npatchcount: $patchcount"
}

# get_merge_request_patches - extract the patches from a merge request
#
# Inputs:
# 	$1 - MR ID number
#
# Returns
#	0 - after extracting patches from the MR
#	1 - if user does not want to get the patches
#
# Globals:
#       USER - username, global to the login session
#	b_mrflag
# 	b_rename_infiles
#	b_fmt_upstream
#	current_mr
# 	valpatchlist
#	bp_commits
#	indir
#	missing_fixes
#	mrcomments
#
get_merge_request_patches() {
	$ui_b_debug && echo -e "${STA}get_merge_request_patches$OFF"
	local mr="$1"
	local mypid
	local stat
	local patches=
	local ackcount=
	local bascmt=
	local basmr=
	local basary=()
	local b_already_acked=false
	local b_has_3_acks=false

	patches=$(ls "$indir"/*.patch 2>/dev/null)

	# Init global bools
	b_mrflag=true
	b_fmt_upstream=true
	b_rename_infiles=false

	applymode=$applymode_off
	set_cfg_item "applymode" $applymode
	set_cfg_item "b_rename_infiles" $b_rename_infiles
	set_cfg_item "b_fmt_upstream" $b_fmt_upstream

	: > "$missing_fixes"
	valpatchlist=
	lab mr show "$origin" "$mr" --comments > "$mrcomments" & mypid=$!
	ui_waitonproc_tty $mypid .05 "${INF}Getting comments from MR $STA$current_mr$OFF" \
		|| return $mr_inv

	# If there's a dependency, find the base commit for it.
	#
	if basmr="$(grep -i -A3 'Depends tags:' "$mrcomments")"; then
		basmr="$(echo "$basmr" | tail -1)"
		ui_strtok "$basmr" "|: " basary
		bascmt="${basary[6]}"
		echo -e "${INF}Dependency detected:$INF MR${STA}"\
			 "$(echo -en "${basary[1]}" | cut -d'!' -f2)"\
		         "${INF}commit $STA${basary[6]}$OFF"
	else
		bascmt="$origin"
	fi

	ackcount=$(grep '^Approved By' "$mrcomments" | cut -d':' -f2- | wc -w)
	less "$mrcomments"

	if grep '^Approved By' "$mrcomments" | grep "$USER"; then
		b_already_acked=true
		echo -e "${INF}You have already ACKed MR $STA$mr$INF."
	fi

	if ((ackcount >= 3)); then
		b_has_3_acks=true
		echo -e "${INF}MR $STA$mr$INF already has 3 ACKs."
	fi

	loop_yn "${MNU}Continue with review? y/n: " || return $mr_norev

	if [ -n "$patches" ]; then
		echo -e "${INF}There are already RHEL patch files in $STA$indir$OFF."

		if getyn "Do you want to replace them? "; then
			rm -f "$indir"/* 2>/dev/null
			rm -f "$outdir"/*.patch 2>/dev/null
		else
			return $nr_norev
		fi
	fi

	get_mrcommits_labmr "$mr" "$bascmt" & mypid=$!
	ui_waitonproc_tty $mypid .05 "${INF}Getting patches from MR $STA$current_mr$OFF"

	git_file2patchset "$bp_commits" "$indir" $b_verbose || { echo "stat $?"; return $mr_nop; }
	return 0
}
