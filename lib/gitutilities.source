#!/bin/bash
#
# gitutilities.src
#
# NOTE: ~/bin/ui.source must be included before this file.
#

declare gitutilities_loaded=true
declare scratchdir=/dev/shm
declare scratchfile=$scratchdir/scratch

[ "$ui_loaded" ]         || source $MYLIB/ui.source
[ "$patchutils_loaded" ] || source $MYLIB/patch-utils.source

# git_commit2patchset
# 	creates a patchset from contiguous commits starting with the most
#	recent.
#
# $1 - number of commits to format
# $2 - destination directory for the patch set.
# $3 - optional commit to start from (most recent of the set)
#
function git_commit2patchset {
	local patchcount=$1
	local destdir="$2"
	local commit="$3"

	git format-patch --no-renames -s -n$patchcount "$commit" -o "$destdir"
	return 0
}

# git_commit2patch
# 	creates one patch from a given commit in a series, using the
# 	number in the series of the commit in the patch as a part of
# 	its name.
#
# $1 - number of the commit in the series
# $2 - commit hash
# $3 - destination directory
#
function git_commit2patch {
	local index=$1
	local commit=$2
	local destdir=$3
	local pfx=$(printf "%04d" $index)

	if [ ${#commitnum} -gt 1 ]; then
		git format-patch -1 -k --no-renames --start-number $index $commit -o $destdir

		# If we could not format the patch, then create an empty
		# patch with the bad patch number in it.
		#
		[ $? -eq 0 ] || echo "invalid commit: $commit" > $destdir/"$pfx-inv.patch"
	else
		echo -n "" > $destdir/"$pfx-no.patch"
	fi
}

# git_file2patchset
# 	creates a patchset from a file containing a list of discontiguous
#	commits.
#
# The commits list must be organized so that the most recent commit is the
# last line in the file and the oldest commit is at the top of the file.
# git_comments2commitsfile() and git_mailhead2commitsfile() can be used to
# generate such a file.
#
# Generated patches will be suitable for applying with "git am" or for
# comparing to other patches.
#
# $1 - path of file containing the list of commits.
# $2 - destination directory for the patch set.
# $3 - optional verbose true or false
#
function git_file2patchset {
	$ui_b_debug && echo -e "${STA}git_file2patchset$OFF"
	local commitsfile="$1"
	local destdir="$2"
	[ $# -eq 3 ] && b_verbose=$3 || b_verbose=true
	local patchcount=$(cat "$commitsfile" | wc -l)
	local commit=""
	local commitnum=0
	local index=1
	local pfx=""
	local pad=
	local remotes=()
	local outline
	local banner=\
""$INF"\
Formatting $STA$patchcount$INF patches from $STA$commitsfile$INF into \
$STA$destdir$OFF"

	local notfound=\
"was not found in any of the upstream repos in your .git/config file"
	local escnt=$(((${#STA} * 3) +(${#INF} * 3) + ${#OFF}))


	if [ $patchcount -eq 0 ]; then
		echo
		echo -e ""$WRN"File "$STA""$commitsfile""$WRN" is empty.$OFF"
		echo
		[ $# -eq 3 ] && eval $3=$patchcount
		return 1
	fi

	pad=$(ui_putnchar '=' $(( ${#banner} - $escnt )))
	echo -e "$banner\n$INF$pad$OFF"
	$verbose || echo

	while read line; do
		[ "${line:0:1}" == "#" ] && continue
		commit=$(echo $line | cut -d' ' -f1 | tr -dc "[[:xdigit:]]")
		commitnum=$(echo $commit | tr -s 0)
		pfx=$(printf "%04d" $index)

		if [[ 16#${commitnum} -eq 0 ]]; then
			outline="No upstream commit detected for patch $index."
			echo "$outline" > $destdir/"$pfx-nocommit.patch"
		else
			if git show $commit > /dev/null 2>&1; then
				outline=$(git format-patch -1 -k \
					--start-number $index $commit -o $destdir)
			else
				# If we could not format the patch, then create an empty
				# patch with the bad patch number in it.
				#
				create_remote_array remotes
				echo "Commit $commit" > $destdir/"$pfx-notfound.patch"
				echo "$notfound" >> $destdir/"$pfx-notfound.patch"
				echo >> $destdir/"$pfx-notfound.patch"
				show_remotes >> $destdir/"$pfx-notfound.patch"
				outline="No upstream found for $commit"
			fi
		fi

		$b_verbose && echo $outline || {
			ui_clearline
			echo -n $outline
		}

		let index++
	done < $commitsfile

	$b_verbose || echo
	return 0
}

# git_setsubjectprefix - set the subject prefix in .git/config
#
git_setsubjectprefix() {
	local newpfx="$(git config format.subjectprefix)"

	echo -e \
"Just press $BLD\0ENTER$OFF to leave the current subject prefix unchanged."
	getuser "New subject prefix: " newpfx
	[ "$newpfx" ] || return
	git config format.subjectprefix "$newpfx"
}

# git_getsubjectprefix - determine the subject prefix stored in .git/config
#
# $1 - query, ask user if he wants to change the prefix
#
function git_getsubjectprefix {
	local newpfx="$(git config format.subjectprefix)"
	local b_ans=true
	local b_query=false
	[ "$1" == "query" ] && b_query=true
	while true; do
		echo -e "Current subject prefix: "$attr_bold""$newpfx""$attr_OFF""
		$b_query && getyn "Change subject prefix?" b_ans
		if $b_ans; then
			getuser "New prefix: " newpfx
			git config format.subjectprefix "$newpfx"
			$b_query || break
		else
			break
		fi
	done
}

# git_repo2commitsfile
# 	create a file containing a list of commits from consecutive commits
#	in a git repo.
#
# Unless the user supplies an option, only the short form hashes will be
# written to the file.
#
# $1 - path to destination file
# $2 - Number of commits to format, before and including the most recent.
# $3 - Most recent commit in the set. Default is top of the tree, if empty.
# $4 - optional argument - "long" for long hash, short is the default.
#
# returns - 128 if $2 is an invalid commit.
#         -   1 if $3 is an invalid option
#         -   0 if all is well.
#
function git_repo2commitsfile {
	local file=$1
	local count=$2
	local lastcommit=$3
	local hashfmt_option=$4
	local hashfmt="short"

	if [ "$hashfmt_option" ]; then
		[ "$hashfmt_option" == "long" ] && hashfmt="long"
	fi

	[ "$hashfmt" == "short" ] && git log --reverse -n$2 --oneline $3 > $file
	[ "$hashfmt" == "long" ] && git log --reverse -n$2 --pretty=oneline $3 > $file

	return $?
}

# git_excisecommit - excise the commit hash from the line
#
# If there appears to be more than one hash on the line, just take the
# first one.
#
# $1 - the line to be grep'd
# $2 - the size of the hash (40 or 7,40)
#
function git_excisecommit {
	local line="$1"
	local hashsize="$2"

	echo "$line" | egrep -o "\b[0-9a-f]{"$hashsize"}\b" | head -1
}

# extract_subject - get the subject from the subject line of the patch
#
# The subject line is expected to have the following format.
#
# Subject: [yada-yada] some explicatory text
#
# Even without the square brackets in the subject line, this function will
# return the correct subject string.
#
# $1 - file containing the subject line
#
extract_subject() {
	local file="$1"
	local subject=$(grep -n -m1 'Subject: ' $file)
	local subline=$(echo "$subject" | cut -d':' -f1)
	local subext=
	local pos

	# Remove the line number from the grep of the subject
	subject=$(echo "$subject" | cut -d':' -f2-)

	# Get the line after the subject line, in case it was too long
	# for the mail client to fit on the same line. If the line does
	# not begin with a white space character, then it is not a part
	# of the subject line, so zero it.
	#
	subext=$(ui_readline $((subline + 1)) $file)
	[[ "${subext:0:1}" =~ [[:space:]] ]] || subext=

	echo "$subject""$subext"
}

# validate_commit - check the hash for a repo and congruent subject
#
# GLOBALS
# 	valfuzz - commit validation fuzz level
#
# ARGUMENTS
# $1 - commit hash from the submitted patch
# $2 - subject line from the submitted patch
#
# OPTIONS
#  -f - fuzz level, 0..3
#  -u - upstream directory
#
# RETURNS
# 	0   - if match is determined
# 	1   - if not sufficiently matched
#	128 - if invalid commit (from 'git log')
#
validate_commit() {
	local commit
	local rhsubj
	local valfuzz=1   # default fuzz level is case-insensitive
	local ussubj=
	local ussubary=()
	local rhsubary=()
	local delimiters=" "
	local stat
	local index
	local ustoks
	local rhtoks
	local rhindex
	local b_nocase=false
	local updir=

	# Parse the options
	while [ "${1:0:1}" == "-" ]; do
		opt="$1"
		case $opt in
			"-f" ) valfuzz="$2"; shift 2;;
			"-u" ) updir="$2"; shift 2;;
		esac
	done

	# get the command line arguments
	commit="$1"
	rhsubj="$2"

	# Get the fuzz level
	# 0 - upstream and RHEL git log summaries must be identical
	# 1 - case insensitive
	# 2 - ignore commas
	# 3 - ignore all punctuation chars
	#
	case $valfuzz in
		0 ) delimiters=" "
		    ;;
		1 ) b_nocase=true
		    ;;
		2 ) delimiters=" ,"
		    ;;
		3 ) delimiters=" ""$punctset"
		    ;;
	esac

	# Get the upstream commit subj line or return the error.
	# Send error output to /dev/null
	[ -n "$updir" ] && cd $updir
	ussubj=$(git log --oneline -n1 $commit 2> /dev/null)
	stat=$?
	[ -n "$updir" ] && cd - > /dev/null 2>&1

	[ $stat -eq 0 ] || return $stat

	# strip the leading commit hash off the 'git log --oneline'
	ussubj=$(echo $ussubj | cut -d' ' -f2-)

	# Tokenize the subject strings.
	ui_strtok "$ussubj" "$delimiters" ussubary
	ui_strtok "$rhsubj" "$delimiters" rhsubary

	# strip out extra space chars and nulls by redeclaring the array
	# contents without double quotes.
	ussubary=( ${ussubary[@]} )
	rhsubary=( ${rhsubary[@]} )

	# Get the number of elements in each array.
	ustoks=${#ussubary[@]}
	rhtoks=${#rhsubary[@]}

#echo -e "delimiters: \"$delimiters\""
#echo "rhsubary: "${rhsubary[@]}""
#echo "ussubary: "${ussubary[@]}""
#echo "rhtoks: ${#rhsubary[@]}"
#echo "ustoks: ${#ussubary[@]}"
#echo
	# Case insensitive match, because people are not especially careful
	$b_nocase && shopt -s nocasematch

	# Find the first instance in the rhsubary of the second token in the
	# ussubary. If we can't find any, return 1.
	# Start with the second token (index = 1), because the first one is
	# subject to change by the RHEL submitter.
	#
#echo "ussubary[1]: |${ussubary[1]}|"
	for ((index = 1; index < $rhtoks; ++index)); do
#echo "rhsubary[i]: |${rhsubary[$index]}|[$index]"
		[ "${rhsubary[$index]}" == "${ussubary[1]}" ] && break
	done

	# If we loop through the whole rhsubary without finding a match,
	# return 1.
	#
	[ $index -gt $rhtoks ] && return 1
	rhtoks=$((rhtoks - index))
	rhindex=$((index - 1))
#set -x
	# Now see if the arrays are the same from here out.
	for ((index = 1; index < $rhtoks; ++index)); do
#echo "rh tok: ${rhsubary[$rhindex + $index]}"
#echo "us tok: ${ussubary[$udex]}"

		[[ "${rhsubary[$rhindex + $index]}" == "${ussubary[$index]}" ]] || break
	done
#set +x
#echo "index: $index  rhtoks: $rhtoks"

	# Restore case sensitivity.
	$b_nocase && shopt -u nocasematch

	[ $index -eq $rhtoks ] && return 0 || return 1
}

# git_comment2commitsfile
#	Create a file containing a list of commits from taken from the "commit"
#	line in each patch in a directory. The patches in the directory are
#	backported patches with upstream commits identified in the backported
#	patch commit log.
#
# NOTE: The only files that will be parsed are those that have ".patch" at the
#	end of their names.
#
# $1 - directory containing the backported patches
# $2 - filename, including path, of the commits file.
# $3 - number of chararcters in the hashes
# $4 - patch validation fuzz level (optional)
#
function git_comment2commitsfile {
	local srcdir=
	local commitsfile=
	local hashsize=40
	local valfuzz=1
	local srcfile=
	local line=
	local index=1
	local jdex
	local patchlist=
	local cmtindex=1
	local linenumber=0
	local commitarray
	local sorted
	local _40digit=true
	local valpatchlist
	local filecount
	local subject
	local commit
	local stat=0
	local banner=
	local b_found_vcmt=false	# valid commit subject flag
	local savedIFS="$IFS"
	local b_quiet=false
	local opt
	local remdir=
	local b_invcmt=false		# if git log status=128 cmt is invalid

	while [ -n "$1" ]; do
		opt="$1"
		case $opt in
			"-i" ) srcdir="$2"; shift 2;;
			"-o" ) commitsfile="$2"; shift 2;;
			"-h" ) hashsize=$2; shift 2;;
			"-f" ) valfuzz=$2; shift 2;;
			"-r" ) remdir="$2"; shift 2;;
			"-q" ) b_quiet=true; shift 1;;
		esac
	done

	[ -d $srcdir ] || return $ui_err_invdir
	[ -f $commitsfile ] || return $ui_err_invfile

	> $commitsfile
	> $scratchfile

	patchlist=$(ls $srcdir/*.patch | sort -V)
	patchtotal=$(wc -w <<< "$patchlist")
	create_patchlist "$patchlist" valpatchlist
	filecount=$( wc -w <<< "$valpatchlist")

	banner="$patchtotal Patches in $indir"
	pad=$(ui_putnchar '=' ${#banner})
	echo -e "$INF$banner\n$pad$OFF"

	for srcfile in $valpatchlist; do

		# If verbose is off, then just print each file on one
		# line.
		# Else, print every file on a newline.
		$b_quiet && {
			ui_clearline
			echo -n $srcfile
		} || echo $srcfile

		b_found_vcmt=false
		subject=$(extract_subject $srcfile)

		linenumber=0
		commitarray=()
		sorted=()

		# The default number of digits for a commit hash is 40.
		#
		# Gather anything that looks like a commit into the scratchfile
		#
		egrep '(commit|cherry)' $srcfile \
			| egrep "\b[0-9a-f]{$hashsize}\b" > $scratchfile

#cat $scratchfile
		# See if there is a commit we can successfully validate as
		# having a valid subject line to minimize user pain.
		# We only need to find one.
		# If git log returns an invalid commit status (128), then skip
		# it and go to the next one in the RHEL commit log.
		# If none of the commits has a valid subject line, then gather
		# what there are and present them to the user for selection.
		# If there are no valid commits in the RHEL commit log, then
		# we won't be able to format an upstream commit corresponding
		# to this patch.
		#
		cmtindex=0
		while read line; do
#echo "line: \"$line\""
			b_found_vcmt=false
			stat=0

			# Skip over lines identifying reverted commits
			# Use double brackets and NO quotes.
			([[ $line == *revert* ]] || [[ $line == *Revert* ]]) && continue

			commit=$(git_excisecommit "$line" "$hashsize")
#echo "commit: $commit"
			validate_commit -f $valfuzz -u $remdir $commit "$subject"
			stat=$?
#echo "stat: $stat"
#set -x
			# Return status of 128 means that the call to git log in
			# validate_commit could not find the commit upstream.
			# 0 means we found the commit, so we can break out of this loop.
			# Anything else means that the user is going to have to sort
			# it out, so put it in the commitarray to present to the screen.
			case $stat in
				128 )	continue;;
				0   )	b_found_vcmt=true; break;;
				*   )   b_found_vcmt=false; continue;;
			esac

			commitarray[$cmtindex]=$commit;
			let cmtindex++

		done < $scratchfile
#set +x
		# If we didn't find a commit we could validate, then present
		# whatever commits we did find to the user to select.
		#
		$b_found_vcmt || {

			# Sort the commit array using the -u unique switch to wring
			# out duplicates.
			#
			IFS=$'\n' sorted=($(sort -u <<< "${commitarray[*]}"))
			IFS="$savedIFS"	# restore IFS

			# If we still have more than one valid commit at this point,
			# present them to the user to determine which to use.
			#
			if [ ${#sorted[@]} -gt 1 ]; then

				echo -en "There is more than one commit mentioned in patch"
				echo -e  "$BLD $index $OFF"
				echo -e  "Please choose one of the following."
# set -x
				[ -n "$remdir" ] && cd "$remdir"
				for ((cmtindex=0; cmtindex < ${#sorted[@]}; cmtindex++))
				do
					cmtstr=$(git log --oneline -n1 ${sorted[$cmtindex]})
					printf "%d - $cmtstr\n" $((cmtindex +1))
				done
# set +x
				[ -n "$remdir" ] && cd - > /dev/null 2>&1

				loop_range 1 $cmtindex linenumber
			else
				linenumber=1
			fi

			cmtindex=$((linenumber - 1))
			commit=${sorted[$cmtindex]}
		}

		rm -f $scratchfile

		if [ -n "$commit" ]; then
			echo "$commit $index/$filecount" >> $commitsfile
		else
			# If we didn't get a commit in this srcfile, then
			# indicate that in the commitsfile by printing 40
			# zeroes where the commit number should be.
			#
			printf "%040d $index/$filecount\n" 0 >> $commitsfile
		fi
		let index++
	done
	$b_quiet && echo
	return 0
}

# git_mailhead2commitsfile
#	Create a file containing a list of commits from taken from the "From"
#	line in each git-formatted patch in a directory. The patches were
#	extracted from a mail client, like mutt.
#
# NOTE: The only files that will be parsed are those that have ".patch" at the
#	end of their names.
#
# $1 - directory where the git-formatted patches were extracted
# $2 - filename, including path, of the commits file.
#
function git_mailhead2commitsfile {
	local srcdir="$1"
	local commitsfile="$2"

	cat /dev/null > $commitsfile
	grep "From " $srcdir/*.patch | cut -d' ' -f2 >> $commitsfile
}

function git_invrepomsg {
	echo -e ""$attr_bold""$PWD""$attr_OFF" is not a valid git repo\n"
}

# git_checkrepo
# 	Determines whether the current directory is a valid git repo
#
# returns 0 valid repo, else returns 1
#
# usage:
# 	$(git_checkrepo) || echo "$PWD is not a valid git repo" || exit 1
#
function git_checkrepo {
	[ -d .git ] && return 0 || return 1
}

# git_get_lasttag <tagstr> [path]
#
# Obtains the most recent tag in the current branch and stores it in
# /dev/shm/lasttag, or the optional path submitted in $2 by the caller.
#
# Returns the tag in $1.
#
# Deletes the previously recorded last tagin /dev/shm/lasttag or the
# optional path submitted by caller.
#
# This operation can take some time, so the git command is spawned
# and we perform a wait for the tag file to appear.
#
# $1 - receives the last tag string
# $2 - path to store lasttag file
#
git_get_lasttag() {

	local _ltfile_="$2"
	local _lasttag_
	local _mypid_

	[ -z "_ltfile_" ] && {
		echo "git_get_lasttag: requires path to last tag file as 2nd arg"
		return 1
	}

	[ -f "$_ltfile_" ] && rm -f $_ltfile_

	echo -en ""$INF"Getting most recent git tag..$OFF"
	git describe --tags --abbrev=0 > $_ltfile_ &
	_mypid_=$!
	ui_waitonproc $_mypid_ .1
	_lasttag_=$(< $_ltfile_)
	echo
	eval $1="$_lasttag_"
	return 0
}

# git_getcurrentbranch
#
# echoes the current branch in the git tree after checking that it's a
# valid repo
#
# usage:
# 	local current_branch=$(git_getcurrentbranch)
#
function git_getcurrentbranch {
 	git_checkrepo true
	[ $? -eq 0 ] || exit 1
	echo $(git branch | egrep \* | cut -d' ' -f2)
}

# git_setbranch outdir
#
# $1 if it exists sets the outpath. Default is /dev/shm/branchlist
#
function git_setbranch {
	local index=1
	local line
	local status=0
	local gitbranch
	local linenumber
	local outpath="/dev/shm/branchlist"

	[ $# -eq 1 ] && outpath="$1"

	git branch > $outpath
	echo
	echo -e "$BLD$UND\0Change Current Branch$OFF\n"

	while read line; do
		printf "$BLD%2d$OFF  $line\n" $index
		let index++
	done < $outpath

	echo
	loop_range_q 1 $((index - 1)) linenumber
	status=$?
	[ $status -ne 0 ] && return

	gitbranch="$(ui_readline $linenumber $outpath | tr -d [\*" "])"
	echo "git checkout "$gitbranch""
	git am --abort 2>/dev/null
	git checkout "$gitbranch" # 2>/dev/null
	status=$?
	git log --oneline -n1
	return $status
}

# find_fixes - grep for all the commits since the one passed as $1 where
#              $1 is named as a fix.
#
# See : https://www.kernel.org/doc/html/v4.17/process/submitting-patches.html
#
#       "If your patch fixes a bug in a specific commit, e.g. you found an
#        issue using git bisect, please use the ‘Fixes:’ tag with the first
#        12 characters of the SHA-1 ID, and the one line summary. For example:
#        Fixes: e21d2170f366 ("video: remove unnecessary platform_set_drvdata()")
#
# $1 - a line expected to contain only a valid commit.
# $2 - file to receive the output
# $3 - directory of the remote repo
# $4 - the remote branch to parse
#
find_fixes () {
	local commit_id="$1"
	local tmpfil="$2"
	local remdir="$3"
	local rembranch="$4"
	local commit_info=
	local short_hash=
	local commit_date=

	# cd to the remote repo directory
	#
	cd "$remdir"

	# get the author date, which is what is displayed in git-log output
	commit_info=$(git log --pretty="%h|%ad" -1 "$commit_id" 2>/dev/null)
	[ $? -eq 0 ] || return 1
	short_hash=$(echo "$commit_info" | awk -F "|"  ' { print $1 } ')
	commit_date=$(echo "$commit_info" | awk -F "|"  ' { print $2 } ')


	# Make the commit date the first line in the tmpfil
	#
	echo "$commit_date" > $tmpfil

	# use the date to do a git log --since=$commit_date and grep for Fixes?
	# then look for short hash
	git --no-pager log \
		--oneline \
		--pretty='%h ("%s")' \
		--since="$commit_date" \
		--grep="Fixes: $short_hash" \
		$rembranch >> $tmpfil

	# Return to the original directory
	#
	cd - > /dev/null 2>&1
}

# extract_commitlog - extract the commit log from a patch
#
# $1 - patchfile
# $2 - destination file
#
extract_commitlog() {
	local patchfile="$1"
	local outfile="$2"

	> $outfile

	while read line; do
		[ "${line:0:3}" == "---" ] && break
		echo "$line" >> $outfile
	done < $patchfile
}

# parse_missingfix - parse the missing fix
#
# Determine whether the fix has already been included in RHEL, or was
# intentionally omitted, or is truly missing. Send output to the screen
# and to the missing_commits file.
#
# $1 - commit date to start search
# $2 - line to parse
# $3 - enumeration of the commit id in the series
# $4 - file containing the list of RHEL commits being reviewed
# $5 - file that will contain any missing fixes
# $6 - file containing Merge Request commit log for the specific patch
# $7 - verbose flag
#
# Returns 1 if a fix is really missing, 0 otherwise.
#
parse_missingfix() {
	local cmtdate="$1"
	local fix_line="$2"
	local commitnum="$3"
	local commitsfile="$4"
	local missing_file=$5
	local mr_commitlog="$6"

	local fix_id=$(echo "$fix_line" | awk ' { print $1 } ')
	local currentbranch=$(git branch | egrep \* | cut -d' ' -f2)
	local missing="Missing Fix:"
	local tskip="Intentionally Omitted Fix:"
	local merged="$currentbranch already has Fix:"
	local tokay="contains Fix:"
	local tmsg="WARNING: found $missing"
	local found=
	local found_id=
	local mypid=

	# If the "missing" commit was intentionally omitted, print a message
	# and return.
	if cat $mr_commitlog | grep -i "omitted-fix" | grep "$fix_id" > /dev/null 2>&1; then
		echo -e "$INF$tskip $fix_line for $commitnum $OFF"
		echo "$tskip $fix_line for $commitnum" >> $missing_file
		return 1
	fi

	# If the missing fix is in the list of upstream commits, then it's
	# applied later in the current MR.
	if found=$(grep "$fix_id" "$commitsfile"); then
		found_id=$(echo "$found" | cut -d' ' -f2)
		echo -e "$INF$found_id $tokay $fix_line for $commitnum$OFF"
		echo "$found_id $tokay $fix_line for $commitnum" >> $missing_file
		return 1
	fi

	# If the "missing" commit is in the current branch,
	# then the upstream commitid has already been applied.
	# In that case, inform the user and return.
	git log --since="$cmtdate" | grep -m1 "commit $fix_id" > /dev/null 2>&1 & mypid=$!
	ui_waitonproc_tty $mypid .05
	if [ $? -eq 0 ]; then
		echo -e "$INF$merged $fix_line for $commitnum$OFF"
		echo "$merged $fix_line for $commitnum"  >> $missing_file
		return 1
	else
		# The missing fix is truly missing, so warn accordingly.
		echo -e "$WRN$tmsg $MNU$fix_line$WRN for $STA$commitnum$OFF"
		echo "$tmsg $fix_line for $commitnum" >> $missing_file
		return 2
	fi

	return 0
}

# check_fixes - look for missing fixes
#
# Walk through the file of upstream commits looking for any that may have
# been missed. If the upstream commits have already been applied, then the
# backported commits will be reported as false positives, so precaution is
# taken to see if the "missing" commits are in the current branch.
#
# GLOBALS
#   indir - directory containing the MR patches
#
# $1 - path to the file containing the upstream commits. Each commit is
#      expected to be the first field in each line of the file.
#
# $2 - remote directory containing the remote_repo/remote_branch
#
# $3 - the remote_repo/remote_branch in which to seek missing fixes
#
# $4 - file to contain the list of missing fixes
#
# $5 - optional verbose boolean true or false. Default is true.
#
# Returns
# 	0 - all is well
# 	1 - something went wrong
#
check_fixes() {
	local commitsfile="$1"
	local remdir="$2"
	local rembranch="$3"
	local missing_file="$4"
	local line=
	local fixes=
	local commitid=
	local commit_fix=
	local commit_fix_id=
	local tmsg="WARNING: found missing fix "
	local emsg="$WRN$tmsg$MNU"
	local tskip="Intentionally Omitted Fix : "
	local eskip="$MNU$tskip$STA"
	local mypid
	local fixfile="/dev/shm/fixfile"
	local currentbranch=$(git branch | egrep \* | cut -d' ' -f2)
	local verbose=true
	local patch=
	local mr_commitlog="/dev/shm/mr_commit.log"
	local patch_filename=
	local stat=0
	local cmtdate=

	[ -n "$5" ] && verbose=$5

	[ -f $commitsfile ] || {
		echo -e ""$INF"Expecting file: $STA$commitsfile$OFF"
		echo -en ""$INF"to contain the upstream commits to be checked, but"
		echo -e "$WRN it does not exist$OFF"
		return 1
	}

	echo -e "\n"$INF"Looking for missing fixes in $STA$remdir : $rembranch$INF...$OFF"

	while read line; do
		commitid=$(echo "$line" | cut -d' ' -f1)
		patch=$(echo "$line" | cut -d' ' -f2)

		# If the commitid is empty, get the next line in commitsfile.
		(( 16#$commitid )) || continue

		find_fixes "$commitid" "$fixfile" "$remdir" "$rembranch" & mypid=$!
		ui_waitonproc_tty $mypid .05 "${INF}Checking $STA$patch${INF}: $commitid$OFF"
		$verbose || ui_clearline up

		# The fixfile will always have at least one line in it. The first line
		# is always the date of the commit being tested for fixes.
		#
		if [ -f "$fixfile" ] && [ $(cat "$fixfile" | wc -l) -gt 1 ]; then

			patch_filename=$(find_filebynumber "$patch" "$indir")
			extract_commitlog "$indir/$patch_filename" "$mr_commitlog"

			cmtdate=
			while read -r commit_fix; do
				# first line in the file is the date
				# get that and continue
				[ -z "$cmtdate" ] && { cmtdate="$commit_fix"; continue; }

				parse_missingfix \
					"$cmtdate" \
					"$commit_fix" \
					"$patch" \
					"$commitsfile" \
					"$missing_file" \
					"$mr_commitlog" & mypid=$!
				wait $mypid

				[ $? -eq 0 ] || { stat=1; }

			done < "$fixfile"
		fi

	done < "$commitsfile"

	[ -f $fixfile ] && rm -f $fixfile
	return $stat
}

show_remotes() {
	local line
	local toks=()
	local gitcfgarray=()
	local remoteurl=

	gitcfgarray=$(grep -w '\[remote' .git/config)
	while read line; do
		ui_strtok "$line" '" ' toks
		remote=$(echo ${toks[1]} | sed  's/]//')
		remoteurl=$(show_remote_url "$remote")
		echo -e "$remote"
		echo -e "$remoteurl"
		echo
	done <<< "$gitcfgarray"
}

create_remote_array() {
	local line
	local toks=()
	local remarray=()
	local gitcfgarray=()

	gitcfgarray=$(grep -w '\[remote' .git/config)
	while read line; do
		ui_strtok "$line" '" ' toks
		remote=$(echo ${toks[1]} | sed  's/]//')
		remarray+=($remote)
	done <<< "$gitcfgarray"

	eval $1="(${remarray[@]})"
}

select_remrepo() {
	local cur="${!1}"
	local remotes=()
	local num_of_remotes
	local stat

	create_remote_array remotes
	num_of_remotes=${#remotes[@]}

	case $num_of_remotes in
		0 ) echo -e "${WRN}No remotes could be detected in .git/config.$OFF"
		    return 1
		    ;;
		1 ) cur=${remotes[0]}
		    stat=0
		    ;;
		* ) select_from_array remotes "remote repos" cur
		    stat=$?
	esac

	eval $1=$cur
	return $stat
}

show_remote_url() {
	local reponame="$1"
	local url
	[ -z "$reponame" ] && return
	url=$(grep -A1 "remote \"$reponame" .git/config | grep url | cut -d'=' -f2)
	echo "$url"
}

select_rembranch() {
	local repo="$1"
	local cur="${!2}"
	local brstr=
	local brancharray=()

	# Get all the branches into one string
	brstr=$(git branch -r | grep "$repo" | cut -d'/' -f2)

	# Filter out lines with '-> in them, because they are not branches
	while read s; do [[ $s == *"->"* ]] || brancharray+=($s); done <<< "$brstr"

	if [ ${#brancharray[@]} -gt 1 ]; then
		select_from_array brancharray "remote branches in $remote_repo" cur
	else
		cur=${brancharray[0]}
		echo -e "$INF Only one branch in this repo: $STA$cur$OFF"
		echo -e "$INF Nothing else to choose from.$OFF"
	fi

	eval $2=$cur
	return 0
}
