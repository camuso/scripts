#!/bin/bash
#
# lib/patch-common.source
#
# This source file provides routines common to both patchreview and
# patchdevelop scripts.
#
version="12.2.2"

# Get the directory defaults if they don't already exist
#
[ "$MYDIR" ] || {
	declare MYDIR=
	MYDIR="$(dirname "$(which "$(basename "$0")")")"
}
[ "$MYLIB" ] || {
	declare MYLIB=
	MYLIB="$MYDIR"/lib
}

[ "$ui_loaded" ]            || source "$MYLIB"/ui.source
[ "$gitutilities_loaded" ]  || source "$MYLIB"/gitutilities.source
[ "$patchutils_loaded" ]    || source "$MYLIB"/patch-utils.source
[ "$configmanager_loaded" ] || source "$MYLIB"/config-manager.source

declare patchcommon_loaded=true

# Enable extglob for more specific directory actions
#
shopt -s extglob

declare MYDATA=
declare MYMAN="$MYDIR"/man
declare repolist="$HOME"/.config/patchreview/repolist
declare main_man=
declare config_man=
main_man="$MYMAN/$(basename "$0").txt"
config_man="$MYMAN/$(basename "$0")-config.txt"

#######################################
# External Scripts
#######################################
alias githead='$MYDIR/githead'
alias renpat='$MYDIR/renpat'
alias patcmp='$MYDIR/patcmp'
alias patbatcmp='$MYDIR/patbatcmp'
alias patbatcmpmgr='$MYDIR/patbatcmpmgr'

# Declare the global variables
#
declare labuser
declare indir
declare outdir
declare indirstr="Patch"
declare outdirstr="Work"
declare patstr		# string used by show_settings,
			# : empty if there are no patch files

declare editor
declare index=0
declare boolcount=0
declare boolindex=0
declare b_found_first_bool=false
declare b_selpat=false
declare b_allapplied=false
declare infilecount=0			# number of files in the input directory
declare patchtotal=0			# total patches in the input directory
declare us_commits_name="us-commits.log"	# upstream commits log filename
declare bp_commits_name="bp-commits.log"	# backport commits log filename
declare usvbp_commits_name="usvbp-commits.log"	# map of upstream vs backported commits

declare us_commits				# These must be initialized in menu
declare bp_commits				# : loop
declare usvbp_commits

declare patchcount=0
declare commit_msg_file="commit-msg.txt"
declare last_tag_file=
declare branchlist=
declare mismatch_file="mm.log"	# patchreview/develop will complete mmfile path
declare mmfile			# complete name of mmfile set by patchreview/devlop
declare valpatchlist=		# inited by call to patch-utils::create_patchlist

# These booleans are always set true when the script is inited.
declare b_rename_infiles
declare b_fmt_upstream
declare b_mrcomments=true
declare b_verbose
declare b_seekfixes

declare lasttag=
declare -i patchvalfuzz

# menu display control
declare -i menumode
declare -i menumode_ext=0
declare -i menumode_min=1
declare -i menumode_states=2

declare -i cmpmode
declare -i cmpmode_off=0
declare -i cmpmode_batch=1
declare -i cmpmode_inter=2
declare -i cmpmode_setup=3
declare -i cmpmode_states=4

declare -i applymode
declare -i applymode_off=0
declare -i applymode_norm=1
declare -i applymode_3way=2
declare -i applymode_patch=3
declare -i applymode_states=
declare -i applyfailmode
declare -i applyfailmode_exit=0
declare -i applyfailmode_cont=1
declare -i applyfailmode_menu=2
declare -i applyfailmode_states=3

declare -i startpat=1
declare -i menucols=30

# Values to be returned by renpat
#
declare -i renpatcnt	# the number of patch files counted by renpat
declare -i rensetcnt	# the number of patch files in the series

declare el6="el6"
declare el7="el7"
declare el8="el8"
declare el9="el9"

declare remote_repo=
declare remote_branch=
declare missing_fixes=	# File to contain missing fixes
declare remote_dir=

declare b_cmdline=false

declare -i mrqan_done=0
declare -i mrqan_news=8
declare -i mrqan_newg=9
declare -i mrqan_run=10

declare menuinput=

########################################
# Function Return Codes
########################################
declare rc_continue=0	# Continue for another pass
declare rc_run=1	# Run
declare rc_pass=2	# don't run

exit_me() {
	echo -e "$OFF"

	cfg_update_configfile
	update_mrhistoryfile

	_prologue=false
	[ -f "$prologue_file".txt ] && 	mv "$prologue_file".txt "$prologue_file"
	[ -e "$last_tag_file" ] && rm -f "$last_tag_file"
	[ -e "$branchlist" ] && rm -f "$branchlist"
	exit "$1"
}

# exit_msg - uses exit messages from lib/ui.source
#
exit_msg() {
	local -i msgindex="$1"
	local artifact="$2"
	local msg

	msg="$WRN${ui_err_msg[msgindex]}$OFF"
	[ -n "$artifact" ] && msg="$MNU$artifact $msg"
	echo -e "$msg"
	exit_me "$msgindex"

}

# run if user hits control-c
#
control_c() {
	echo -en "\nCtrl-c detected\nCleaning up and exiting.\n"
	exit_me $CTLC_EXIT
}

################  SANITY TEST DEBUGER  ###########################
test_sanity() { echo -e "$BLD\0SANITY$OFF"; ui_press_any; }
###################################################################

set_cfg_item() {
	cfg_write_key "$1" "$2"
}

get_cfg_item() {
	cfg_read_key "$1"
}

show_version() {
       echo -e "${INF}Version: $STA$version$OFF"
}

show_seekfixes() {
	$b_seekfixes && echo "ON" || echo "OFF"
}

show_missing_fixes() {
	if [ -s "$missing_fixes" ] \
	&& grep -q 'WARNING:' "$missing_fixes"; then
		echo -e "$MNU f$OFF  Show missing fixes"
	fi
}

show_screenbg() {
	echo -en "${MNU}Currently $STA"
	if ((background == tb_dark)); then
		echo -e "DARK$OFF"
	else
		echo -e "LIGHT$OFF"
	fi
}

print_missing_fixes() {
	if [ -s "$missing_fixes" ]; then
		echo -e "$INF"
		missingfixes -a
		echo -e "$OFF"
		ui_press_any
	fi
}

# set_working_repo - set the repo directory to work in
#
# Globals
# 	repolist - list of repo directories
#
set_working_repo() {
	local dndx
	local dnum
	local dary=()
	local repod
	local instruct

	instruct=$(
cat <<EOF
$INF
You must create a $MNU$repolist$INF file
containing a list of directories with repos you are using.
For example...

$ cat $repolist
/mywork/rhel8/kernel
/mywork/c9s/kernel
/mywork/rhel9/kernel
$OFF

EOF
)
	[ -f "$repolist" ] || {
		echo -e "$instruct"
		ui_press_any
		return 1
	}

	mapfile -t dary < "$repolist"
	for ((dndx = 0; dndx < ${#dary[@]}; ++dndx)); do
		echo -e "$MNU$((dndx+1)). $OFF${dary[dndx]}"
	done

	loop_range_q 1 ${#dary[@]} dnum || return 1
	repod="$(realpath "${dary[dnum-1]}")"

	[ -d "$repod" ] || {
		echo -e "$WRN$repod is not a directory!$OFF"
		ui_press_any
		return 1
	}

	cd "$repod" || exit_msg "$ui_err_invdir" "$repod"
	[ -d .git ] || {
		echo -e "$WRN$repod is not a git repo!$OFF"
		ui_press_any
		cd - > /dev/null || exit_msg "$ui_err_invdir" "cd -"
		return 1
	}

	init_parms
	missing_fixes="$outdir/missing_fixes"
	git_get_lasttag lasttag "$last_tag_file"
	return 0
}

# set_remotedir - name the directory where the upstream remotes are
#
# GLOBALS
# 	remote_dir
#
set_remotedir() {
	local stat
	local b_exists=false

	echo -e "\n$INF Set the directory that contains the remote repo to" \
		"search for missing fixes.$OFF"

	if [ -n "$remote_dir" ]; then
		echo -e "$INF Your current remote directory is: $STA$remote_dir"
		prstr="$INF Enter a new remote directory or press "
		prstr+="$qstr$INF to leave it unchanged : $OFF"
		b_exists=true
	else
		prstr="$INF Enter a new remote directory : $OFF"
		b_exists=false
	fi

	while :; do
		ui_getnewdir "$prstr" remote_dir
		stat=$?

		if ($b_exists && [ $stat -eq 4 ]); then
			return
		else
			if [ $stat -ne 4 ]; then
				break
			else
				echo -e \
				    "${WRN}You must provide an upstream directory.$OFF"
			fi
		fi
	done

	# get the full pathname of the remote directory.
	# If there is no git repo in it, print the tutor to the screen
	# and exit gracefully.
	#
	remote_dir=$(realpath "$remote_dir")
	[ -d "$remote_dir"/.git ] || exit_msg "$ui_err_norepo" "$remote_dir"

	# Changing the remote directory means changing the remote
	# origin/branch, too.
	#
	remote_repo=
	remote_branch=
	set_cfg_item "remote_repo" "$remote_repo"
	set_cfg_item "remote_branch" "$remote_branch"
	set_cfg_item "remote_dir" "$remote_dir"
}

# set_remote_seek() - set the remote origin and branch to seek
#
# Sets up the remote origin/branch global fields to use when seeking
# missing fixes.
#
# GLOBALS:
# 	remote_repo
# 	remote_branch
#
set_remote_seek() {
	local remotes=
	local b_set=true
	local remrepo_msg

	remrepo_msg=$(
cat <<EOF
$INF
 Set the upstream origin/branch in: $STA$remote_dir$INF
 to search for any missing fixes.$OFF
EOF
)
	[ -n "$remote_dir" ] || set_remotedir
	echo -e "$remrepo_msg"

	if [ -n "$remote_repo" ] && [ -n "$remote_branch" ]; then
		remotes="$remote_repo/$remote_branch"
		echo -e "$INF Your current remote repo/branch is: $STA$remotes"
		loop_yn "$MNU Do you want to change this? (y/n) : $OFF" b_set
	fi

	if $b_set; then
		cd "$remote_dir" || exit_msg "$ui_err_invdir" "$remote_dir"
		select_remrepo remote_repo && select_rembranch "$remote_repo" remote_branch
		cd - > /dev/null || exit_msg "$ui_err_invdir" "cd -"
		set_cfg_item "remote_repo" "$remote_repo"
		set_cfg_item "remote_branch" "$remote_branch"
	fi
}

# check_upstream - check the upstream dir and remote branches
#
# 	remote_repo
# 	remote_branch
# 	remote_dir
#
check_upstream() {

	# See if the remote/branch exists. If not, query for them
	cd "$remote_dir" || exit_msg "$ui_err_invdir" "$remote_dir"
	while :; do
		git branch -r | grep -q "$remote_repo/$remote_branch" \
			&& break
		echo -e "${WRN}Cannot find $STA$remote_repo/$remote_branch$WRN"
		echo -e "in remote directory: $STA$remote_dir$OFF"
		set_remote_seek
	done
	cd - > /dev/null || exit_msg "$ui_err_invdir" "cd -"
}

# seek_missing_fixes() - search remote/branch for missing commits
#
# GLOBALS
# 	us_commits
# 	remote_repo
# 	remote_branch
# 	remote_dir
# 	missing_fixes	# file
# 	b_verbose
#
seek_missing_fixes() {
	[ -d "$remote_dir" ]    || set_remotedir
	[ -n "$remote_repo" ]   || select_remrepo remote_repo
	[ -n "$remote_branch" ] || select_rembranch "$remote_repo" remote_branch
	[ -f "$us_commits" ]    || format_upstream_patches

	check_upstream

	: > "$missing_fixes"
	check_fixes "$us_commits" \
		"$remote_dir" \
		"$remote_repo/$remote_branch" \
		"$missing_fixes" \
		$b_verbose

	[ -s "$missing_fixes" ] && \
	grep -q 'WARNING:' "$missing_fixes" && echo -e \
		"${WRN}There are missing fixes listed in $STA$missing_fixes$OFF"
	return 0
}

# test_editor() - tests for the existence of the chosen editor
#
# If the editor was not installed, the user is given a choice to exit now
# to install it or to select another editor. The function returns a 1 in
# this case to signal the caller that the editor is not installed and the
# user wants to see the choices available again.
#
# If the editor was installed, then it is set in the project file and the
# caller is signaled with a return of zero that the editor has been
# successfully chosen.
#
# $1 - the string name of the editor
#
# returns 0 if editor was found
# returns 1 if editor was not found
#
test_editor() {
	local _editor_="$1"
	local _noed_
	local _pstr_

	_noed_=\
"$WRN$_editor_$INF is not installed. Do you want to exit and install it now?$OFF"

	_pstr_=\
"${INF}Press '${MNU}y$INF' to exit now or '${MNU}n$INF' to select another editor: $INF"

	which "$_editor_" > /dev/null 2>&1 || {
		echo -e "$_noed_"
		getyn "$_pstr_" && exit_msg "$ui_err_invcmd" "$_editor_"
		return 1
	}

	set_cfg_item editor "$_editor_"
	return 0
}

set_editor() {
	local choice
	echo -e "${INF}Select one of these currently supported diff editors.$OFF"
	echo -e "$MNU 1 -$OFF vimdiff"
	echo -e "$MNU 2 -$OFF emacs"
	echo -e "$MNU 3 -$OFF tkdiff"

	while true; do
		loop_range 1 3 choice
		case "$choice" in
			1 )	editor="vimdiff";;
			2 )	editor="emacs"	;;
			3 )	editor="tkdiff"
		esac
		test_editor "$editor" && break
	done
	set_cfg_item "editor" "$editor"
	echo -e "${INF}Editor is $STA$editor$OFF\n"
}

set_colors() {
	while :; do
		ui_use_colors
		background="$terminal_background"
		set_cfg_item background "$terminal_background"
		echo -en "${INF}You chose "

		case "$terminal_background" in
			1) echo -e "${STA}light$INF background$OFF\n";;
			2) echo -e "${STA}dark$INF background$OFF\n";;
		esac

		if loop_yn_ro "Is that what you want? (y/n) : "; then
			return
		else
			continue
		fi
	done
}

# get_currentfuzz - get the current patch validation fuzz level
#
# Returns a string with the level number preceded by an asterisk for
# the current fuzz level, or just a string with the level number if
# not the current level.
#
# GLOBALS
#     patchvalfuzz - current patch validation fuzz level
#
get_currentfuzz() {
	local fuzz="$1"
	local ast="* $fuzz - "
	local noa="  $fuzz - "

	if ((fuzz == patchvalfuzz)); then
		echo "$ast"
	else
		echo "$noa"
	fi
}

# set_patchvalfuzz - set the fuzz level for patch validation
#
# GLOBALS
#     patchvalfuzz - current patch validation fuzz level
#
set_patchvalfuzz() {
	local fuzz_msg

	fuzz_msg=$(
cat <<EOF
$YEL

  Patches are validated in two steps.

  First, upstream commit hashes in the submitted RHEL patch are looked up.
  Then, the summary line from 'git log --oneline' of the upstream hash is
  compared with the summary line of the submitted RHEL patch. This is done
  to avoid confounding the mention of any other hash in the git log with
  the one being backported.

  Because there can be some differences in the way developers copy the
  upstream summary line, fuzz is sometimes necessary to minimize false
  positives of invalid commits.
$OFF
  Select one of the following fuzz levels. Current level has a leading '*'

  $(get_currentfuzz 0)no fuzz, strictest comparison
  $(get_currentfuzz 1)case insensitive (DEFAULT)
  $(get_currentfuzz 2)case insensitive and ignore commas
  $(get_currentfuzz 3)case insensitive and ignore all punctuation

EOF
)
	echo -e "$fuzz_msg\n"
	loop_range_q 0 3 patchvalfuzz
	set_cfg_item patchvalfuzz "$patchvalfuzz"
}

# show_patchvalfuzz - show the current patch validation fuzz level
#
# GOBALS
#    patchvalfuzz - current patch validation fuzz level
#
show_patchvalfuzz() {
	case "$patchvalfuzz" in
		0 ) echo "0 - no fuzz, strictest comparison"
		    ;;
		1 ) echo "1 - case insensitive (DEFAULT)"
		    ;;
		2 ) echo "2 - case insensitive and ignore commas"
		    ;;
		3 ) echo "3 - case insensitive and ignore all punctuation"
		    ;;
	esac
}

# set_dir - set a directory variable and save it in the config file
#
# Arguments
#   $1 - string to be used in the prompt describing the directory
#   $2 - the config file key for the directory variable name
#   $3 - the current value of the directory variable. Will be updated
#        if the user changes the directory name.
#
set_dir() {
	local dirstr="$1"
	local dircfgkey="$2"
	local -n pdir="$3"
	local b_msgshown=false
	local ndirmsg

	ndirmsg=$(
cat <<EOF
$INF
This directory has not yet been named.
You must provide a directory path for me to continue.
If the path does not exist, I will offer to create it
for you.
$OFF
EOF
)
	[ -n "$pdir" ] && {
		echo -e "${INF}Current $STA$dirstr$INF directory : $STA$pdir$OFF"
		echo -e "${INF}Type $qstr$INF to leave it as it is.$OFF"
	}

	# We can't accept a NULL directory name, so cycle until we get one.
	#
	while :; do
		ui_getnewdir "${INF}New $STA$dirstr$INF directory : $OFF" pdir

		if [ -n "$pdir" ]; then
			[ -d "$pdir" ] || mkdir -p "$pdir"
			break
		else
			$b_msgshown || echo -e "$ndirmsg"
			b_msgshown=true
		fi
	done

	pdir=$(realpath "$pdir")
	set_cfg_item "$dircfgkey" "$pdir"
	echo -e "$INF$dirstr directory is $STA$pdir$OFF\n"
}

# exec_boolean
#
# Execute a command string and pass the boolean that was
# used to determine whether the command should be executed.
# The boolean will be given the value passed by the caller.
#
# $1 - The boolean
# $2 - The boolean's new value
# $3 - The command line as a strng.
#
# Returns the status of the executed command string.
#
exec_boolean() {
	local argc=$#
	local argv="$*"
	local stat
	local boolean="$1"
	local b_newval="$2"
	local cmdstr

	cmdstr="$(echo "$argv" | cut -d' ' -f$argc-)"

	$cmdstr
	stat=$?
	# echo "$cmdstr status: $stat"
	if ((stat == 0)); then
		((argc >= 2)) && set_cfg_item "$boolean" "$b_newval"
	else
		echo "$cmdstr"
		echo -e "\tDid not execute successfully"
		echo
	fi
	return $stat
}

# replace_patch
#
# GLOBALS
#	outdir
#	us_commits
#
replace_patch() {
	local patnum
	local commit
	local patcnt

	patcnt=$(wc -l < "$us_commits")

	getuser "Patch Number to replace: " patnum
	getuser "Correct commit ID: " commit
	ui_replaceline "$patnum" "$commit $patnum/$patcnt" "$us_commits"
	rm -f "$outdir"/*.patch
	# git_file2patchset "$us_commits" "$outdir"
	git_commit2patch "$patnum" "$commit" "$outdir"
}

# create_commit_msg
#
# $1 - pathname of patch
# $2 - outdir
#
# GLOBALS
#	commit_msg_file
#
create_commit_msg() {
	local diffstr="diff "
	local subjstr="Subject: "
	local found_subj=false
	local commit_msg_path="$outdir/$commit_msg_file"
	local sumstrpos
	local sumstr

	: > "$commit_msg_path"

	while read -r line; do
		[ "${line:0:5}" == "$diffstr" ] && break

		if [ "${line:0:9}" == "$subjstr" ]; then
			sumstrpos=$(($(ui_strindex "$line" "]") + 1))
			sumstr="$(echo -e "${line:$sumstrpos}")"
			echo "$sumstr" >> "$commit_msg_path"
			echo "" >> "$commit_msg_path"
			found_subj=true
		fi
		$found_subj && echo "$line" >> "$commit_msg_path"
	done < "$1"
}

# process_patcherr - decide what to do upon patch apply error
#
# Globals
# 	patchcount
# 	applyfailmode*
#
process_patcherr() {
	local failedpatch="$1"
	local ghead="$2"
	local amresolve

	echo -en "$BLD"
	echo -e "\nPatch: $OFF$failedpatch$BLD"
	echo -e "Failed to apply.$OFF"

	check_already_applied

	if (( applymode != applymode_patch )); then
		echo "Please select one of the following"
		echo "1 - git am --abort"
		echo "2 - git am --quit"
		echo
		loop_range 1 2 amresolve

		case "$amresolve" in
			1 ) git am --abort
			    git reset --hard "$ghead"
			    patchcount=0
			    ;;
			2 ) git am --quit
			    patchcount=$(git log --oneline "$ghead"..HEAD | wc -l)
			    ;;
		esac
	fi

	case "$applyfailmode" in
	    "$applyfailmode_exit" )
		    echo -e "Exiting script ...\n"
		    exit_me 1
		    ;;
	    "$applyfailmode_cont" )
		    echo -e "Continuing without patching...\n"
		    ;;
	    "$applyfailmode_menu" )
		    echo -e "Returning to main menu ...\n"
	esac
}

# use_patch - use the patch app instead of git am
#
# Arguments
#	$1 - the string containing the list of patches
#
# Globals:
#	patchcount - running tally of applied patches
#	startpat   - patch to start applying from
#
use_patch() {
	local patchlist="$1"
	local stat=0
	local cmtlog="/dev/shm/cmtlog.txt"

	for patch in $patchlist; do
		((patchcount++))
		# [ $patchcount -ge $startpat ] || continue
		echo "$patch"
		patch --fuzz=3 -p1 < "$patch"
		stat=$?

		((stat == 0)) && {
			git log -n1 --pretty=format:"%s" > "$cmtlog"
			echo -e "\n" >> $cmtlog
			git log -n1 --pretty=medium >> "$cmtlog"
			git commit . -s -F "$cmtlog"
			rm -f "$cmtlog" > /dev/null 2>&1
		}
	done

	return $stat
}

# get_failedpatch - returns the filename of the failed patch
#
# Globals
# 	patchcount - running tally of applied patches
# 	applymode
# 	applymode_patch
#
get_failedpatch() {
	local patchlist="$1"
	local patcharray=( "$patchlist" )
	local patsub
	local patfil

	if (( applymode == applymode_patch )); then
		echo "${patcharray[$((patchcount - 1))]}"
	else
		patsub="$(git am --show-current-patch | grep -m1 'Subject: ')"
		patsub="$(echo "$patsub" | cut -d'[' -f2 | cut -d']' -f1)"
		patfil="$(grep -l "$patsub" "$patchlist")"
		echo "$patfil"
	fi
}

# map_us2bp - map upstream to backported commits
#
# GLOBALS
#	bp_commits    - log of backported commits
#	us_commits    - log of upstream commits
#	usvbp_commits - map of upstream to backported commits
#
map_us2bp() {
	local usline=
	local bpline=
	local b_done=false

	: > "$usvbp_commits"

	# Create two file descriptors for the upstream and backported logs.
	exec 5<"$us_commits"
	exec 6<"$bp_commits"

	until $b_done; do
		read -ru 5 usline || b_done=true
		read -ru 6 bpline || b_done=true

		usline="$(echo "$usline" | cut -d' ' -f1)"

		$b_done || echo -n "$usline " >> "$usvbp_commits"
		$b_done || echo "$bpline" >> "$usvbp_commits"
	done

	exec 5<&-
	exec 6<&-
}

# apply_patches
#
# GLOBALS
#	indir         - input directory, contains the patches
#	patchcount    - running count of applied patches
#	patchtotal    - total number of patches to apply INITED HERE
#	bp_commits    - log of backported commits
#	applymode*    - git am, git am -3, or patch --fuzz=3 -p1
#	applyfailmode - exit, goto main-menu, or continue
#	startpat      - patch from which to start the apply
#	valpatchlist  - created by call to lib/patch-utils::create_patchlist
#
apply_patches() {
	# echo -e "\n$BLD\0patch-common::apply_patches()$OFF"
	local stat=0
	local patchlist

	patchlist="$(ls -1 "$indir"/*.patch)"

	create_patchlist "$patchlist" valpatchlist "$startpat"
	patchtotal=$(wc -w <<< "$valpatchlist")

	((applymode == applymode_off)) && return 0
	: > "$bp_commits"

        [ "$valpatchlist" ] || {
		echo -e "$WRN\nIt appears there are no valid patches to apply.\n$OFF"
		return 1
	}

	case "$applymode" in
	    "$applymode_norm"  ) git am "$valpatchlist"    ; stat=$? ;;
	    "$applymode_3way"  ) git am -3 "$valpatchlist" ; stat=$? ;;
	    "$applymode_patch" ) use_patch "$valpatchlist" ; stat=$? ;;
	esac

	((stat == 0)) || process_patcherr "$(get_failedpatch "$valpatchlist")"

	# Create the log of commits backported.
	patchcount=$(find "$indir" -maxdepth 1 -name "*.patch" | wc -l)
	git log --oneline -n"$patchcount" > "$bp_commits"
	map_us2bp

	if ((stat == 0)); then b_allapplied=true; else tail -1 "$bp_commits"; fi
	return $stat
}

show_discrete_ops() {
	echo -en "$MNU x$OFF  "
	case "$menumode" in
		"$menumode_ext" ) echo -en "Hide " ;;
		"$menumode_min" ) echo -en "Show ";;
	esac
	echo -e "$MNU${UND}Discrete Operations$OFF Menu"
}

show_colors() {
	if $b_color; then echo -e "ON"; else echo -e "OFF"; fi
}

show_verbose() {
	if $b_verbose; then
		echo -e "${MNU}verbose is$STA ON$OFF"
	else
		echo -e "${MNU}verbose is$STA OFF$OFF"
	fi
}

show_patches() {
	echo -en "$MNU d$OFF  $indirstr directory"
	printf "%*c" $((15 - ${#indirstr})) " "
	echo -e  ":$STA $indir$OFF has $STA$infilecount$OFF ${patstr}files."
}

show_workdir() {
	echo -en "$MNU w$OFF  $outdirstr directory"
	printf "%*c" $((15 - ${#outdirstr})) " "
	echo -e ":$STA $outdir"
}

show_cmpmode() {

	case "$cmpmode" in
	    "$cmpmode_off"   )	echo "OFF" ;;
	    "$cmpmode_batch" )	echo "Batch" ;;
	    "$cmpmode_inter" )	echo "Interactive Only" ;;
	    "$cmpmode_setup" )	echo "Batch compare setup" ;;
		           * )	echo "Not a valid comparison mode" ;;
	esac
}

show_applymode() {

	case "$applymode" in
	    "$applymode_off"   )	echo "OFF" ;;
	    "$applymode_norm"  )	echo "git am" ;;
	    "$applymode_3way"  )	echo "git am 3-way merge" ;;
	    "$applymode_patch" )  echo "patch --fuzz=3 -p1 <" ;;
	                     * )	echo "Not a valid apply mode" ;;
	esac
}

show_applyfailmode() {

	case "$applyfailmode" in
	    "$applyfailmode_exit" ) echo "Exit" ;;
	    "$applyfailmode_cont" ) echo "Continue without applying" ;;
	    "$applyfailmode_menu" ) echo "Return to main menu" ;;
	                        * ) echo "Not a valid failover mode" ;;
	esac
}

show_view_logs() {
	local logs

	logs=$(ls -1 "$outdir"/*.log 2> /dev/null)

	[  "$logs" ] && echo -e "\n$MNU V$OFF  View the log files"
}

view_logs() {
	local logs
	local logfile
	local index=1
	local choice

	mapfile -t logs < <(find "$outdir" -type f -name "*.log")
	((${#logs[@]} != 0)) || {
		echo -e "\n${INF}There are currently no log files.$OFF"
		return
	}

	echo -e "\n${MNU}Select the log file you wish to view.$OFF\n"
	for logfile in "${logs[@]}"; do
		echo -e "$MNU$index$OFF - $logfile"
		((++index))
	done
	echo

	loop_range_q 1 $((index - 1)) choice || return

	less "${logs[$((choice - 1))]}"
}

# get_filecount() - count the files in the indir
#
# This is a bit ugly. If there are .patch files in the indir, then count
# the number of patch files, else count all the files.
#
# Globals:
# 	infilecount
# 	patstr      - used by show_settings
# 	b_selpat
#
get_filecount() {
	local fc

	fc=$(find "$indir" -maxdepth 1 -type f -name "*.patch" -print -quit)
	if [ "$fc" ]; then
		infilecount=$(find "$indir" -maxdepth 1 -type f -name "*.patch" | wc -l)
		! $b_allapplied && b_selpat=true || b_selpat=false
		patstr="patch "
		b_rename_infiles=false
	else
		infilecount=$(find "$indir" -maxdepth 1 -type f | wc -l)
		patstr=""
		b_selpat=false
		b_rename_infiles=true
	fi
}

# show_nextpatch() - determine whether user can select next patch
#                    and display accordingly
#
# Globals:
# 	infilecount
# 	b_allapplied
#
show_nextpatch() {
	local shownext=

	shownext=$(
cat <<EOF
$MNU
 5$OFF  Start applying at patch  :$STA $startpat$OFF
EOF
)
	((infilecount == 0)) && { b_selpat=false; return; }

	$b_allapplied && {
		echo -e "\n$INF    All patches were successfully applied$OFF"
		return
	}

	[ "$patstr" ] && echo -e "$shownext"
}

# show_apply_patches() - show the option to apply the patches
#
# Only appears if there are patches remaining to be applied
#
# Globals:
#	b_allapplied
#
show_apply_patches() {
	echo -en "\n$MNU A$OFF  Apply patches"

	if ((applymode == applymode_off)) && $b_allapplied; then
		echo -en "            :$OFF "
		echo -en "already applied and apply mode ${STA}OFF${OFF}"
	elif ((applymode == applymode_off)) && ! $b_allapplied; then
		echo -en "            :$OFF "
		echo -en "apply mode is ${STA}OFF$OFF"
	elif ((applymode != applymode_off)) && $b_allapplied; then
		echo -en "            :$OFF "
		echo -en "already applied"
	fi
}

# select_patch() - select a patch to start the apply process
#
# Globals:
# 	patstr
# 	infilecount
# 	startpat
#
select_patch() {

	[ "$patstr" ] || {
		echo "Please run the rename on the files first."
		return
	}

	loop_range_q 1 "$infilecount" startpat ||
		echo "Leaving starting patch at $startpat."
	return
}

# show_branch_mismatch - prints discrepency between distro and kernel
#
# If user options to switch branches, the global lasttag is refreshed.
#
# Globals:
# 	lasttag
# 	last_tag_file
# 	branchlist
#
# $1 - current distro
# $2 - user's y or n response to query to switch branches
#
show_branch_mismatch() {
	local _distro_="$1"
	local -n _yn_="$2"

	echo -e "$BLD\0Patches are$OFF $_distro_$BLD but kernel is$OFF $lasttag"
	doyn "Switch branches now?" "git_setbranch $branchlist" "" _yn_
	$_yn_ && git_get_lasttag lasttag "$last_tag_file"
}

# check_patchvbranch - see if the patch names match the branch
#
# Globals
# 	rhel*str, pegas*str - strings that represent the corresponding kernels
# 	indir - directory containing the RHEL patches
#	krnstrlen - length of the string that defines which kernel
# 	lasttag
#
check_patchvbranch() {
	local pat
	local subject
	local pfx
	local dist
	local distname="NOT RHEL"
	local tag
	local elstr=""
	local yn=false
	local -i i
	local -i j
	local ary
	local b_pegas=false

	[ "$indir" ] || return 1

	# See if there are any .patch files in the $indir
	#
	stat "$indir"/*.patch > /dev/null 2>&1 || {
		echo -e "\nNo .patch files in $BLD$indir$OFF"
		ui_press_any
		return 1
	}

	# Get the subject line from the first patch and remove "Subject:"
	pat="$(find "$indir" -type f -name "*.patch" | head -1)"
	subject="$(grep 'Subject: ' -m1 i"$pat")"
	subject=${subject//"Subject: "/}

	# Convert to upper case
	pfx="$(echo "$subject" | tr '[:lower:]' '[:upper:]')"

	# Remove the word PATCH if it's there
	pfx="${pfx//"PATCH"/}"

	# The Prefix must begin with a 'RHEL'. If it does not, then advise
	# the user and offer to run anyway, or return to the main menu.
	i=$(ui_strindex "$pfx" "RHEL")

	# Find the end of the RHEL prefix at the right bracket.
	j=$(ui_strindex "$pfx" "]")

	# echo "i: $i j: $j"
	if ((i < 0)) || ((j <= 0)) || ((j <= i)); then
		echo -e "$STA$subject$OFF"
		echo -e "${WRN}...does not appear to be a RHEL patch or series$OFF"
		getyn "Do you wish to continue anyway?" yn
		$yn || return 1
		distname="NOT RHEL"
		elstr=""
	else
		# Extract the patch prefix between the brackets.
		pfx="${pfx:$i:$((j-i))}"
		# echo "pfx extracted: $pfx"

		# If there is "alt" anywhere in the prefix, then set the
		# pegas flag.
		[[ "$pfx" = *"ALT"* ]] && b_pegas=true

		# If it exists, remove the "ALT" string to get the basic distro.
		$b_pegas && dist="${pfx//ALT/}" || dist="$pfx"

		# Replace hyphens with spaces and remove any extraneous spaces.
		dist="$(tr -s "-" " " <<< "$dist")"

		# Tokenize the dist so we can extract just the RHEL and its
		# version numbers.
		ui_strtok "$dist" " " ary
		# echo "dist: \"$dist\" ary: ${ary[@]}"

		# If the first token in the array only has 4 chars, then it is
		# "RHEL" without the version numbers. In this case, the second
		# token will have the version.
		[ ${#ary[0]} -eq 4 ] && dist=${ary[0]}${ary[1]} || dist=${ary[0]}

		# echo "dist: $dist"
		case "${dist:0:5}" in
			"RHEL6" ) elstr="$el6" ; distname="$dist" ;;
			"RHEL7" ) elstr="$el7" ; distname="$dist" ;;
			"RHEL8" ) elstr="$el8" ; distname="$dist" ;;
			"RHEL9" ) elstr="$el9" ; distname="$dist" ;;
			      * ) elstr=""     ; distname="NOT RHEL" ;;
		esac

		$b_pegas && distname="${distname}-ALT" && elstr="${elstr}a"
	fi

	# Tokenize the current kernel branch tag.
	#
	ui_strtok "$lasttag" ".-" tag

	# 2020-10-05
	# Cycle through the tag array looking for elstr. It is not
	# necessarily the last token anymore.
	#
	for ((i = 0; i < ${#tag[@]}; ++i)); do
		[ "${tag[i]}" == "$elstr" ] && break
	done

	# If we went through the loop and didn't find the elstr, then the
	# script thinks that we do not have a match between the patches and
	# the current branch. In that case, see whether the user wants to
	# choose a different branch or apply the patches to the current
	# branch, regardless.
	#
	(( i < ${#tag[@]} )) ||  show_branch_mismatch "$distname" yn

	# If user did not opt to switch branches, then user wants to apply
	# patches to current branch, even when they appear to the script
	# to be mismatched.
	# If the user did switch branches, call this routine recursively to
	# see if s/he chose the correct branch.
	#
	$yn && check_patchvbranch

	return 0
}

# get_current_head_trunc() - returns the current head truncated
#
#  Truncation is the difference between the global tcols, which is the number
#  of columns of the current terminal declared in ui.source, and the number
#  passed in $1
#
#  $1 - number of columns already used (offset columns to where the current
#       head will be displayed on the terminal)
#
get_current_head_trunc() {
	local used=$1
	local cols=$((tcols-used))
	local current_head=
	local current_head_trunc=

	current_head="$(git log --oneline -n1)"
	current_head_trunc="${current_head:0:$cols}"
	echo "$current_head_trunc"
}

# create_branch - creates a branch at the current head
#
create_branch() {
	local bname=
	local tagname=
	local current_head_trunc=
	local brstr=

	current_head_trunc=$(get_current_head_trunc 23)
	brstr=$(
cat <<EOF

Create new branch at: $BLD$current_head_trunc$OFF
Press ${BLD}ENTER$OFF or $qstr at the naming prompts to \
quit without applying the change.
\0
EOF
)
	echo -e "$brstr"
	getuser "Name of the new branch: " bname
	[[ "qQ" == *"$bname"* ]]  && return
	git branch "$bname"
	echo -e "Created branch $BLD$bname$OFF"
	getuser "New tag name: " tagname
	[[ "qQ" == *"$tagname"* ]] || git tag "$tagname"
}

# format_upstream_patches
#
# Create a list of commits and use that to format the patches.
#
# Globals:
# 	indir
# 	outdir
# 	us_commits
# 	b_fmt_upstream
# 	remote_dir
#
# Returns
# 	0 - all good
# 	1 - no patch files to review
#
format_upstream_patches() {
	$ui_b_debug && echo -e "${STA}format_upstream_patches$OFF"
	local fc=	# $(find $outdir -maxdepth 1 -not -type d -name "*.patch" -print -quit)
	local b_yup
	local banner=
	local pad=
	local escnt=
	local stat=0
	local quiet=

	$b_verbose || quiet="-q"

	fc=$(find . "$outdir" -maxdepth 1 -type f -name "*.patch" -print -quit)

	[ "$fc" ] && {
		echo
		echo -e "${INF}There are already upstream patch files in $STA$outdir$OFF"
		getyn "Do you want to replace them? " b_yup

		if $b_yup; then
			rm -f "$outdir"/* > /dev/null 2>&1
			: > "$missing_fixes"
		else
			return 1
		fi
	}

	ls "$indir"/*.patch > /dev/null 2>&1 || {
		echo
		echo -e "${INF}There are no patch files to review in $STA$indir$OFF"
		return 1
	}

	rm -f "$outdir"/*.patch > /dev/null 2>&1
	: > "$us_commits"
	echo

	git_comment2commitsfile \
		-r "$remote_dir" -i "$indir" -o "$us_commits" -f "$patchvalfuzz" $quiet
	stat=$?
	echo
	[ $stat -eq 0 ] || {
		echo -en "$WRN${ui_err_msg[$stat]}"
		case $stat in
			"$ui_err_invdir" )  echo -e " : $STA$indir$OFF";;
			"$ui_err_invfile" ) echo -e " : $STA$us_commits$OFF";;
		esac
		return 1
	}

	if $b_verbose; then
		banner="${INF}Upstream commits extracted from the patches in $STA$us_commits$INF"
		escnt=$((${#INF} + ${#STA} + ${#INF}))
		pad=$(ui_putnchar '=' $(( ${#banner} - escnt)))
		echo -e "$banner\n$pad$OFF"

		cat "$us_commits"
		echo
	fi

	(
	cd "$remote_dir" > /dev/null || exit_msg "$ui_err_invdir" "$remote_dir"
	exec_boolean b_fmt_upstream false \
		"git_file2patchset ${us_commits} ${outdir} ${b_verbose}"
	)
	return 0
}

# check_already_applied - see if the commits have already been applied
#
# GLOBALS
# 	us_commits
# 	usvbp_commits
#
check_already_applied() {
	local usline
	local usvbpline
	local uscommit
	local bpcommit
	local linecnt=20	# just a guess for now.
	local promptresp
	local b_done=false
	local b_header=true
	local header=

	header=$(
cat <<EOF
$INF
The backported commits log $STA$bp_commits$OFF$INF is not empty.
It's possible that some of them have already been applied.
Press "$MNU"'i' (init)$INF at the main menu to remove the commits log.$OFF

Upstream       RHEL commit
------------   ------------
EOF
)
	local moreprompt=\
"${INF}If you've seen enough press$OFF $qstr$INF, else any other key to see more: $OFF"

	# if there's nothing in the us v bp commit map, just return
	#
	[ -s "$usvbp_commits" ] || return 0

	exec 5<"$us_commits"

	until $b_done; do
		read -r -u 5 usline || b_done=true
		uscommit="$(echo "$usline" | cut -d' ' -f1)"
		(( 16#$uscommit )) || continue
		echo -n "$uscommit"
		usvbpline="$(grep -m1 "$uscommit" "$usvbp_commits")"

		if [ -n "$usvbpline" ]; then
			ui_clearline

			if [ $linecnt -ge $((tlines - 2)) ]; then
				linecnt=1
				promptgetchar "$moreprompt" promptresp
				if [ "$promptresp" == "q" ]; then
					b_done=true
					continue
				fi

			fi

			bpcommit="$(echo "$usvbpline" | cut -d' ' -f2-)"

			if $b_header; then
				b_header=false
				echo -e "$header"
			fi

			echo "${uscommit:0:12}""   ""$bpcommit"
			((++linecnt))
		else
			ui_clearline
		fi
	done

	exec 5<&-
	echo
	return 1
}

# exec_apply_patches
#
# Do all the front-end housekeeping and apply the patches in the indir.
#
# Globals:
# 	patchcount
# 	applymode
# 	applyfailmode
# 	applyfailmode_menu
#
# returns nonzero if patches fail to apply
#
exec_apply_patches(){
	local stat

	git am --abort 2>/dev/null
	patchcount=0

	check_patchvbranch || return 1

	apply_patches; stat=$?
		if ((stat != 0)) && ((applyfailmode == applyfailmode_menu)); then
			return $stat
		fi

	applymode=$applymode_off
	set_cfg_item "applymode" $applymode

	return 0
}

examine_patches() {
	local tb=$terminal_background
	local quiet=

	[ -f "$mmfile" ] || { compare_patches; return 0; }
	[ -f "$us_commits" ] || { compare_patches; return 0; }

	$b_verbose || quiet="-q"
	patcmp $quiet -b "$tb" -m "$mmfile" -u "$remote_dir" \
		"$indir" "$outdir" "$editor" "$us_commits"
}

# exec_patcmp - execute the comparison of the patches
#
#  $1 - Contains "-X" to execute in patbatcmpmgr in batch mode.
#       If this parameter is not passed, then patbatcmpmgr operates in
#       setup mode.
#
# Globals:
# 	indir
# 	outdir
# 	mmfile
# 	us_commits
# 	editor
# 	patchtotal
# 	terminal_background
#
exec_patcmp() {
	$ui_b_debug && echo -e "${STA}patch-common::exec_patcmp$OFF"
	local xval="$1"
	local patchlist=
	local tb=$terminal_background
	local quiet=

	patchlist="$(ls -1 "$indir"/*.patch)"
	$b_verbose || quiet="-q"

	# If we don't have a valid patch list, create one now.
	#
	[ "$valpatchlist" ] || create_patchlist "$patchlist" valpatchlist
	patchtotal=$(wc -w <<< "$valpatchlist")

# echo "indir: $indir  outdir: $outdir"
# echo "patchtotal: $patchtotal"
# echo "patchlist:"
# echo "${patchlist[@]}"
# echo
# echo "valpatchlist:"
# echo "${valpatchlist[@]}"
# ui_press_any

	# If the mmfile does not contain the same number of patches
	# as the infilecount, then go make the mmfile.
	#
	if [ "$xval" ]; then

		$b_reviewed ||
			patbatcmpmgr -P "$valpatchlist" -R "$indir" -U "$outdir" \
				     -o "$mmfile" "$xval" -b "$tb"
	else

		patbatcmpmgr -X -P "$valpatchlist" \
			-R "$indir" -U "$outdir" -o "$mmfile" -b "$tb"
	fi
	patcmp $quiet -b "$tb" -m "$mmfile" -u "$remote_dir" \
		"$indir" "$outdir" "$editor" "$us_commits"

	return $?
}

# compare_patches - compare the downstream with the upstream
#
# Globals
#	cmpmode*
#	terminal_background
#
compare_patches() {
	local tb=$terminal_background
	local stat=

	local quiet=

	$b_verbose || quiet="-q"

	case $cmpmode in
		"$cmpmode_batch" ) exec_patcmp "-X"; stat=$? ;;
		"$cmpmode_setup" ) exec_patcmp; stat=$? ;;
		"$cmpmode_inter" ) patcmp $quiet -b "$tb" \
				   "$indir" "$outdir" "$editor" "$us_commits"
				   stat=$? ;;
			       * ) cmpmode=$cmpmode_off
	esac

	return $stat
}

# init_menu - initialize the menu loop with default global values
#
init_menu() {
	init_booleans
	get_booleans
	applymode=$applymode_norm
	set_cfg_item applymode $applymode
	patchcount=0
	startpat=1
	b_fmt_upstream=true
	b_allapplied=false
	if ((opmode == opmode_mr)); then b_mrflag=true; else b_mrflag=false; fi
	[ -f "$usvbp_commits" ] && rm -f "$usvbp_commits"
	if $b_mrflag; then
		current_mr=
		rm -f "$indir"/* >/dev/null
		rm -f "$outdir"/* >/dev/null
	fi
}

# check_patch_count
#
# Check to see that the number of .patch files matches the denominator of
# the series.
#
# Globals
# 	rensetcnt
# 	renpatcnt
#
check_patch_count() {
	local b_cont
	local miscntmsg=

	miscntmsg=$(
cat <<EOF

There are $BLD$renpatcnt$OFF patch files, but the series claims
to have $BLD$rensetcnt$OFF patches.
EOF
)
	if ((renpatcnt > 1)) && ((rensetcnt > 0)); then return 0; fi

	if ((renpatcnt == rensetcnt)); then
		return 0
	else
		echo -e "$miscntmsg"
		getyn "Do you want to continue anyway? " b_cont
		$b_cont && return 0 || return 1
	fi
}

# renpatfiles - renames the files in a given directory
#
# Globals:
# 	indir     - directory containing the emailed patches
# 	renpatcnt - the number of patch files counted by the routine
# 	rensetcnt - the number of patch files purported to be in the set
# 	            as determined by the denominator of the set, if it
# 	            exists.
#
# Returns ui_err_nofiles or return value of call to check_patch_count
#
renpatfiles() {

    declare -i total
    declare -i windex	# index of word in subj prefix having '/' in it
    declare -i fldwid=0	# width of the field having total number of patches
    declare -a pfxary	# tokenized subject line
    declare -a wary	# word having '/' in it tokenized
    declare subject
    declare word
    declare iszero=false
    declare patnum
    declare pfx		# subject prefix, stuff between the [ and ]

    rensetcnt=0		# globally declared in this file
    renpatcnt=0		# :

    cd "$indir" > /dev/null || exit_msg "$ui_err_invdir" "$indir"
    echo -e "${INF}Changing directory to $STA$PWD$OFF"
    total=$(find . -maxdepth 1 -type f | wc -l)
    echo -e "$STA$PWD$INF has $STA$total$INF files.$OFF"

    if ((total == 0)); then
	echo -e "$STA$indir$INF has no files to rename.$OFF"
	echo -en "${INF}Returning to main menu. and repo directory: $STA"
	cd - > /dev/null || exit_msg "$ui_err_invdir" "cd -"
	echo -en "$OFF"
	return $ui_err_nofiles
    fi

    ui_remove_spaces

    # Don't try to rename files that have ".patch" endings, because
    # these have already been renamed.
    #
    while IFS= read -r -d '' filename; do
	iszero=false
	word=""
	windex=0

	# Extract the subject line.
	#
	subject=$(grep -m1 "Subject: " "$filename")

	# Remove any asterisks from the subject line.
	#
	subject=$(sed 's/\*//g' <<< "$subject")

	# Remove the word "Subject: " from the line
	#
	subject=$(echo "$subject" | cut -d' ' -f2-)

	# If the next character is not '[', then it is not a patch.
	#
	[ "${subject:0:1}" == "[" ] || continue

	# Remove any version numbers from within the brackets. There is no
	# standard on where the patch version number appears, so the patch
	# can be out of order.
	#
	# Find the right bracket to isolate the text within the brackets.
	# If we don't find a right bracket in the subject line, then continue
	# to the next file.
	#
	rb_pos=$(ui_strindex "$subject" "]")
	((rb_pos < 0)) && continue

	# extract the bracketed prefix substring and remove any version numbers
	#
	pfx="${subject:1:$((rb_pos-1))}"
	new="$(echo "$pfx" | sed 's/v\w//i')"

	# Substitute the new prefix for the old in the subject string.
	#
	subject="${subject/"$pfx"/"$new"}"

	# If there is no / in the subject prefix, then it is not a series.
	#
	if [[ $new == *"/"* ]]; then

	    # Tokenize the subject prefix.
	    # Look for the first token with a '/' in it.  If all the
	    # characters leading up to the '/' are zero, then it is a
	    # prologue, not a patch.
	    #
	    ui_strtok "$new" " " pfxary
	    for ((i = 0; i < ${#pfxary[@]}; i++)); do
		    word=${pfxary[$i]}
		    [[ $word == *"/"* ]] && windex=$i && break
	    done

	    # The zeroth patch is the prologue, so skip it.
	    #
	    for ((i = 0; i < ${#word}; i++)); do
		    [[ ${word:$i:1} == "/" ]] && break
		    [[ ${word:$i:1} != "0" ]] && iszero=false && break
		    [[ ${word:$i:1} == "0" ]] && iszero=true
	    done

	    $iszero && continue

	    # Some posters do not provide padding zeroes in their PATCH
	    # n/m subject lines. This will cause out-of-order
	    # processing, since 1/n will be immediately followed by
	    # 10/n, 11/n, etc. Padding the first number with leading
	    # zeroes will preclude this.
	    #
	    # If we found a "/" in the subject string, then windex is
	    # nonzero.  In that case, we need to determine the correct
	    # number of padding zeroes required in the first number.
	    #
	    if ((windex > 0)); then

		# Tokenize the word with the "/" in it. We need to
		# pad the leading number with zeroes to make it the
		# same width as the number of patches in the set.
		# Including the brackets in the delimiter will strip
		# them from the word.
		#
		ui_strtok "$word" "[/]" wary

		# We only need to do this once per patchset
		#
		if ((fldwid == 0)); then

		    # The total number of patches is in the
		    # second word of the wary stripped of any
		    # non-alphanumeric chars.
		    #
		    rensetcnt="${wary[1]}" # | sed 's/:[][<>(),"//g')"

		    # Determine the fieldwidth of the total
		    # number of patches.
		    #
		    fldwid=${#rensetcnt}
		fi

		# Determine the fieldwidth of the patch number and pad it
		# with leading zeroes if necessary.
		#
		patnum="${wary[0]}"
		for ((j = fldwid - ${#patnum}; j > 0; --j )); do
		    wary[0]="0${wary[0]}"
		done

		# Replace the patch's n/m with the new padded n/m word.
		# The new word will have a space where there was a '/', but
		# that will be handled when we strip the non-alphanumeric
		# characters from the subject string.
		#
		pfxary[$windex]="${wary[*]}"
		subject="${pfxary[*]}-${subject:$rb_pos}"
	    fi
	fi

	# Replace non-alphanumerics with a hyphen, then delete any leading
	# and trailing hyphens.
	#
	for s in punct space; do subject="${subject//[[:%s:]]/-}"; done
	subject="${subject##+(-)}"
	subject="${subject%%+(-)}"

	newname="$subject.patch"

	# See if we already have one of these, if so, skip it.
	#
	[ -f "$newname" ] && continue

	echo "mv $filename -> $newname"
	mv "$filename" "$newname"
	((renpatcnt++))
    done < <(find . -maxdepth 1 -type f -not -name "*.patch" -print0)

    cd - > /dev/null || exit_msg "$ui_err_invdir" "cd -"
    check_patch_count
    return $?
}

# find_filebynumber - echo a filename with a leading %04d
#
# This is only useful for finding a filename that begins with a
# number padded with zeroes to four digits. It's useful when trying
# to find a patch in a directory when you have only the patch number.
#
# $1 - file number
# $2 - directory to search
#
find_filebynumber() {
	local num="$1"
	local dir="$2"

	# If the number is expressed as num/total, then extract just
	# the number. This will still work, even if the number is not
	# expressed as a fraction.
	num=$(echo "$num" | cut -d'/' -f1)

	# pad the number out to four digits with leading zeroes.
	num=$(printf "%04d" "$num")

	# find and echo the filename.
	find "$dir" -maxdepth 1 -type f -name "$num*" | head -1
}
