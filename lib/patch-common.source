#!/bin/bash
#
# lib/patch-common.source
#
# This source file provides routines common to both patchreview and
# patchdevelop scripts.
#
# This file uses shdoc-style documentation annotations.
# See: https://github.com/reconquest/shdoc
#
# Common annotations:
#   @description  - Function/script description
#   @arg          - Function argument: @arg $1 type description
#   @set          - Global variable set: @set varname type description
#   @exitcode     - Exit code: @exitcode 0 description
#   @stdout       - Standard output description
#   @example      - Usage example
#
# Use 'docscript -f funcname lib/patch-common.source' to view function documentation.
#

[ -n "$MYDIR" ] || {
	declare MYDIR
	MYDIR="$(dirname "$(readlink -f "$0")")"
}

[ -n "$MYLIB" ] || {
	declare MYLIB
	MYLIB="$MYDIR"/lib
}

[ -n "$MYMAN" ] || {
	declare MYMAN
	MYMAN="$MYDIR"/man
}

[ "$ptversion_loaded" ]     || source "$MYLIB"/patchtools-version.source
[ "$ui_loaded" ]            || source "$MYLIB"/ui.source
[ "$gitutilities_loaded" ]  || source "$MYLIB"/gitutilities.source
[ "$patchutils_loaded" ]    || source "$MYLIB"/patch-utils.source
[ "$configmanager_loaded" ] || source "$MYLIB"/config-manager.source

declare patchcommon_loaded=true

# Enable extglob for more specific directory actions
#
shopt -s extglob

declare repolist="$HOME"/.config/patchreview/repolist
declare main_man=
declare config_man=
main_man="$MYMAN/$(basename "$0").pgman"
config_man="$MYMAN/$(basename "$0")-config.pgman"

#######################################
# External Scripts
#######################################
alias githead='$MYDIR/githead'
alias renpat='$MYDIR/renpat'
alias patcmp='$MYDIR/patcmp'
alias patbatcmp='$MYDIR/patbatcmp'
alias patbatcmpmgr='$MYDIR/patbatcmpmgr'

# Declare the global variables
#
declare labuser
declare indir
declare outdir
declare indirstr="Patch"
declare outdirstr="Work"
declare patstr		# string used by show_settings,
			# : empty if there are no patch files

declare editor
declare index=0
declare boolcount=0
declare boolindex=0
declare b_found_first_bool=false
declare b_selpat=false
declare b_allapplied=false
declare infilecount=0			# number of files in the input directory
declare patchtotal=0			# total patches in the input directory
declare us_commits_name="us-commits.log"	# upstream commits log filename
declare bp_commits_name="bp-commits.log"	# backport commits log filename
declare usvbp_commits_name="usvbp-commits.log"	# map of upstream vs backported commits

declare us_commits				# These must be initialized in menu
declare bp_commits				# : loop
declare usvbp_commits

declare patchcount=0
declare commit_msg_file="commit-msg.txt"
declare last_tag_file=
declare branchlist=
declare mismatch_file="mm.log"	# patchreview/develop will complete mmfile path
declare mmfile			# complete name of mmfile set by patchreview/devlop
declare valpatchlist=		# inited by call to patch-utils::create_patchlist

# These booleans are always set true when the script is inited.
declare b_rename_infiles
declare b_fmt_upstream
declare b_mrcomments=true
declare b_verbose
declare b_seekfixes

declare lasttag=
declare -i patchvalfuzz

# menu display control
declare -i menumode
declare -i menumode_ext=0
declare -i menumode_min=1
declare -i menumode_states=2

declare -i cmpmode
declare -i cmpmode_off=0
declare -i cmpmode_batch=1
declare -i cmpmode_inter=2
declare -i cmpmode_setup=3
declare -i cmpmode_states=4

declare -i applymode
declare -i applymode_off=0
declare -i applymode_norm=1
declare -i applymode_3way=2
declare -i applymode_patch=3
declare -i applymode_states=
declare -i applyfailmode
declare -i applyfailmode_exit=0
declare -i applyfailmode_cont=1
declare -i applyfailmode_menu=2
declare -i applyfailmode_states=3

declare -i startpat=1
declare -i menucols=30

# Values to be returned by renpat
#
declare -i renpatcnt	# the number of patch files counted by renpat
declare -i rensetcnt	# the number of patch files in the series

declare el6="el6"
declare el7="el7"
declare el8="el8"
declare el9="el9"

declare remote_repo=
declare remote_branch=
declare missing_fixes=	# File to contain missing fixes
declare remote_dir=

declare b_cmdline=false

declare -i mrqan_done=0
declare -i mrqan_news=8
declare -i mrqan_newg=9
declare -i mrqan_run=10

declare menuinput=

########################################
# Function Return Codes
########################################
declare rc_continue=0	# Continue for another pass
declare rc_run=1	# Run
declare rc_pass=2	# don't run

# exit_me
# @description Clean up and exit the script
#
# Arguments:
# @arg $1 int Exit code to return
#
# Globals:
# @set prologue_file string Prologue file path (read)
# @set last_tag_file string Last tag file path (read)
# @set branchlist string Branch list file path (read)
#
# Returns:
# @exitcode * Returns the provided exit code
#
exit_me() {
	echo -e "$OFF"

	cfg_update_configfile

	_prologue=false
	[ -f "$prologue_file".txt ] && 	mv "$prologue_file".txt "$prologue_file"
	[ -e "$last_tag_file" ] && rm -f "$last_tag_file"
	[ -e "$branchlist" ] && rm -f "$branchlist"
	exit "$1"
}

# exit_msg
# @description Exit with formatted message from ui.source error messages
#
# Arguments:
# @arg $1 int Message index into ui_err_msg array
# @arg $2 string Optional artifact string to include in message
#
# Globals:
# @set ui_err_msg array Error message array (read)
#
# Returns:
# @exitcode * Returns the message index as exit code
#
exit_msg() {
	local -i msgindex="$1"
	local artifact="$2"
	local msg

	msg="$WRN${ui_err_msg[msgindex]}$OFF"
	[ -n "$artifact" ] && msg="$MNU$artifact $msg"
	echo -e "$msg"
	exit_me "$msgindex"

}

# control_c
# @description Handle Ctrl-C interrupt signal
#
# Effects:
# @stdout Prints cleanup message
#
# Returns:
# @exitcode CTLC_EXIT Exits with CTLC_EXIT code
#
control_c() {
	echo -en "\nCtrl-c detected\nCleaning up and exiting.\n"
	exit_me $CTLC_EXIT
}

# test_sanity
# @description Debug helper to display SANITY message and wait for keypress
#
# Effects:
# @stdout Prints SANITY message
#
# Returns:
# @exitcode 0 Always succeeds
#
test_sanity() { echo -e "${CAU}SANITY$OFF"; ui_press_any; }

# set_cfg_item
# @description Write a key-value pair to the config file
#
# Arguments:
# @arg $1 string Config key name
# @arg $2 string Value to set
#
# Returns:
# @exitcode 0 Always succeeds
#
set_cfg_item() {
	cfg_write_key "$1" "$2"
}

# get_cfg_item
# @description Read a value from the config file by key
#
# Arguments:
# @arg $1 string Config key name
#
# Effects:
# @stdout Prints the value associated with the key
#
# Returns:
# @exitcode 0 Always succeeds
#
get_cfg_item() {
	cfg_read_key "$1"
}

# show_version
# @description Display the current version number
#
# Globals:
# @set version string Version string (read)
#
# Effects:
# @stdout Prints formatted version string
#
# Returns:
# @exitcode 0 Always succeeds
#
show_version() {
       echo -e "${INF}Version: $STA$version$OFF"
}

# show_seekfixes
# @description Display the current seek fixes state
#
# Globals:
# @set b_seekfixes bool Seek fixes flag (read)
#
# Effects:
# @stdout Prints ON or OFF
#
# Returns:
# @exitcode 0 Always succeeds
#
show_seekfixes() {
	$b_seekfixes && echo "ON" || echo "OFF"
}

# show_missing_fixes
# @description Display menu option for missing fixes if any exist
#
# Arguments:
# @arg $1 string Indentation string for menu display
#
# Globals:
# @set missing_fixes string Path to missing fixes file (read)
#
# Effects:
# @stdout Prints menu option if missing fixes exist
#
# Returns:
# @exitcode 0 Always succeeds
#
show_missing_fixes() {
	local indent="$1"

	if [ -s "$missing_fixes" ] \
	&& grep -q 'WARNING:' "$missing_fixes"; then
		echo -e "$indent$MNU f$OFF  Show missing fixes"
	fi
}

# show_screenbg
# @description Display the current screen background setting
#
# Globals:
# @set background int Current background setting (read)
# @set tb_dark int Dark background constant (read)
#
# Effects:
# @stdout Prints DARK or LIGHT
#
# Returns:
# @exitcode 0 Always succeeds
#
show_screenbg() {
	echo -en "${MNU}Currently $STA"
	if ((background == tb_dark)); then
		echo -e "DARK$OFF"
	else
		echo -e "LIGHT$OFF"
	fi
}

# print_missing_fixes
# @description Display the contents of the missing fixes file
#
# Globals:
# @set missing_fixes string Path to missing fixes file (read)
#
# Effects:
# @stdout Prints missing fixes if file is not empty
#
# Returns:
# @exitcode 0 Always succeeds
#
print_missing_fixes() {
	if [ -s "$missing_fixes" ]; then
		echo -e "$INF"
		missingfixes -a
		echo -e "$OFF"
		ui_press_any
	fi
}

# pc_cd
# @description Change directory with error handling
#
# Arguments:
# @arg $1 string Directory path to change to
#
# Returns:
# @exitcode 0 On success
# @exitcode ui_err_invdir On invalid directory
#
pc_cd() {
	local dir="$1"
	cd "$dir" > /dev/null 2>&1 || exit_msg "$ui_err_invdir" "$dir"
}

# set_working_repo
# @description Set the repository directory to work in
#
# Globals:
# @set repolist string Path to file containing list of repo directories (read)
# @set MYDATA string Data directory path (write)
# @set missing_fixes string Missing fixes file path (write)
# @set lasttag string Last tag string (write)
#
# Returns:
# @exitcode 0 On success
# @exitcode 1 On failure or user cancellation
#
set_working_repo() {
	local dndx
	local dnum
	local dary=()
	local repod
	local instruct

	instruct=$(
cat <<EOF
$INF
You must create a $MNU$repolist$INF file
containing a list of directories with repos you are using.
For example...

$ cat $repolist
/mywork/rhel8/kernel
/mywork/c9s/kernel
/mywork/rhel9/kernel
$OFF

EOF
)
	[ -f "$repolist" ] || {
		echo -e "$instruct"
		ui_press_any
		return 1
	}

	mapfile -t dary < "$repolist"
	for ((dndx = 0; dndx < ${#dary[@]}; ++dndx)); do
		echo -e "$MNU$((dndx+1)). $OFF${dary[dndx]}"
	done

	loop_range_q 1 ${#dary[@]} dnum || return 1
	repod="$(realpath "${dary[dnum-1]}")"

	[ -d "$repod" ] || {
		echo -e "$WRN$repod is not a directory!$OFF"
		ui_press_any
		return 1
	}

	cd "$repod" || exit_msg "$ui_err_invdir" "$repod"
	[ -d .git ] || {
		echo -e "$WRN$repod is not a git repo!$OFF"
		ui_press_any
		cd - > /dev/null || exit_msg "$ui_err_invdir" "cd -"
		return 1
	}

	MYDATA="$PWD"/.data
	init_parms
	# Ensure outdir exists after switching repos
	[ -d "$outdir" ] || mkdir -p "$outdir"
	missing_fixes="$outdir/missing_fixes"
	git_get_lasttag lasttag "$last_tag_file"
	return 0
}

# set_remotedir
# @description Set the directory containing upstream remotes
#
# Globals:
# @set remote_dir string Remote directory path (read/write)
# @set remote_repo string Remote repository name (write)
# @set remote_branch string Remote branch name (write)
#
# Effects:
# @stdout Prompts user for directory input
#
# Returns:
# @exitcode 0 On success
#
set_remotedir() {
	local stat
	local b_exists=false

	echo -e "\n$INF Set the directory that contains the remote repo to" \
		"search for missing fixes.$OFF"

	if [ -n "$remote_dir" ]; then
		echo -e "$INF Your current remote directory is: $STA$remote_dir"
		prstr="$INF Enter a new remote directory or press "
		prstr+="$qstr$INF to leave it unchanged : $OFF"
		b_exists=true
	else
		prstr="$INF Enter a new remote directory : $OFF"
		b_exists=false
	fi

	while :; do
		ui_getnewdir "$prstr" remote_dir
		stat=$?

		if ($b_exists && [ $stat -eq 4 ]); then
			return
		else
			if [ $stat -ne 4 ]; then
				break
			else
				echo -e \
				    "${WRN}You must provide an upstream directory.$OFF"
			fi
		fi
	done

	# get the full pathname of the remote directory.
	# If there is no git repo in it, print the tutor to the screen
	# and exit gracefully.
	#
	remote_dir=$(realpath "$remote_dir")
	[ -d "$remote_dir"/.git ] || exit_msg "$ui_err_norepo" "$remote_dir"

	# Changing the remote directory means changing the remote
	# origin/branch, too.
	#
	remote_repo=
	remote_branch=
	set_cfg_item "remote_repo" "$remote_repo"
	set_cfg_item "remote_branch" "$remote_branch"
	set_cfg_item "remote_dir" "$remote_dir"
}

# set_remote_seek
# @description Set the remote origin and branch for seeking missing fixes
#
# Globals:
# @set remote_repo string Remote repository name (read/write)
# @set remote_branch string Remote branch name (read/write)
# @set remote_dir string Remote directory path (read)
#
# Effects:
# @stdout Prompts user for remote repo/branch selection
#
# Returns:
# @exitcode 0 On success
#
set_remote_seek() {
	local remotes=
	local b_set=true
	local remrepo_msg

	remrepo_msg=$(
cat <<EOF
$INF
 Set the upstream origin/branch in: $STA$remote_dir$INF
 to search for any missing fixes.$OFF
EOF
)
	[ -n "$remote_dir" ] || set_remotedir
	echo -e "$remrepo_msg"

	if [ -n "$remote_repo" ] && [ -n "$remote_branch" ]; then
		remotes="$remote_repo/$remote_branch"
		echo -e "$INF Your current remote repo/branch is: $STA$remotes"
		loop_yn "$MNU Do you want to change this? (y/n) : $OFF" b_set
	fi

	if $b_set; then
		pc_cd "$remote_dir"
		select_remrepo remote_repo && select_rembranch "$remote_repo" remote_branch
		cd - > /dev/null || exit_msg "$ui_err_invdir" "cd -"
		set_cfg_item "remote_repo" "$remote_repo"
		set_cfg_item "remote_branch" "$remote_branch"
	fi
}

# check_upstream
# @description Verify upstream directory and remote branch exist
#
# Globals:
# @set remote_repo string Remote repository name (read)
# @set remote_branch string Remote branch name (read)
# @set remote_dir string Remote directory path (read)
#
# Returns:
# @exitcode 0 On success
#
check_upstream() {

	# See if the remote/branch exists. If not, query for them
	cd "$remote_dir" || exit_msg "$ui_err_invdir" "$remote_dir"
	while :; do
		git branch -r | grep -q "$remote_repo/$remote_branch" \
			&& break
		echo -e "${WRN}Cannot find $STA$remote_repo/$remote_branch$WRN"
		echo -e "in remote directory: $STA$remote_dir$OFF"
		set_remote_seek
	done
	cd - > /dev/null || exit_msg "$ui_err_invdir" "cd -"
}

# seek_missing_fixes
# @description Search remote branch for missing commits
#
# Globals:
# @set us_commits string Upstream commits file path (read)
# @set remote_repo string Remote repository name (read)
# @set remote_branch string Remote branch name (read)
# @set remote_dir string Remote directory path (read)
# @set missing_fixes string Missing fixes file path (read/write)
# @set b_verbose bool Verbose output flag (read)
#
# Effects:
# @stdout Prints warning if missing fixes found
#
# Returns:
# @exitcode 0 Always succeeds
#
seek_missing_fixes() {
	[ -d "$remote_dir" ]    || set_remotedir
	[ -n "$remote_repo" ]   || select_remrepo remote_repo
	[ -n "$remote_branch" ] || select_rembranch "$remote_repo" remote_branch
	[ -f "$us_commits" ]    || format_upstream_patches

	check_upstream

	: > "$missing_fixes"
	check_fixes "$us_commits" \
		"$remote_dir" \
		"$remote_repo/$remote_branch" \
		"$missing_fixes" \
		$b_verbose

	[ -s "$missing_fixes" ] && \
	grep -q 'WARNING' "$missing_fixes" && echo -e \
		"${CAU}There are missing fixes listed in $STA$missing_fixes$OFF"
	return 0
}

# test_editor
# @description Test if the chosen editor is installed
#
# Arguments:
# @arg $1 string Name of the editor to test
#
# Effects:
# @stdout Prompts user if editor not found
#
# Returns:
# @exitcode 0 If editor was found and set
# @exitcode 1 If editor was not found
#
test_editor() {
	local _editor_="$1"
	local _noed_
	local _pstr_

	_noed_=\
"$WRN$_editor_$INF is not installed. Do you want to exit and install it now?$OFF"

	_pstr_=\
"${INF}Press '${MNU}y$INF' to exit now or '${MNU}n$INF' to select another editor: $INF"

	which "$_editor_" > /dev/null 2>&1 || {
		echo -e "$_noed_"
		getyn "$_pstr_" && exit_msg "$ui_err_invcmd" "$_editor_"
		return 1
	}

	set_cfg_item editor "$_editor_"
	return 0
}

# set_editor
# @description Select and configure the diff editor
#
# Globals:
# @set editor string Selected editor name (write)
#
# Effects:
# @stdout Displays editor menu and selection prompts
#
# Returns:
# @exitcode 0 Always succeeds
#
set_editor() {
	local choice
	echo -e "${INF}Select one of these currently supported diff editors.$OFF"
	echo -e "$MNU 1 -$OFF vimdiff"
	echo -e "$MNU 2 -$OFF emacs"
	echo -e "$MNU 3 -$OFF tkdiff"

	while true; do
		loop_range 1 3 choice
		case "$choice" in
			1 )	editor="vimdiff";;
			2 )	editor="emacs"	;;
			3 )	editor="tkdiff"
		esac
		test_editor "$editor" && break
	done
	set_cfg_item "editor" "$editor"
	echo -e "${INF}Editor is $STA$editor$OFF\n"
}

# set_colors
# @description Configure terminal color scheme for light or dark background
#
# Globals:
# @set background int Background setting (write)
# @set terminal_background int Terminal background from ui.source (read)
#
# Effects:
# @stdout Displays color selection prompts
#
# Returns:
# @exitcode 0 Always succeeds
#
set_colors() {
	while :; do
		ui_use_colors
		background="$terminal_background"
		set_cfg_item background "$terminal_background"
		echo -en "${INF}You chose "

		case "$terminal_background" in
			1) echo -e "${STA}light$INF background$OFF\n";;
			2) echo -e "${STA}dark$INF background$OFF\n";;
		esac

		if loop_yn_ro "Is that what you want? (y/n) : "; then
			return
		else
			continue
		fi
	done
}

# get_currentfuzz
# @description Get formatted string showing current fuzz level
#
# Arguments:
# @arg $1 int Fuzz level to format
#
# Globals:
# @set patchvalfuzz int Current patch validation fuzz level (read)
#
# Effects:
# @stdout Prints asterisk-prefixed string if current, plain otherwise
#
# Returns:
# @exitcode 0 Always succeeds
#
get_currentfuzz() {
	local fuzz="$1"
	local ast="* $fuzz - "
	local noa="  $fuzz - "

	if ((fuzz == patchvalfuzz)); then
		echo "$ast"
	else
		echo "$noa"
	fi
}

# set_patchvalfuzz
# @description Set the fuzz level for patch validation
#
# Globals:
# @set patchvalfuzz int Current patch validation fuzz level (read/write)
#
# Effects:
# @stdout Displays fuzz level menu and selection prompt
#
# Returns:
# @exitcode 0 Always succeeds
#
set_patchvalfuzz() {
	local fuzz_msg

	fuzz_msg=$(
cat <<EOF
$YEL

  Patches are validated in two steps.

  First, upstream commit hashes in the submitted RHEL patch are looked up.
  Then, the summary line from 'git log --oneline' of the upstream hash is
  compared with the summary line of the submitted RHEL patch. This is done
  to avoid confounding the mention of any other hash in the git log with
  the one being backported.

  Because there can be some differences in the way developers copy the
  upstream summary line, fuzz is sometimes necessary to minimize false
  positives of invalid commits.
$OFF
  Select one of the following fuzz levels. Current level has a leading '*'

  $(get_currentfuzz 0)no fuzz, strictest comparison
  $(get_currentfuzz 1)case insensitive (DEFAULT)
  $(get_currentfuzz 2)case insensitive and ignore commas
  $(get_currentfuzz 3)case insensitive and ignore all punctuation

EOF
)
	echo -e "$fuzz_msg\n"
	loop_range_q 0 3 patchvalfuzz
	set_cfg_item patchvalfuzz "$patchvalfuzz"
}

# show_patchvalfuzz
# @description Display the current patch validation fuzz level description
#
# Globals:
# @set patchvalfuzz int Current patch validation fuzz level (read)
#
# Effects:
# @stdout Prints fuzz level description string
#
# Returns:
# @exitcode 0 Always succeeds
#
show_patchvalfuzz() {
	case "$patchvalfuzz" in
		0 ) echo "0 - no fuzz, strictest comparison"
		    ;;
		1 ) echo "1 - case insensitive (DEFAULT)"
		    ;;
		2 ) echo "2 - case insensitive and ignore commas"
		    ;;
		3 ) echo "3 - case insensitive and ignore all punctuation"
		    ;;
	esac
}

# set_dir
# @description Set a directory variable and save it in the config file
#
# Arguments:
# @arg $1 string Description string for the prompt
# @arg $2 string Config file key for the directory
# @arg $3 string Current directory value (nameref, will be updated)
#
# Effects:
# @stdout Prompts user for directory input
#
# Returns:
# @exitcode 0 Always succeeds
#
set_dir() {
	local dirstr="$1"
	local dircfgkey="$2"
	local -n pdir="$3"
	local b_msgshown=false
	local ndirmsg

	ndirmsg=$(
cat <<EOF
$INF
This directory has not yet been named.
You must provide a directory path for me to continue.
If the path does not exist, I will offer to create it
for you.
$OFF
EOF
)
	[ -n "$pdir" ] && {
		echo -e "${INF}Current $STA$dirstr$INF directory : $STA$pdir$OFF"
		echo -e "${INF}Type $qstr$INF to leave it as it is.$OFF"
	}

	# We can't accept a NULL directory name, so cycle until we get one.
	#
	while :; do
		ui_getnewdir "${INF}New $STA$dirstr$INF directory : $OFF" pdir

		if [ -n "$pdir" ]; then
			[ -d "$pdir" ] || mkdir -p "$pdir"
			break
		else
			$b_msgshown || echo -e "$ndirmsg"
			b_msgshown=true
		fi
	done

	pdir=$(realpath "$pdir")
	set_cfg_item "$dircfgkey" "$pdir"
	echo -e "$INF$dirstr directory is $STA$pdir$OFF\n"
}

# exec_boolean
# @description Execute a command and update a boolean config value
#
# Arguments:
# @arg $1 string Boolean config key name
# @arg $2 bool New value for the boolean
# @arg $3 string Command line to execute
#
# Returns:
# @exitcode * Returns the status of the executed command
#
exec_boolean() {
	local argc=$#
	local argv="$*"
	local stat
	local boolean="$1"
	local b_newval="$2"
	local cmdstr

	cmdstr="$(echo "$argv" | cut -d' ' -f$argc-)"

	$cmdstr
	stat=$?
	# echo "$cmdstr status: $stat"
	if ((stat == 0)); then
		((argc >= 2)) && set_cfg_item "$boolean" "$b_newval"
	else
		echo "$cmdstr"
		echo -e "\tDid not execute successfully"
		echo
	fi
	return $stat
}

# replace_patch
# @description Replace a patch with a corrected commit ID
#
# Globals:
# @set outdir string Output directory path (read)
# @set us_commits string Upstream commits file path (read)
#
# Effects:
# @stdout Prompts user for patch number and commit ID
#
# Returns:
# @exitcode 0 Always succeeds
#
replace_patch() {
	local patnum
	local commit
	local patcnt

	patcnt=$(wc -l < "$us_commits")

	getuser "Patch Number to replace: " patnum
	getuser "Correct commit ID: " commit
	ui_replaceline "$patnum" "$commit $patnum/$patcnt" "$us_commits"
	rm -f "$outdir"/*.patch
	# git_file2patchset "$us_commits" "$outdir"
	git_commit2patch "$patnum" "$commit" "$outdir"
}

# create_commit_msg
# @description Extract commit message from a patch file
#
# Arguments:
# @arg $1 string Pathname of the patch file
# @arg $2 string Output directory (unused, uses global outdir)
#
# Globals:
# @set commit_msg_file string Name of commit message file (read)
# @set outdir string Output directory path (read)
#
# Returns:
# @exitcode 0 Always succeeds
#
create_commit_msg() {
	local diffstr="diff "
	local subjstr="Subject: "
	local found_subj=false
	local commit_msg_path="$outdir/$commit_msg_file"
	local sumstrpos
	local sumstr

	: > "$commit_msg_path"

	while read -r line; do
		[ "${line:0:5}" == "$diffstr" ] && break

		if [ "${line:0:9}" == "$subjstr" ]; then
			sumstrpos=$(($(ui_strindex "$line" "]") + 1))
			sumstr="$(echo -e "${line:$sumstrpos}")"
			echo "$sumstr" >> "$commit_msg_path"
			echo "" >> "$commit_msg_path"
			found_subj=true
		fi
		$found_subj && echo "$line" >> "$commit_msg_path"
	done < "$1"
}

# process_patcherr
# @description Handle patch apply error and prompt for resolution
#
# Arguments:
# @arg $1 string Name of the failed patch
# @arg $2 string Git HEAD reference before patching
#
# Globals:
# @set patchcount int Running count of applied patches (read/write)
# @set applymode int Current apply mode (read)
# @set applyfailmode int Current failure mode setting (read)
#
# Effects:
# @stdout Displays error message and resolution options
#
# Returns:
# @exitcode 0 Always succeeds
#
process_patcherr() {
	local failedpatch="$1"
	local ghead="$2"
	local amresolve

	echo -en "$BLD"
	echo -e "\nPatch: $OFF$failedpatch$BLD"
	echo -e "Failed to apply.$OFF"

	check_already_applied

	if (( applymode != applymode_patch )); then
		echo "Please select one of the following"
		echo "1 - git am --abort"
		echo "2 - git am --quit"
		echo
		loop_range 1 2 amresolve

		case "$amresolve" in
			1 ) git am --abort
			    git reset --hard "$ghead"
			    patchcount=0
			    ;;
			2 ) git am --quit
			    patchcount=$(git log --oneline "$ghead"..HEAD | wc -l)
			    ;;
		esac
	fi

	case "$applyfailmode" in
	    "$applyfailmode_exit" )
		    echo -e "Exiting script ...\n"
		    exit_me 1
		    ;;
	    "$applyfailmode_cont" )
		    echo -e "Continuing without patching...\n"
		    ;;
	    "$applyfailmode_menu" )
		    echo -e "Returning to main menu ...\n"
	esac
}

# use_patch
# @description Apply patches using patch command instead of git am
#
# Arguments:
# @arg $1 string Space-separated list of patch files
#
# Globals:
# @set patchcount int Running tally of applied patches (read/write)
#
# Returns:
# @exitcode * Returns status of last patch operation
#
use_patch() {
	local patchlist="$1"
	local stat=0
	local cmtlog="/dev/shm/cmtlog.txt"

	for patch in $patchlist; do
		((patchcount++))
		# [ $patchcount -ge $startpat ] || continue
		echo "$patch"
		patch --fuzz=3 -p1 < "$patch"
		stat=$?

		((stat == 0)) && {
			git log -n1 --pretty=format:"%s" > "$cmtlog"
			echo -e "\n" >> $cmtlog
			git log -n1 --pretty=medium >> "$cmtlog"
			git commit . -s -F "$cmtlog"
			rm -f "$cmtlog" > /dev/null 2>&1
		}
	done

	return $stat
}

# get_failedpatch
# @description Get the filename of the failed patch
#
# Arguments:
# @arg $1 string List of patches that were being applied
#
# Globals:
# @set patchcount int Running tally of applied patches (read)
# @set applymode int Current apply mode (read)
# @set applymode_patch int Patch mode constant (read)
#
# Effects:
# @stdout Prints the filename of the failed patch
#
# Returns:
# @exitcode 0 Always succeeds
#
get_failedpatch() {
	local patchlist="$1"
	local patcharray=( "$patchlist" )
	local patsub
	local patfil

	if (( applymode == applymode_patch )); then
		echo "${patcharray[$((patchcount - 1))]}"
	else
		patsub="$(git am --show-current-patch | grep -m1 'Subject: ')"
		patsub="$(echo "$patsub" | cut -d'[' -f2 | cut -d']' -f1)"
		patfil="$(grep -l "$patsub" "$patchlist")"
		echo "$patfil"
	fi
}

# map_us2bp
# @description Create mapping of upstream to backported commits
#
# Globals:
# @set bp_commits string Log file of backported commits (read)
# @set us_commits string Log file of upstream commits (read)
# @set usvbp_commits string Output map file (write)
#
# Returns:
# @exitcode 0 Always succeeds
#
map_us2bp() {
	local usline=
	local bpline=
	local b_done=false

	: > "$usvbp_commits"

	# Create two file descriptors for the upstream and backported logs.
	exec 5<"$us_commits"
	exec 6<"$bp_commits"

	until $b_done; do
		read -ru 5 usline || b_done=true
		read -ru 6 bpline || b_done=true

		usline="$(echo "$usline" | cut -d' ' -f1)"

		$b_done || echo -n "$usline " >> "$usvbp_commits"
		$b_done || echo "$bpline" >> "$usvbp_commits"
	done

	exec 5<&-
	exec 6<&-
}

# apply_patches
# @description Apply patches from indir using configured apply mode
#
# Globals:
# @set indir string Input directory containing patches (read)
# @set patchcount int Running count of applied patches (read/write)
# @set patchtotal int Total patches to apply (write)
# @set bp_commits string Backported commits log file (read/write)
# @set applymode int Apply mode setting (read)
# @set applyfailmode int Failure mode setting (read)
# @set startpat int Starting patch number (read)
# @set valpatchlist string Validated patch list (read/write)
# @set b_allapplied bool All patches applied flag (write)
#
# Returns:
# @exitcode 0 On success
# @exitcode 1 On failure
#
apply_patches() {
	# echo -e "\n$BLD\0patch-common::apply_patches()$OFF"
	local stat=0
	local patchlist

	patchlist="$(ls -1 "$indir"/*.patch)"

	create_patchlist "$patchlist" valpatchlist "$startpat"
	patchtotal=$(wc -w <<< "$valpatchlist")

	((applymode == applymode_off)) && return 0
	: > "$bp_commits"

        [ "$valpatchlist" ] || {
		echo -e "$WRN\nIt appears there are no valid patches to apply.\n$OFF"
		return 1
	}

	case "$applymode" in
	    "$applymode_norm"  ) git am "$valpatchlist"    ; stat=$? ;;
	    "$applymode_3way"  ) git am -3 "$valpatchlist" ; stat=$? ;;
	    "$applymode_patch" ) use_patch "$valpatchlist" ; stat=$? ;;
	esac

	((stat == 0)) || process_patcherr "$(get_failedpatch "$valpatchlist")"

	# Create the log of commits backported.
	patchcount=$(find "$indir" -maxdepth 1 -name "*.patch" | wc -l)
	git log --oneline -n"$patchcount" > "$bp_commits"
	map_us2bp

	if ((stat == 0)); then b_allapplied=true; else tail -1 "$bp_commits"; fi
	return $stat
}

# show_discrete_ops
# @description Display the discrete operations menu option
#
# Globals:
# @set menumode int Current menu mode (read)
# @set menumode_ext int Extended menu mode constant (read)
# @set menumode_min int Minimal menu mode constant (read)
#
# Effects:
# @stdout Prints menu option to show/hide discrete operations
#
# Returns:
# @exitcode 0 Always succeeds
#
show_discrete_ops() {
	echo -en "$MNU x$OFF  "
	case "$menumode" in
		"$menumode_ext" ) echo -en "Hide " ;;
		"$menumode_min" ) echo -en "Show ";;
	esac
	echo -e "$MNU${UND}Discrete Operations$OFF Menu"
}

# show_colors
# @description Display whether colors are enabled
#
# Globals:
# @set b_color bool Color enabled flag (read)
#
# Effects:
# @stdout Prints ON or OFF
#
# Returns:
# @exitcode 0 Always succeeds
#
show_colors() {
	if $b_color; then echo -e "ON"; else echo -e "OFF"; fi
}

# show_verbose
# @description Display the current verbose setting
#
# Globals:
# @set b_verbose bool Verbose flag (read)
#
# Effects:
# @stdout Prints verbose ON or OFF
#
# Returns:
# @exitcode 0 Always succeeds
#
show_verbose() {
	if $b_verbose; then
		echo -e "${MNU}verbose is$STA ON$OFF"
	else
		echo -e "${MNU}verbose is$STA OFF$OFF"
	fi
}

# show_patches
# @description Display the patches directory and file count
#
# Globals:
# @set indirstr string Input directory description (read)
# @set indir string Input directory path (read)
# @set infilecount int Number of files in input directory (read)
# @set patstr string Patch string prefix (read)
#
# Effects:
# @stdout Prints formatted directory and file count
#
# Returns:
# @exitcode 0 Always succeeds
#
show_patches() {
	echo -en "$MNU d$OFF  $indirstr directory"
	printf "%*c" $((15 - ${#indirstr})) " "
	echo -e  ":$STA $indir$OFF has $STA$infilecount$OFF ${patstr}files."
}

# show_workdir
# @description Display the work directory path
#
# Globals:
# @set outdirstr string Output directory description (read)
# @set outdir string Output directory path (read)
#
# Effects:
# @stdout Prints formatted work directory path
#
# Returns:
# @exitcode 0 Always succeeds
#
show_workdir() {
	echo -en "$MNU w$OFF  $outdirstr directory"
	printf "%*c" $((15 - ${#outdirstr})) " "
	echo -e ":$STA $outdir"
}

# show_cmpmode
# @description Display the current comparison mode
#
# Globals:
# @set cmpmode int Current comparison mode (read)
# @set cmpmode_off int Off mode constant (read)
# @set cmpmode_batch int Batch mode constant (read)
# @set cmpmode_inter int Interactive mode constant (read)
# @set cmpmode_setup int Setup mode constant (read)
#
# Effects:
# @stdout Prints comparison mode description
#
# Returns:
# @exitcode 0 Always succeeds
#
show_cmpmode() {

	case "$cmpmode" in
	    "$cmpmode_off"   )	echo "OFF" ;;
	    "$cmpmode_batch" )	echo "Batch" ;;
	    "$cmpmode_inter" )	echo "Interactive Only" ;;
	    "$cmpmode_setup" )	echo "Batch compare setup" ;;
		           * )	echo "Not a valid comparison mode" ;;
	esac
}

# show_applymode
# @description Display the current apply mode
#
# Globals:
# @set applymode int Current apply mode (read)
# @set applymode_off int Off mode constant (read)
# @set applymode_norm int Normal mode constant (read)
# @set applymode_3way int 3-way mode constant (read)
# @set applymode_patch int Patch mode constant (read)
#
# Effects:
# @stdout Prints apply mode description
#
# Returns:
# @exitcode 0 Always succeeds
#
show_applymode() {

	case "$applymode" in
	    "$applymode_off"   )	echo "OFF" ;;
	    "$applymode_norm"  )	echo "git am" ;;
	    "$applymode_3way"  )	echo "git am 3-way merge" ;;
	    "$applymode_patch" )  echo "patch --fuzz=3 -p1 <" ;;
	                     * )	echo "Not a valid apply mode" ;;
	esac
}

# show_applyfailmode
# @description Display the current apply failure mode
#
# Globals:
# @set applyfailmode int Current failure mode (read)
# @set applyfailmode_exit int Exit mode constant (read)
# @set applyfailmode_cont int Continue mode constant (read)
# @set applyfailmode_menu int Menu mode constant (read)
#
# Effects:
# @stdout Prints failure mode description
#
# Returns:
# @exitcode 0 Always succeeds
#
show_applyfailmode() {

	case "$applyfailmode" in
	    "$applyfailmode_exit" ) echo "Exit" ;;
	    "$applyfailmode_cont" ) echo "Continue without applying" ;;
	    "$applyfailmode_menu" ) echo "Return to main menu" ;;
	                        * ) echo "Not a valid failover mode" ;;
	esac
}

# show_view_logs
# @description Display menu option to view log files if any exist
#
# Globals:
# @set outdir string Output directory path (read)
#
# Effects:
# @stdout Prints menu option if log files exist
#
# Returns:
# @exitcode 0 Always succeeds
#
show_view_logs() {
	local logs

	logs=$(ls -1 "$outdir"/*.log 2> /dev/null)

	[  "$logs" ] && echo -e "\n$MNU V$OFF  View the log files"
}

# view_logs
# @description Display and allow selection of log files to view
#
# Globals:
# @set outdir string Output directory path (read)
#
# Effects:
# @stdout Displays log file menu and selected log content
#
# Returns:
# @exitcode 0 Always succeeds
#
view_logs() {
	local logs
	local logfile
	local index=1
	local choice

	mapfile -t logs < <(find "$outdir" -type f -name "*.log")
	((${#logs[@]} != 0)) || {
		echo -e "\n${INF}There are currently no log files.$OFF"
		return
	}

	echo -e "\n${MNU}Select the log file you wish to view.$OFF\n"
	for logfile in "${logs[@]}"; do
		echo -e "$MNU$index$OFF - $logfile"
		((++index))
	done
	echo

	loop_range_q 1 $((index - 1)) choice || return

	less "${logs[$((choice - 1))]}"
}

# get_filecount
# @description Count files in the input directory
#
# Globals:
# @set indir string Input directory path (read)
# @set infilecount int Number of files counted (write)
# @set patstr string Patch string for display (write)
# @set b_selpat bool Whether patches are selectable (write)
# @set b_allapplied bool All patches applied flag (read)
# @set b_rename_infiles bool Rename input files flag (write)
#
# Returns:
# @exitcode 0 Always succeeds
#
get_filecount() {
	local fc

	fc=$(find "$indir" -maxdepth 1 -type f -name "*.patch" -print -quit)
	if [ "$fc" ]; then
		infilecount=$(find "$indir" -maxdepth 1 -type f -name "*.patch" | wc -l)
		! $b_allapplied && b_selpat=true || b_selpat=false
		patstr="patch "
		b_rename_infiles=false
	else
		infilecount=$(find "$indir" -maxdepth 1 -type f | wc -l)
		patstr=""
		b_selpat=false
		b_rename_infiles=true
	fi
}

# show_nextpatch
# @description Display starting patch option if applicable
#
# Globals:
# @set infilecount int Number of input files (read)
# @set b_allapplied bool All patches applied flag (read)
# @set b_selpat bool Patches selectable flag (write)
# @set startpat int Starting patch number (read)
# @set patstr string Patch string prefix (read)
#
# Effects:
# @stdout Prints starting patch option or applied status
#
# Returns:
# @exitcode 0 Always succeeds
#
show_nextpatch() {
	local shownext=

	shownext=$(
cat <<EOF
$MNU
 5$OFF  Start applying at patch  :$STA $startpat$OFF
EOF
)
	((infilecount == 0)) && { b_selpat=false; return; }

	$b_allapplied && {
		echo -e "\n$INF    All patches were successfully applied$OFF"
		return
	}

	[ "$patstr" ] && echo -e "$shownext"
}

# show_apply_patches
# @description Display the apply patches menu option with status
#
# Globals:
# @set applymode int Current apply mode (read)
# @set applymode_off int Off mode constant (read)
# @set b_allapplied bool All patches applied flag (read)
#
# Effects:
# @stdout Prints apply patches option with current status
#
# Returns:
# @exitcode 0 Always succeeds
#
show_apply_patches() {
	echo -en "\n$MNU A$OFF  Apply patches"

	if ((applymode == applymode_off)) && $b_allapplied; then
		echo -en "            :$OFF "
		echo -en "already applied and apply mode ${STA}OFF${OFF}"
	elif ((applymode == applymode_off)) && ! $b_allapplied; then
		echo -en "            :$OFF "
		echo -en "apply mode is ${STA}OFF$OFF"
	elif ((applymode != applymode_off)) && $b_allapplied; then
		echo -en "            :$OFF "
		echo -en "already applied"
	fi
}

# select_patch
# @description Select a patch to start the apply process
#
# Globals:
# @set patstr string Patch string prefix (read)
# @set infilecount int Number of input files (read)
# @set startpat int Starting patch number (read/write)
#
# Effects:
# @stdout Prompts for patch selection
#
# Returns:
# @exitcode 0 Always succeeds
#
select_patch() {

	[ "$patstr" ] || {
		echo "Please run the rename on the files first."
		return
	}

	loop_range_q 1 "$infilecount" startpat ||
		echo "Leaving starting patch at $startpat."
	return
}

# show_branch_mismatch
# @description Display branch/distro mismatch and prompt to switch
#
# Arguments:
# @arg $1 string Current distro name
# @arg $2 string Nameref for user's y/n response
#
# Globals:
# @set lasttag string Last tag string (read/write)
# @set last_tag_file string Last tag file path (read)
# @set branchlist string Branch list file path (read)
#
# Effects:
# @stdout Displays mismatch warning and switch prompt
#
# Returns:
# @exitcode 0 Always succeeds
#
show_branch_mismatch() {
	local _distro_="$1"
	local -n _yn_="$2"

	echo -e "$BLD\0Patches are$OFF $_distro_$BLD but kernel is$OFF $lasttag"
	doyn "Switch branches now?" "git_setbranch $branchlist" "" _yn_
	$_yn_ && git_get_lasttag lasttag "$last_tag_file"
}

# check_patchvbranch
# @description Verify patch names match the current kernel branch
#
# Globals:
# @set indir string Input directory containing patches (read)
# @set lasttag string Last tag string (read)
# @set el6 string EL6 identifier (read)
# @set el7 string EL7 identifier (read)
# @set el8 string EL8 identifier (read)
# @set el9 string EL9 identifier (read)
#
# Effects:
# @stdout Displays mismatch warnings if any
#
# Returns:
# @exitcode 0 On success or user continues
# @exitcode 1 On no patches or user cancellation
#
check_patchvbranch() {
	local pat
	local subject
	local pfx
	local dist
	local distname="NOT RHEL"
	local tag
	local elstr=""
	local yn=false
	local -i i
	local -i j
	local ary
	local b_pegas=false

	[ "$indir" ] || return 1

	# See if there are any .patch files in the $indir
	#
	stat "$indir"/*.patch > /dev/null 2>&1 || {
		echo -e "\nNo .patch files in $BLD$indir$OFF"
		ui_press_any
		return 1
	}

	# Get the subject line from the first patch and remove "Subject:"
	pat="$(find "$indir" -type f -name "*.patch" | head -1)"
	subject="$(grep 'Subject: ' -m1 i"$pat")"
	subject=${subject//"Subject: "/}

	# Convert to upper case
	pfx="$(echo "$subject" | tr '[:lower:]' '[:upper:]')"

	# Remove the word PATCH if it's there
	pfx="${pfx//"PATCH"/}"

	# The Prefix must begin with a 'RHEL'. If it does not, then advise
	# the user and offer to run anyway, or return to the main menu.
	i=$(ui_strindex "$pfx" "RHEL")

	# Find the end of the RHEL prefix at the right bracket.
	j=$(ui_strindex "$pfx" "]")

	# echo "i: $i j: $j"
	if ((i < 0)) || ((j <= 0)) || ((j <= i)); then
		echo -e "$STA$subject$OFF"
		echo -e "${WRN}...does not appear to be a RHEL patch or series$OFF"
		getyn "Do you wish to continue anyway?" yn
		$yn || return 1
		distname="NOT RHEL"
		elstr=""
	else
		# Extract the patch prefix between the brackets.
		pfx="${pfx:$i:$((j-i))}"
		# echo "pfx extracted: $pfx"

		# If there is "alt" anywhere in the prefix, then set the
		# pegas flag.
		[[ "$pfx" = *"ALT"* ]] && b_pegas=true

		# If it exists, remove the "ALT" string to get the basic distro.
		$b_pegas && dist="${pfx//ALT/}" || dist="$pfx"

		# Replace hyphens with spaces and remove any extraneous spaces.
		dist="$(tr -s "-" " " <<< "$dist")"

		# Tokenize the dist so we can extract just the RHEL and its
		# version numbers.
		ui_strtok "$dist" " " ary
		# echo "dist: \"$dist\" ary: ${ary[@]}"

		# If the first token in the array only has 4 chars, then it is
		# "RHEL" without the version numbers. In this case, the second
		# token will have the version.
		[ ${#ary[0]} -eq 4 ] && dist=${ary[0]}${ary[1]} || dist=${ary[0]}

		# echo "dist: $dist"
		case "${dist:0:5}" in
			"RHEL6" ) elstr="$el6" ; distname="$dist" ;;
			"RHEL7" ) elstr="$el7" ; distname="$dist" ;;
			"RHEL8" ) elstr="$el8" ; distname="$dist" ;;
			"RHEL9" ) elstr="$el9" ; distname="$dist" ;;
			      * ) elstr=""     ; distname="NOT RHEL" ;;
		esac

		$b_pegas && distname="${distname}-ALT" && elstr="${elstr}a"
	fi

	# Tokenize the current kernel branch tag.
	#
	ui_strtok "$lasttag" ".-" tag

	# 2020-10-05
	# Cycle through the tag array looking for elstr. It is not
	# necessarily the last token anymore.
	#
	for ((i = 0; i < ${#tag[@]}; ++i)); do
		[ "${tag[i]}" == "$elstr" ] && break
	done

	# If we went through the loop and didn't find the elstr, then the
	# script thinks that we do not have a match between the patches and
	# the current branch. In that case, see whether the user wants to
	# choose a different branch or apply the patches to the current
	# branch, regardless.
	#
	(( i < ${#tag[@]} )) ||  show_branch_mismatch "$distname" yn

	# If user did not opt to switch branches, then user wants to apply
	# patches to current branch, even when they appear to the script
	# to be mismatched.
	# If the user did switch branches, call this routine recursively to
	# see if s/he chose the correct branch.
	#
	$yn && check_patchvbranch

	return 0
}

# get_current_head_trunc
# @description Get current git HEAD truncated to fit terminal width
#
# Arguments:
# @arg $1 int Number of columns already used
#
# Globals:
# @set tcols int Terminal columns from ui.source (read)
#
# Effects:
# @stdout Prints truncated HEAD commit string
#
# Returns:
# @exitcode 0 Always succeeds
#
get_current_head_trunc() {
	local used=$1
	local cols=$((tcols-used))
	local current_head=
	local current_head_trunc=

	current_head="$(git log --oneline -n1)"
	current_head_trunc="${current_head:0:$cols}"
	echo "$current_head_trunc"
}

# create_branch
# @description Create a new branch at the current HEAD
#
# Effects:
# @stdout Prompts for branch and tag names
#
# Returns:
# @exitcode 0 Always succeeds
#
create_branch() {
	local bname=
	local tagname=
	local current_head_trunc=
	local brstr=

	current_head_trunc=$(get_current_head_trunc 23)
	brstr=$(
cat <<EOF

Create new branch at: $BLD$current_head_trunc$OFF
Press ${BLD}ENTER$OFF or $qstr at the naming prompts to \
quit without applying the change.
\0
EOF
)
	echo -e "$brstr"
	getuser "Name of the new branch: " bname
	[[ "qQ" == *"$bname"* ]]  && return
	git branch "$bname"
	echo -e "Created branch $BLD$bname$OFF"
	getuser "New tag name: " tagname
	[[ "qQ" == *"$tagname"* ]] || git tag "$tagname"
}

# format_upstream_patches
# @description Create upstream patches from commit list in input directory
#
# Globals:
# @set indir string Input directory containing patches (read)
# @set outdir string Output directory for formatted patches (read)
# @set us_commits string Upstream commits file path (read/write)
# @set b_fmt_upstream bool Format upstream flag (read)
# @set remote_dir string Remote directory path (read)
# @set b_verbose bool Verbose output flag (read)
# @set patchvalfuzz int Patch validation fuzz level (read)
# @set missing_fixes string Missing fixes file path (write)
#
# Returns:
# @exitcode 0 On success
# @exitcode 1 On failure or no patches to review
#
format_upstream_patches() {
	$ui_b_debug && echo -e "${STA}format_upstream_patches$OFF"
	local fc=	# $(find $outdir -maxdepth 1 -not -type d -name "*.patch" -print -quit)
	local b_yup
	local banner=
	local pad=
	local escnt=
	local stat=0
	local quiet=

	$b_verbose || quiet="-q"

	fc=$(find . "$outdir" -maxdepth 1 -type f -name "*.patch" -print -quit)

	[ "$fc" ] && {
		echo
		echo -e "${INF}There are already upstream patch files in $STA$outdir$OFF"
		getyn "Do you want to replace them? " b_yup

		if $b_yup; then
			rm -f "$outdir"/* > /dev/null 2>&1
			: > "$missing_fixes"
		else
			return 1
		fi
	}

	ls "$indir"/*.patch > /dev/null 2>&1 || {
		echo
		echo -e "${INF}There are no patch files to review in $STA$indir$OFF"
		return 1
	}

	rm -f "$outdir"/*.patch > /dev/null 2>&1
	: > "$us_commits"
	echo

	git_comment2commitsfile \
		-r "$remote_dir" -i "$indir" -o "$us_commits" -f "$patchvalfuzz" $quiet
	stat=$?
	echo
	[ $stat -eq 0 ] || {
		echo -en "$WRN${ui_err_msg[$stat]}"
		case $stat in
			"$ui_err_invdir" )  echo -e " : $STA$indir$OFF";;
			"$ui_err_invfile" ) echo -e " : $STA$us_commits$OFF";;
		esac
		return 1
	}

	if $b_verbose; then
		banner="${INF}Upstream commits extracted from the patches in $STA$us_commits$INF"
		escnt=$((${#INF} + ${#STA} + ${#INF}))
		pad=$(ui_putnchar '=' $(( ${#banner} - escnt)))
		echo -e "$banner\n$pad$OFF"

		cat "$us_commits"
		echo
	fi

	(
	cd "$remote_dir" > /dev/null || exit_msg "$ui_err_invdir" "$remote_dir"
	exec_boolean b_fmt_upstream false \
		"git_file2patchset ${us_commits} ${outdir} ${b_verbose}"
	)
	return 0
}

# check_already_applied
# @description Check if commits have already been applied
#
# Globals:
# @set us_commits string Upstream commits file path (read)
# @set usvbp_commits string Upstream vs backported commits map (read)
# @set bp_commits string Backported commits file path (read)
#
# Effects:
# @stdout Displays already-applied commits if any
#
# Returns:
# @exitcode 0 If some commits already applied
# @exitcode 1 If no commits file or none applied
#
check_already_applied() {
	local usline
	local usvbpline
	local uscommit
	local bpcommit
	local linecnt=20	# just a guess for now.
	local promptresp
	local b_done=false
	local b_header=true
	local header=

	header=$(
cat <<EOF
$INF
The backported commits log $STA$bp_commits$OFF$INF is not empty.
It's possible that some of them have already been applied.
Press "$MNU"'i' (init)$INF at the main menu to remove the commits log.$OFF

Upstream       RHEL commit
------------   ------------
EOF
)
	local moreprompt=\
"${INF}If you've seen enough press$OFF $qstr$INF, else any other key to see more: $OFF"

	# if there's nothing in the us v bp commit map, just return
	#
	[ -s "$usvbp_commits" ] || return 0

	exec 5<"$us_commits"

	until $b_done; do
		read -r -u 5 usline || b_done=true
		uscommit="$(echo "$usline" | cut -d' ' -f1)"
		(( 16#$uscommit )) || continue
		echo -n "$uscommit"
		usvbpline="$(grep -m1 "$uscommit" "$usvbp_commits")"

		if [ -n "$usvbpline" ]; then
			ui_clearline

			if [ $linecnt -ge $((tlines - 2)) ]; then
				linecnt=1
				promptgetchar "$moreprompt" promptresp
				if [ "$promptresp" == "q" ]; then
					b_done=true
					continue
				fi

			fi

			bpcommit="$(echo "$usvbpline" | cut -d' ' -f2-)"

			if $b_header; then
				b_header=false
				echo -e "$header"
			fi

			echo "${uscommit:0:12}""   ""$bpcommit"
			((++linecnt))
		else
			ui_clearline
		fi
	done

	exec 5<&-
	echo
	return 1
}

# exec_apply_patches
# @description Apply patches with front-end housekeeping
#
# Globals:
# @set patchcount int Patch count (write)
# @set applymode int Apply mode (read/write)
# @set applyfailmode int Failure mode (read)
# @set applyfailmode_menu int Menu mode constant (read)
#
# Returns:
# @exitcode 0 On success
# @exitcode * Non-zero if patches fail to apply
#
exec_apply_patches(){
	local stat

	git am --abort 2>/dev/null
	patchcount=0

	check_patchvbranch || return 1

	apply_patches; stat=$?
		if ((stat != 0)) && ((applyfailmode == applyfailmode_menu)); then
			return $stat
		fi

	applymode=$applymode_off
	set_cfg_item "applymode" $applymode

	return 0
}

# examine_patches
# @description Examine patches using patcmp with mismatch file
#
# Globals:
# @set terminal_background int Terminal background setting (read)
# @set mmfile string Mismatch file path (read)
# @set us_commits string Upstream commits file path (read)
# @set b_verbose bool Verbose flag (read)
# @set remote_dir string Remote directory path (read)
# @set indir string Input directory path (read)
# @set outdir string Output directory path (read)
# @set editor string Editor name (read)
#
# Returns:
# @exitcode 0 Always succeeds
#
examine_patches() {
	local tb=$terminal_background
	local quiet=

	[ -f "$mmfile" ] || { compare_patches; return 0; }
	[ -f "$us_commits" ] || { compare_patches; return 0; }

	$b_verbose || quiet="-q"
	patcmp $quiet -b "$tb" -m "$mmfile" -u "$remote_dir" \
		"$indir" "$outdir" "$editor" "$us_commits"
}

# exec_patcmp
# @description Execute patch comparison using patbatcmpmgr
#
# Arguments:
# @arg $1 string Optional "-X" for batch mode execution
#
# Globals:
# @set indir string Input directory path (read)
# @set outdir string Output directory path (read)
# @set mmfile string Mismatch file path (read)
# @set us_commits string Upstream commits file path (read)
# @set editor string Editor name (read)
# @set patchtotal int Total patch count (write)
# @set terminal_background int Terminal background setting (read)
# @set valpatchlist string Validated patch list (read/write)
# @set b_verbose bool Verbose flag (read)
# @set b_reviewed bool Reviewed flag (read)
#
# Returns:
# @exitcode * Returns status from patcmp
#
exec_patcmp() {
	$ui_b_debug && echo -e "${STA}patch-common::exec_patcmp$OFF"
	local xval="$1"
	local patchlist=
	local tb=$terminal_background
	local quiet=

	patchlist="$(ls -1 "$indir"/*.patch)"
	$b_verbose || quiet="-q"

	# If we don't have a valid patch list, create one now.
	#
	[ "$valpatchlist" ] || create_patchlist "$patchlist" valpatchlist
	patchtotal=$(wc -w <<< "$valpatchlist")

# echo "indir: $indir  outdir: $outdir"
# echo "patchtotal: $patchtotal"
# echo "patchlist:"
# echo "${patchlist[@]}"
# echo
# echo "valpatchlist:"
# echo "${valpatchlist[@]}"
# echo "b_reviewed: $b_reviewed"
# ui_press_any

	# If the mmfile does not contain the same number of patches
	# as the infilecount, then go make the mmfile.
	#
	if [ "$xval" ]; then

		$b_reviewed ||
			patbatcmpmgr -P "$valpatchlist" -R "$indir" -U "$outdir" \
				     -o "$mmfile" "$xval" -b "$tb"
	else

		patbatcmpmgr -X -P "$valpatchlist" \
			-R "$indir" -U "$outdir" -o "$mmfile" -b "$tb"
	fi
	patcmp $quiet -b "$tb" -m "$mmfile" -u "$remote_dir" \
		"$indir" "$outdir" "$editor" "$us_commits"

	return $?
}

# compare_patches
# @description Compare downstream patches with upstream using configured mode
#
# Globals:
# @set cmpmode int Comparison mode (read/write)
# @set cmpmode_batch int Batch mode constant (read)
# @set cmpmode_setup int Setup mode constant (read)
# @set cmpmode_inter int Interactive mode constant (read)
# @set cmpmode_off int Off mode constant (read)
# @set terminal_background int Terminal background setting (read)
# @set b_verbose bool Verbose flag (read)
#
# Returns:
# @exitcode * Returns status from comparison
#
compare_patches() {
	local tb=$terminal_background
	local stat=

	local quiet=

	$b_verbose || quiet="-q"

	case $cmpmode in
		"$cmpmode_batch" ) exec_patcmp "-X"; stat=$? ;;
		"$cmpmode_setup" ) exec_patcmp; stat=$? ;;
		"$cmpmode_inter" ) patcmp $quiet -b "$tb" \
				   "$indir" "$outdir" "$editor" "$us_commits"
				   stat=$? ;;
			       * ) cmpmode=$cmpmode_off
	esac

	return $stat
}

# init_menu
# @description Initialize menu loop with default global values
#
# Globals:
# @set applymode int Apply mode (write)
# @set patchcount int Patch count (write)
# @set startpat int Starting patch (write)
# @set b_fmt_upstream bool Format upstream flag (write)
# @set b_allapplied bool All applied flag (write)
# @set b_mrflag bool Merge request flag (write)
# @set opmode int Operation mode (read)
# @set opmode_mr int MR mode constant (read)
# @set usvbp_commits string Upstream vs backported commits file (read)
# @set current_mr string Current merge request (write)
# @set indir string Input directory (read)
# @set outdir string Output directory (read)
#
# Returns:
# @exitcode 0 Always succeeds
#
init_menu() {
	init_booleans
	get_booleans
	applymode=$applymode_norm
	set_cfg_item applymode $applymode
	patchcount=0
	startpat=1
	b_fmt_upstream=true
	b_allapplied=false
	if ((opmode == opmode_mr)); then b_mrflag=true; else b_mrflag=false; fi
	[ -f "$usvbp_commits" ] && rm -f "$usvbp_commits"
	if $b_mrflag; then
		current_mr=
		rm -f "$indir"/* >/dev/null
		rm -f "$outdir"/* >/dev/null
	fi
}

# check_patch_count
# @description Verify patch file count matches series denominator
#
# Globals:
# @set rensetcnt int Number of patches claimed in series (read)
# @set renpatcnt int Actual number of patch files (read)
#
# Effects:
# @stdout Displays mismatch warning if counts differ
#
# Returns:
# @exitcode 0 If counts match or user continues
# @exitcode 1 If user cancels
#
check_patch_count() {
	local b_cont
	local miscntmsg=

	miscntmsg=$(
cat <<EOF

There are $BLD$renpatcnt$OFF patch files, but the series claims
to have $BLD$rensetcnt$OFF patches.
EOF
)
	if ((renpatcnt > 1)) && ((rensetcnt > 0)); then return 0; fi

	if ((renpatcnt == rensetcnt)); then
		return 0
	else
		echo -e "$miscntmsg"
		getyn "Do you want to continue anyway? " b_cont
		$b_cont && return 0 || return 1
	fi
}

# renpatfiles
# @description Rename email patch files to sequential numbered format
#
# Globals:
# @set indir string Directory containing patches (read)
# @set renpatcnt int Number of patches renamed (write)
# @set rensetcnt int Number of patches in series (write)
#
# Effects:
# @stdout Displays rename progress
#
# Returns:
# @exitcode ui_err_nofiles If no files to rename
# @exitcode * Returns value from check_patch_count
#
renpatfiles() {

    declare -i total
    declare -i windex	# index of word in subj prefix having '/' in it
    declare -i fldwid=0	# width of the field having total number of patches
    declare -a pfxary	# tokenized subject line
    declare -a wary	# word having '/' in it tokenized
    declare subject
    declare word
    declare iszero=false
    declare patnum
    declare pfx		# subject prefix, stuff between the [ and ]

    rensetcnt=0		# globally declared in this file
    renpatcnt=0		# :

    cd "$indir" > /dev/null || exit_msg "$ui_err_invdir" "$indir"
    echo -e "${INF}Changing directory to $STA$PWD$OFF"
    total=$(find . -maxdepth 1 -type f | wc -l)
    echo -e "$STA$PWD$INF has $STA$total$INF files.$OFF"

    if ((total == 0)); then
	echo -e "$STA$indir$INF has no files to rename.$OFF"
	echo -en "${INF}Returning to main menu. and repo directory: $STA"
	cd - > /dev/null || exit_msg "$ui_err_invdir" "cd -"
	echo -en "$OFF"
	return $ui_err_nofiles
    fi

    ui_remove_spaces

    # Don't try to rename files that have ".patch" endings, because
    # these have already been renamed.
    #
    while IFS= read -r -d '' filename; do
	iszero=false
	word=""
	windex=0

	# Extract the subject line.
	#
	subject=$(grep -m1 "Subject: " "$filename")

	# Remove any asterisks from the subject line.
	#
	subject=$(sed 's/\*//g' <<< "$subject")

	# Remove the word "Subject: " from the line
	#
	subject=$(echo "$subject" | cut -d' ' -f2-)

	# If the next character is not '[', then it is not a patch.
	#
	[ "${subject:0:1}" == "[" ] || continue

	# Remove any version numbers from within the brackets. There is no
	# standard on where the patch version number appears, so the patch
	# can be out of order.
	#
	# Find the right bracket to isolate the text within the brackets.
	# If we don't find a right bracket in the subject line, then continue
	# to the next file.
	#
	rb_pos=$(ui_strindex "$subject" "]")
	((rb_pos < 0)) && continue

	# extract the bracketed prefix substring and remove any version numbers
	#
	pfx="${subject:1:$((rb_pos-1))}"
	new="$(echo "$pfx" | sed 's/v\w//i')"

	# Substitute the new prefix for the old in the subject string.
	#
	subject="${subject/"$pfx"/"$new"}"

	# If there is no / in the subject prefix, then it is not a series.
	#
	if [[ $new == *"/"* ]]; then

	    # Tokenize the subject prefix.
	    # Look for the first token with a '/' in it.  If all the
	    # characters leading up to the '/' are zero, then it is a
	    # prologue, not a patch.
	    #
	    ui_strtok "$new" " " pfxary
	    for ((i = 0; i < ${#pfxary[@]}; i++)); do
		    word=${pfxary[$i]}
		    [[ $word == *"/"* ]] && windex=$i && break
	    done

	    # The zeroth patch is the prologue, so skip it.
	    #
	    for ((i = 0; i < ${#word}; i++)); do
		    [[ ${word:$i:1} == "/" ]] && break
		    [[ ${word:$i:1} != "0" ]] && iszero=false && break
		    [[ ${word:$i:1} == "0" ]] && iszero=true
	    done

	    $iszero && continue

	    # Some posters do not provide padding zeroes in their PATCH
	    # n/m subject lines. This will cause out-of-order
	    # processing, since 1/n will be immediately followed by
	    # 10/n, 11/n, etc. Padding the first number with leading
	    # zeroes will preclude this.
	    #
	    # If we found a "/" in the subject string, then windex is
	    # nonzero.  In that case, we need to determine the correct
	    # number of padding zeroes required in the first number.
	    #
	    if ((windex > 0)); then

		# Tokenize the word with the "/" in it. We need to
		# pad the leading number with zeroes to make it the
		# same width as the number of patches in the set.
		# Including the brackets in the delimiter will strip
		# them from the word.
		#
		ui_strtok "$word" "[/]" wary

		# We only need to do this once per patchset
		#
		if ((fldwid == 0)); then

		    # The total number of patches is in the
		    # second word of the wary stripped of any
		    # non-alphanumeric chars.
		    #
		    rensetcnt="${wary[1]}" # | sed 's/:[][<>(),"//g')"

		    # Determine the fieldwidth of the total
		    # number of patches.
		    #
		    fldwid=${#rensetcnt}
		fi

		# Determine the fieldwidth of the patch number and pad it
		# with leading zeroes if necessary.
		#
		patnum="${wary[0]}"
		for ((j = fldwid - ${#patnum}; j > 0; --j )); do
		    wary[0]="0${wary[0]}"
		done

		# Replace the patch's n/m with the new padded n/m word.
		# The new word will have a space where there was a '/', but
		# that will be handled when we strip the non-alphanumeric
		# characters from the subject string.
		#
		pfxary[$windex]="${wary[*]}"
		subject="${pfxary[*]}-${subject:$rb_pos}"
	    fi
	fi

	# Replace non-alphanumerics with a hyphen, then delete any leading
	# and trailing hyphens.
	#
	for s in punct space; do subject="${subject//[[:%s:]]/-}"; done
	subject="${subject##+(-)}"
	subject="${subject%%+(-)}"

	newname="$subject.patch"

	# See if we already have one of these, if so, skip it.
	#
	[ -f "$newname" ] && continue

	echo "mv $filename -> $newname"
	mv "$filename" "$newname"
	((renpatcnt++))
    done < <(find . -maxdepth 1 -type f -not -name "*.patch" -print0)

    cd - > /dev/null || exit_msg "$ui_err_invdir" "cd -"
    check_patch_count
    return $?
}

# find_filebynumber
# @description Find a file by its leading zero-padded number
#
# Arguments:
# @arg $1 string File number (may be in n/total format)
# @arg $2 string Directory to search
#
# Effects:
# @stdout Prints the matching filename
#
# Returns:
# @exitcode 0 Always succeeds
#
find_filebynumber() {
	local num="$1"
	local dir="$2"

	# If the number is expressed as num/total, then extract just
	# the number. This will still work, even if the number is not
	# expressed as a fraction.
	num=$(echo "$num" | cut -d'/' -f1)

	# pad the number out to four digits with leading zeroes.
	num=$(printf "%04d" "$num")

	# find and echo the filename.
	find "$dir" -maxdepth 1 -type f -name "$num*" | head -1
}
