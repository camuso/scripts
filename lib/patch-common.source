#!/bin/bash
#
# lib/patch-common.source
#
# This source file provides routines common to both patchreview and
# patchdevelop scripts.
#
version="11.6"

# Get the directory defaults if they don't already exist
#
[ "$MYDIR" ] || declare MYDIR=$(dirname $(which $(basename $0)))
[ "$MYLIB" ] || declare MYLIB=$MYDIR/lib

[ "$ui_loaded" ]            || source $MYLIB/ui.source
[ "$gitutilities_loaded" ]  || source $MYLIB/gitutilities.source
[ "$patchutils_loaded" ]    || source $MYLIB/patch-utils.source
[ "$configmanager_loaded" ] || source $MYLIB/config-manager.source

declare patchcommon_loaded=true

b_ui_int_first_getyn=false	# For lib/ui.source

# Enable extglob for more specific directory actions
#
shopt -s extglob

declare manual="$MYDIR/man/$(basename $0).txt"
declare MYDATA=
declare configfile=
declare repolist="$HOME"/.config/patchreview/repolist

#######################################
# External Scripts
#######################################
alias githead='$MYDIR/githead'
alias renpat='$MYDIR/renpat'
alias patcmp='$MYDIR/patcmp'
alias patbatcmp='$MYDIR/patbatcmp'
alias patbatcmpmgr='$MYDIR/patbatcmpmgr'

# Declare the global variables
#
declare indir
declare outdir
declare indirstr="Patch"
declare outdirstr="Work"
declare patstr		# string used by show_settings,
			# : empty if there are no patch files

declare editor
declare index=0
declare boolcount=0
declare boolindex=0
declare b_found_first_bool=false
declare b_selpat=false
declare b_allapplied=false
declare infilecount=0			# number of files in the input directory
declare patchtotal=0			# total patches in the input directory
declare us_commits_name="us-commits.log"	# upstream commits log filename
declare bp_commits_name="bp-commits.log"	# backport commits log filename
declare usvbp_commits_name="usvbp-commits.log"	# map of upstream vs backported commits

declare us_commits				# These must be initialized in menu
declare bp_commits				# : loop
declare usvbp_commits

declare patchcount=0
declare commit_msg_file="commit-msg.txt"
declare last_tag_file=
declare branchlist=
declare mismatch_file="mm.log"	# patchreview/develop will complete mmfile path
declare mmfile			# complete name of mmfile set by patchreview/devlop
declare valpatchlist=		# inited by call to patch-utils::create_patchlist

# These booleans are always set true when the script is inited.
declare b_rename_infiles
declare b_fmt_upstream
declare b_mrcomments=true
declare b_verbose
declare b_seekfixes

declare lasttag=
declare -i patchvalfuzz

# menu display control
declare -i menumode
declare -i menumode_ext=0
declare -i menumode_min=1
declare -i menumode_states=2

declare -i cmpmode
declare -i cmpmode_off=0
declare -i cmpmode_batch=1
declare -i cmpmode_inter=2
declare -i cmpmode_setup=3
declare -i cmpmode_states=4

declare -i applymode
declare -i applymode_off=0
declare -i applymode_norm=1
declare -i applymode_3way=2
declare -i applymode_patch=3
declare -i applymode_states=
declare -i applyfailmode
declare -i applyfailmode_exit=0
declare -i applyfailmode_cont=1
declare -i applyfailmode_menu=2
declare -i applyfailmode_states=3

declare -i startpat=1
declare -i menucols=30

# Values to be returned by renpat
#
declare -i renpatcnt	# the number of patch files counted by renpat
declare -i rensetcnt	# the number of patch files in the series

declare el6="el6"
declare el7="el7"
declare el8="el8"
declare el9="el9"

declare remote_repo=
declare remote_branch=
declare missing_fixes=	# File to contain missing fixes
declare remote_dir=

declare b_cmdline=false

########################################
# Function Return Codes
########################################
declare rc_continue=0	# Continue for another pass
declare rc_run=1	# Run

function exit_me {
	echo -e "$OFF"
	set_booleans

	for item in \
		menumode \
		patchvalfuzz \
		applyfailmode \
		applymode \
		cmpmode \
		editor \
		indir \
		outdir \
		background \
		remote_dir \
		remote_repo \
		remote_branch \
		mergelist_filter \
		opmode \
		current_mr \
		b_rename_infiles \
		b_fmt_upstream \
		b_verbose \
		b_mrcomments \
		b_seekfixes
	do set_cfg_item $item ${!item}; done

	_prologue=false
	[ -f "$prologue_file".txt ] && 	mv "$prologue_file".txt "$prologue_file"
	[ -e "$last_tag_file" ] && rm -f $last_tag_file
	[ -e "$branchlist" ] && rm -f "$branchlist"
	exit $1
}

# run if user hits control-c
#
control_c()
{
	echo -en "\nCtrl-c detected\nCleaning up and exiting.\n"
	exit_me $CTLC_EXIT
}

################  SANITY TEST DEBUGER  ###########################
function test_sanity { echo -e "$BLD\0SANITY$OFF"; ui_press_any; }
###################################################################

set_cfg_item() {
	cfg_write_key $1 $2
}

get_cfg_item() {
	cfg_read_key $1
}

show_version() {
       echo -e "${INF}Version: $STA$version$OFF"
}

show_seekfixes() {
	$b_seekfixes && echo "ON" || echo "OFF"
}

# set_working_repo - set the repo directory to work in
#
# Globals
# 	repolist - list of repo directories
#
set_working_repo() {
	local dndx
	local dnum
	local dary=()
	local repod
	local instruct=$(
cat <<EOF
$INF
You must create a $MNU$repolist$INF file
containing a list of directories with repos you are using.
For example...

$ cat $repolist
/mywork/rhel8/kernel
/mywork/c9s/kernel
/mywork/rhel9/kernel
$OFF

EOF
)
	[ -f "$repolist" ] || {
		echo -e "$instruct"
		ui_press_any
		return 1
	}

	dary=($(cat $repolist))
	for ((dndx = 0; dndx < ${#dary[@]}; ++dndx)); do
		echo -e "$MNU$((dndx+1)). $OFF${dary[dndx]}"
	done

	loop_range_q 1 ${#dary[@]} dnum || return 1
	repod=${dary[dnum-1]}

	[ -d "$repod" ] || {
		echo -e "$WRN$repod is not a directory!$OFF"
		ui_press_any
		return 1
	}

	cd $(realpath "$repod")
	[ -d .git ] || {
		echo -e "$WRN$repod is not a git repo!$OFF"
		ui_press_any
		cd -
		return 1
	}

	init_parms
	missing_fixes="$outdir/missing_fixes"
	git_get_lasttag lasttag $last_tag_file
	return 0
}

# set_remotedir - name the directory where the upstream remotes are
#
# GLOBALS
# 	remote_dir
#
set_remotedir() {
	local stat
	local b_exists=false

	echo -e "\n$INF Set the directory that contains the remote repo to" \
		"search for missing fixes.$OFF"

	if [ -n "$remote_dir" ]; then
		echo -e "$INF Your current remote directory is: $STA$remote_dir"
		prstr=$(echo "$INF Enter a new remote directory or press " \
			"$qstr$INF to leave it unchanged : $OFF")
		b_exists=true
	else
		prstr="$INF Enter a new remote directory : $OFF"
		b_exists=false
	fi

	while :; do
		ui_getnewdir "$prstr" remote_dir
		stat=$?

		if ($b_exists && [ $stat -eq 3 ]); then
			return
		else
			if [ $stat -ne 3 ]; then
				break
			else
				echo -e \
				    "${WRN}You must provide an upstream directory.$OFF"
			fi
		fi
	done

	# get the full pathname of the remote directory.
	# If there is no git repo in it, print the tutor to the screen
	# and exit gracefully.
	#
	remote_dir=$(realpath $remote_dir)
	[ -d $remote_dir/.git ] || {
		echo -e "${WRN}No git repo detected in $MNU$remote_dir$OFF"
		echo -e "${INF}This script will exit now."
		exit_me 1
	}

	# Changing the remote directory means changing the remote
	# origin/branch, too.
	#
	remote_repo=
	remote_branch=
	set_cfg_item "remote_repo" "$remote_repo"
	set_cfg_item "remote_branch" "$remote_branch"
	set_cfg_item "remote_dir" "$remote_dir"
}

# set_remote_seek() - set the remote origin and branch to seek
#
# Sets up the remote origin/branch global fields to use when seeking
# missing fixes.
#
# GLOBALS:
# 	remote_repo
# 	remote_branch
#
set_remote_seek() {
	local remotes=
	local b_set=true
	local remrepo_msg=$(
cat <<EOF
$INF
 Set the upstream origin/branch in: $STA$remote_dir$INF
 to search for any missing fixes.$OFF
EOF
)
	[ -n "$remote_dir" ] || set_remotedir
	echo -e "$remrepo_msg"

	if ([ -n "$remote_repo" ] && [ -n "$remote_branch" ]); then
		remotes="$remote_repo/$remote_branch"
		echo -e "$INF Your current remote repo/branch is: $STA$remotes"
		loop_yn "$MNU Do you want to change this? (y/n) : $OFF" b_set
	fi

	if $b_set; then
		cd $remote_dir
		select_remrepo remote_repo && select_rembranch "$remote_repo" remote_branch
		cd - > /dev/null 2>&1
		set_cfg_item "remote_repo" "$remote_repo"
		set_cfg_item "remote_branch" "$remote_branch"
	fi
}

# check_upstream - check the upstream dir and remote branches
#
# 	remote_repo
# 	remote_branch
# 	remote_dir
#
check_upstream() {

	# See if the remote/branch exists. If not, query for them
	cd $remote_dir
	while :; do
		git branch -r | grep "$remote_repo/$remote_branch" > /dev/null 2>&1
		[ $? -eq 0 ] && break
		echo -e "${WRN}Cannot find $STA$remote_repo/$remote_branch$WRN"
		echo -e "in remote directory: $STA$remote_dir$OFF"
		set_remote_seek
	done
	cd - > /dev/null 2>&1
}

# seek_missing_fixes() - search remote/branch for missing commits
#
# GLOBALS
# 	us_commits
# 	remote_repo
# 	remote_branch
# 	remote_dir
#
seek_missing_fixes() {
	[ -d $remote_dir ] || set_remotedir
	[ -n "$remote_repo" ] || select_remrepo remote_repo
	[ -n "$remote_branch" ] || select_rembranch "$remote_repo" remote_branch
	[ -f "$us_commits" ] || format_upstream_patches

	check_upstream

	> $missing_fixes
	check_fixes "$us_commits" \
		"$remote_dir" \
		"$remote_repo/$remote_branch" \
		"$missing_fixes" \
		$b_verbose

	[ -s $missing_fixes ] && \
	grep -q 'WARNING:' "$missing_fixes" && echo -e \
		"${WRN}There are missing fixes listed in $STA$missing_fixes$OFF"
	return 0
}

# test_editor() - tests for the existence of the chosen editor
#
# If the editor was not installed, the user is given a choice to exit now
# to install it or to select another editor. The function returns a 1 in
# this case to signal the caller that the editor is not installed and the
# user wants to see the choices available again.
#
# If the editor was installed, then it is set in the project file and the
# caller is signaled with a return of zero that the editor has been
# successfully chosen.
#
# $1 - the string name of the editor
#
# returns 0 if editor was found
# returns 1 if editor was not found
#
test_editor() {
	local _editor_="$1"
	local _ans_
	local _noed_=\
"$WRN$_editor_$INF is not installed. Do you want to exit and install it now?$OFF"
	local _pstr_=\
"${INF}Press '${MNU}y$INF' to exit now or '${MNU}n$INF' to select another editor: $INF"

	which "$_editor_" > /dev/null 2>&1

	if [ $? -ne 0 ]; then
		echo -e "$_noed_"
		getyn "$_pstr_" _ans_
		$_ans_ && exit_me 0
		return 1
	fi

	set_cfg_item editor "$_editor_"
	return 0
}

function set_editor {
	local choice
	echo -e ""$INF$"Select one of these currently supported diff editors.$OFF"
	echo -e "$MNU 1 -$OFF vimdiff"
	echo -e "$MNU 2 -$OFF emacs"
	echo -e "$MNU 3 -$OFF tkdiff"

	while true; do
		loop_range 1 3 choice
		case $choice in
			1 )	editor="vimdiff";;
			2 )	editor="emacs"	;;
			3 )	editor="tkdiff"
		esac
		test_editor "$editor"
		[ $? -eq 0 ] && break
	done
	set_cfg_item "editor" "$editor"
	echo -e "${INF}Editor is $STA$editor$OFF\n"
}

set_colors() {
	local ans
	while :; do
		ui_use_colors
		background=$terminal_background
		set_cfg_item background $terminal_background
		echo -en "${INF}You chose "

		case $terminal_background in
			1) echo -e "${STA}light$INF background$OFF\n";;
			2) echo -e "${STA}dark$INF background$OFF\n";;
		esac

		loop_yn_ro "Is that what you want? (y/n) : "
		[ $? -eq 0 ] && return || continue
	done
}

# get_currentfuzz - get the current patch validation fuzz level
#
# Returns a string with the level number preceded by an asterisk for
# the current fuzz level, or just a string with the level number if
# not the current level.
#
# GLOBALS
#     patchvalfuzz - current patch validation fuzz level
#
get_currentfuzz() {
	local fuzz=$1
	local ast="* $fuzz - "
	local noa="  $fuzz - "

	[ $fuzz -eq $patchvalfuzz ] && echo "$ast" || echo "$noa"
}

# set_patchvalfuzz - set the fuzz level for patch validation
#
# GLOBALS
#     patchvalfuzz - current patch validation fuzz level
#
set_patchvalfuzz() {
	local fuzz_msg=$(
cat <<EOF
$YEL

  Patches are validated in two steps.

  First, upstream commit hashes in the submitted RHEL patch are looked up.
  Then, the summary line from 'git log --oneline' of the upstream hash is
  compared with the summary line of the submitted RHEL patch. This is done
  to avoid confounding the mention of any other hash in the git log with
  the one being backported.

  Because there can be some differences in the way developers copy the
  upstream summary line, fuzz is sometimes necessary to minimize false
  positives of invalid commits.
$OFF
  Select one of the following fuzz levels. Current level has a leading '*'

  $(get_currentfuzz 0)no fuzz, strictest comparison
  $(get_currentfuzz 1)case insensitive (DEFAULT)
  $(get_currentfuzz 2)case insensitive and ignore commas
  $(get_currentfuzz 3)case insensitive and ignore all punctuation

EOF
)
	echo -e "$fuzz_msg\n"
	loop_range_q 0 3 patchvalfuzz
	set_cfg_item patchvalfuzz $patchvalfuzz
}

# show_patchvalfuzz - show the current patch validation fuzz level
#
# GOBALS
#    patchvalfuzz - current patch validation fuzz level
#
show_patchvalfuzz() {
	case $patchvalfuzz in
		0 ) echo "0 - no fuzz, strictest comparison"
		    ;;
		1 ) echo "1 - case insensitive (DEFAULT)"
		    ;;
		2 ) echo "2 - case insensitive and ignore commas"
		    ;;
		3 ) echo "3 - case insensitive and ignore all punctuation"
		    ;;
	esac
}

# set_dir - set a directory variable and save it in the config file
#
# Arguments
#   $1 - string to be used in the prompt describing the directory
#   $2 - the config file key for the directory variable name
#   $3 - the current value of the directory variable. Will be updated
#        if the user changes the directory name.
#
set_dir() {
	local dirstr="$1"
	local dircfgkey="$2"
	local dir="${!3}"
	local b_msgshown=false
	local ndirmsg=$(
cat <<EOF
$INF
This directory has not yet been named.
You must provide a directory path for me to continue.
If the path does not exist, I will offer to create it
for you.
$OFF
EOF
)
	[ -n "$dir" ] && {
		echo -e "${INF}Current $STA$dirstr$INF directory : $STA$dir$OFF"
		echo -e "${INF}Type $qstr$INF to leave it as it is.$OFF"
	}

	# We can't accept a NULL directory name, so cycle until we get one.
	#
	while :; do
		ui_getnewdir "${INF}New $STA$dirstr$INF directory : $OFF" dir

		if [ -n "$dir" ]; then
			[ -d "$dir" ] || mkdir -p "$dir"
			break
		else
			$b_msgshown || echo -e "$ndirmsg"
			b_msgshown=true
		fi
	done

	dir=$(realpath $dir)
	set_cfg_item $dircfgkey "$dir"
	echo -e "$INF$dirstr directory is $STA$dir$OFF\n"
	eval $3=$dir
}

# exec_boolean
#
# Execute a command string and pass the boolean that was
# used to determine whether the command should be executed.
# The boolean will be given the value passed by the caller.
#
# $1 - The boolean
# $2 - The boolean's new value
# $3 - The command line as a strng.
#
# Returns the status of the executed command string.
#
function exec_boolean {
	argc=$#
	argv="$@"
	local stat
	local boolean=$1
	local b_newval=$2
	local cmdstr="$(echo "$@" | cut -d' ' -f$argc-)"

	$cmdstr
	stat=$?
	# echo "$cmdstr status: $stat"
	if [ $stat -eq 0 ]; then
		[ $argc -ge 2 ] && set_cfg_item "$boolean" $b_newval
	else
		echo "$cmdstr"
		echo -e "\tDid not execute successfully"
		echo
	fi
	return $stat
}

# replace_patch
#
# GLOBALS
#	outdir
#	us_commits
#
function replace_patch {
	local patnum
	local commit
	local patcnt=$(cat "$us_commits" | wc -l)

	getuser "Patch Number to replace: " patnum
	getuser "Correct commit ID: " commit
	ui_replaceline $patnum "$commit $patnum/$patcnt" "$us_commits"
	rm -f "$outdir"/*.patch
	# git_file2patchset "$us_commits" "$outdir"
	git_commit2patch $patnum $commit $outdir
}

# create_commit_msg
#
# $1 - pathname of patch
# $2 - outdir
#
# GLOBALS
#	commit_msg_file
#
function create_commit_msg {
	local diffstr="diff "
	local subjstr="Subject: "
	local found_subj=false
	local commit_msg_path=""$outdir"/"$commit_msg_file""

	echo "" > "$commit_msg_path"

	while read line; do
		[ "${line:0:5}" == "$diffstr" ] && break

		if [ "${line:0:9}" == "$subjstr" ]; then
			local sumstrpos=$(($(ui_strindex "$line" "]") + 1))
			local sumstr=$(echo -e ${line:$sumstrpos})
			echo "$sumstr" >> "$commit_msg_path"
			echo "" >> "$commit_msg_path"
			found_subj=true
		fi
		$found_subj && echo "$line" >> "$commit_msg_path"
	done < "$1"
}

# process_patcherr - decide what to do upon patch apply error
#
# Globals
# 	patchcount
# 	applyfailmode*
#
process_patcherr() {
	local failedpatch=$1
	local head=$2
	local amresolve

	echo -en "$BLD"
	echo -e "\nPatch: $OFF$failedpatch$BLD"
	echo -e "Failed to apply.$OFF"

	check_already_applied

	if (( applymode != applymode_patch )); then
		echo "Please select one of the following"
		echo "1 - git am --abort"
		echo "2 - git am --quit"
		echo
		loop_range 1 2 amresolve

		case $amresolve in
			1 ) git am --abort
			    git reset --hard $head
			    patchcount=0
			    ;;
			2 ) git am --quit
			    patchcount=$(git log --oneline $head..HEAD | wc -l)
			    ;;
		esac
	fi

	case $applyfailmode in
	    $applyfailmode_exit )
		    echo -e "Exiting script ...\n"
		    exit_me 1
		    ;;
	    $applyfailmode_cont )
		    echo -e "Continuing without patching...\n"
		    ;;
	    $applyfailmode_menu )
		    echo -e "Returning to main menu ...\n"
	esac
}

# use_patch - use the patch app instead of git am
#
# Arguments
#	$1 - the string containing the list of patches
#
# Globals:
#	patchcount - running tally of applied patches
#	startpat   - patch to start applying from
#
use_patch() {
	local patchlist="$1"
	local stat=0
	local cmtlog="/dev/shm/cmtlog.txt"

	for patch in $patchlist; do
		let patchcount++
		# [ $patchcount -ge $startpat ] || continue
		echo "$patch"
		patch --fuzz=3 -p1 < $patch
		stat=$?

		# If the patch applied cleanly, build a commit log message.
		#
		if [ $stat -eq 0 ]; then
			git log -n1 --pretty=format:"%s" > $cmtlog
			echo -e "\n" >> $cmtlog
			git log -n1 --pretty=medium >> $cmtlog
			git commit . -s -F $cmtlog
			rm -f $cmtlog > /dev/null 2>&1
		fi
	done

	return $stat
}

# get_failedpatch - returns the filename of the failed patch
#
# Globals
# 	patchcount - running tally of applied patches
# 	applymode
# 	applymode_patch
#
get_failedpatch() {
	local patchlist="$1"
	local patcharray=( $patchlist )
	local patsub
	local patfil

	if (( applymode == applymode_patch )); then
		echo "${patcharray[$((patchcount - 1))]}"
	else
		patsub=$(git am --show-current-patch | grep -m1 'Subject: ')
		patsub=$(echo "$patsub" | cut -d'[' -f2 | cut -d']' -f1)
		patfil=$(grep -l "$patsub" $patchlist)
		echo "$patfil"
	fi
}

# map_us2bp - map upstream to backported commits
#
# GLOBALS
#	bp_commits    - log of backported commits
#	us_commits    - log of upstream commits
#	usvbp_commits - map of upstream to backported commits
#
map_us2bp() {
	local usline=
	local bpline=
	local b_done=false

	> $usvbp_commits

	# Create two file descriptors for the upstream and backported logs.
	exec 5<"$us_commits"
	exec 6<"$bp_commits"

	until $b_done; do
		read -u 5 usline || b_done=true
		read -u 6 bpline || b_done=true

		usline="$(echo "$usline" | cut -d' ' -f1)"

		$b_done || echo -n "$usline " >> $usvbp_commits
		$b_done || echo "$bpline" >> $usvbp_commits
	done

	exec 5<&-
	exec 6<&-
}

# apply_patches
#
# GLOBALS
#	indir         - input directory, contains the patches
#	patchcount    - running count of applied patches
#	patchtotal    - total number of patches to apply INITED HERE
#	bp_commits    - log of backported commits
#	applymode*    - git am, git am -3, or patch --fuzz=3 -p1
#	applyfailmode - exit, goto main-menu, or continue
#	startpat      - patch from which to start the apply
#	valpatchlist  - created by call to lib/patch-utils::create_patchlist
#
function apply_patches {
	# echo -e "\n$BLD\0patch-common::apply_patches()$OFF"
	local stat=0
	local patchlist="$(ls -1 "$indir"/*.patch)"
	local head=$(git log --oneline -n1 | cut -d' ' -f 1)

	create_patchlist "$patchlist" valpatchlist $startpat
	patchtotal=$(wc -w <<< "$valpatchlist")

	[ $applymode -eq $applymode_off ] && return 0
	> "$bp_commits"

        [ "$valpatchlist" ] || {
		echo -e "$WRN\nIt appears there are no valid patches to apply.\n$OFF"
		return 1
	}

	case $applymode in
	    $applymode_norm  ) git am $valpatchlist; stat=$? ;;
	    $applymode_3way  ) git am -3 $valpatchlist ; stat=$? ;;
	    $applymode_patch ) use_patch "$valpatchlist"; stat=$? ;;
	esac

	[ $stat -eq 0 ] || process_patcherr $(get_failedpatch "$valpatchlist")

	# Create the log of commits backported.
	shopt -s extglob
	patchcount=$(ls -1 $indir/*.patch | wc -l)
	shopt -u extglob
	git log --oneline -n$patchcount > "$bp_commits"
	map_us2bp

	[ $stat -eq 0 ] && b_allapplied=true || tail -1 "$bp_commits"
	return $stat
}

show_discrete_ops() {
	echo -en "$MNU x$OFF  "
	case $menumode in
		$menumode_ext ) echo -en "Hide " ;;
		$menumode_min ) echo -en "Show ";;
	esac
	echo -e "$MNU${UND}Discrete Operations$OFF Menu"
}

show_colors() {
	$b_color && echo -e "ON" || echo -e "OFF"
}

show_verbose() {
	$b_verbose && echo -e "${MNU}verbose is$STA ON$OFF" \
		   || echo -e "${MNU}verbose is$STA OFF$OFF"
}

show_patches() {
	echo -en "$MNU d$OFF  $indirstr directory"
	printf "%*c" $((15 - ${#indirstr})) " "
	echo -e  ":$STA $indir$OFF has $STA$infilecount$OFF ${patstr}files."
}

show_workdir() {
	echo -en "$MNU w$OFF  $outdirstr directory"
	printf "%*c" $((15 - ${#outdirstr})) " "
	echo -e ":$STA $outdir"
}

show_cmpmode() {

	case $cmpmode in
	    $cmpmode_off   )	echo "OFF" ;;
	    $cmpmode_batch )	echo "Batch" ;;
	    $cmpmode_inter )	echo "Interactive Only" ;;
	    $cmpmode_setup )	echo "Batch compare setup" ;;
		         * )	echo "Not a valid comparison mode" ;;
	esac
}

show_applymode() {

	case $applymode in
	    $applymode_off   )	echo "OFF" ;;
	    $applymode_norm  )	echo "git am" ;;
	    $applymode_3way  )	echo "git am 3-way merge" ;;
	    $applymode_patch )  echo "patch --fuzz=3 -p1 <" ;;
	                   * )	echo "Not a valid apply mode" ;;
	esac
}

show_applyfailmode() {

	case $applyfailmode in
	    $applyfailmode_exit ) echo "Exit" ;;
	    $applyfailmode_cont ) echo "Continue without applying" ;;
	    $applyfailmode_menu ) echo "Return to main menu" ;;
	                      * ) echo "Not a valid failover mode" ;;
	esac
}

show_view_logs() {
	local logs=$(ls -1 $outdir/*.log 2> /dev/null)

	[  "$logs" ] && echo -e "\n$MNU V$OFF  View the log files"
}

view_logs() {
	local logs=($(ls  $outdir/*.log  2>/dev/null))
	local logfile
	local index=1
	local choice

	[  "${#logs[@]}" -ne 0 ] || {
		echo -e "\n${INF}There are currently no log files.$OFF"
		return
	}

	echo -e "\n${BLD}Select the log file you wish to view.$OFF\n"
	for logfile in ${logs[@]}; do
		echo "$index - $logfile"
		let ++index
	done
	echo

	loop_range_q 1 $((index - 1)) choice

	[ $? -ne 0 ] && return

	less ${logs[$((choice - 1))]}
}

# get_filecount() - count the files in the indir
#
# This is a bit ugly. If there are .patch files in the indir, then count
# the number of patch files, else count all the files.
#
# Globals:
# 	infilecount
# 	patstr      - used by show_settings
# 	b_selpat
#
get_filecount() {
	local fc=$(find $indir -maxdepth 1 -not -type d -name "*.patch" -print -quit)
	if [ "$fc" ]; then
		infilecount=$(find $indir -maxdepth 1 -not -type d -name "*.patch" | wc -l)
		! $b_allapplied && b_selpat=true || b_selpat=false
		patstr="patch "
		b_rename_infiles=false
	else
		infilecount=$(find $indir -maxdepth 1 -not -type d | wc -l)
		patstr=""
		b_selpat=false
		b_rename_infiles=true
	fi
}

# show_nextpatch() - determine whether user can select next patch
#                    and display accordingly
#
# Globals:
# 	infilecount
# 	b_allapplied
#
show_nextpatch() {
	local shownext=$(
cat <<EOF
$MNU
 5$OFF  Start applying at patch  :$STA $startpat$OFF
EOF
)
	[ $infilecount -eq 0 ] && { b_selpat=false; return; }

	$b_allapplied && {
		echo -e "\n$INF    All patches were successfully applied$OFF"
		return
	}

	[ "$patstr" ] && echo -e "$shownext"
}

# show_apply_patches() - show the option to apply the patches
#
# Only appears if there are patches remaining to be applied
#
# Globals:
#	b_allapplied
#
show_apply_patches() {
	echo -en "\n$MNU A$OFF  Apply patches"

	if [ $applymode -eq $applymode_off ] && $b_allapplied; then
		echo -en "            :$OFF "
		echo -en "already applied and apply mode ${STA}OFF${OFF}"
	elif [ $applymode -eq $applymode_off ] && ! $b_allapplied; then
		echo -en "            :$OFF "
		echo -en "apply mode is ${STA}OFF$OFF"
	elif [ $applymode -ne $applymode_off ] && $b_allapplied; then
		echo -en "            :$OFF "
		echo -en "already applied"
	fi
}

# select_patch() - select a patch to start the apply process
#
# Globals:
# 	patstr
# 	infilecount
# 	startpat
#
select_patch() {

	[ "patstr" ] || {
		echo "Please run the rename on the files first."
		return
	}

	loop_range_q 1 $infilecount startpat
	[ $? -ne 0 ] && echo "Leaving starting patch at $startpat."
	return
}

# show_branch_mismatch - prints discrepency between distro and kernel
#
# If user options to switch branches, the global lasttag is refreshed.
#
# Globals:
# 	lasttag
# 	last_tag_file
# 	branchlist
#
# $1 - current distro
# $2 - user's y or n response to query to switch branches
#
show_branch_mismatch() {
	local _distro_="$1"
	local _yn_

	echo -e "$BLD\0Patches are$OFF $_distro_$BLD but kernel is$OFF $lasttag"
	doyn "Switch branches now?" "git_setbranch $branchlist" "" _yn_
	$_yn_ && git_get_lasttag lasttag $last_tag_file
	eval $2=$_yn_
}

# check_patchvbranch - see if the patch names match the branch
#
# Globals
# 	rhel*str, pegas*str - strings that represent the corresponding kernels
# 	indir - directory containing the RHEL patches
#	krnstrlen - length of the string that defines which kernel
# 	lasttag
#
check_patchvbranch() {
	local pat
	local subject
	local pfx
	local dist
	local distname="NOT RHEL"
	local tag
	local elstr=""
	local yn=false
	local i
	local j
	local ary
	local b_pegas=false

	[ $indir ] || return 1

	# See if there are any .patch files in the $indir
	#
	stat $indir/*.patch > /dev/null 2>&1
	[ $? -eq 0 ] || {
		echo -e "\nNo .patch files in $BLD$indir$OFF"
		ui_press_any
		return 1
	}

	# Get the subject line from the first patch and remove "Subject:"
	pat=$(ls -1 $indir/*.patch | head -1)
	subject=$(grep 'Subject: ' -m1 $pat)
	subject=${subject//"Subject: "/}

	# Convert to upper case
	pfx="$(echo "$subject" | tr [a-z] [A-Z])"

	# Remove the word PATCH if it's there
	pfx="${pfx//"PATCH"/}"

	# The Prefix must begin with a 'RHEL'. If it does not, then advise
	# the user and offer to run anyway, or return to the main menu.
	i=$(ui_strindex "$pfx" "RHEL")

	# Find the end of the RHEL prefix at the right bracket.
	j=$(ui_strindex "$pfx" "]")

	# echo "i: $i j: $j"
	if ( [ $i -lt 0 ] || [ $j -le 0 ] || [ $j -le $i ] ); then
		echo -e "$STA$subject$OFF"
		echo -e ""$WRN"...does not appear to be a RHEL patch or series$OFF"
		getyn "Do you wish to continue anyway?" yn
		$yn || return 1
		distname="NOT RHEL"
		elstr=""
	else
		# Extract the patch prefix between the brackets.
		pfx="${pfx:$i:$((j-i))}"
		# echo "pfx extracted: $pfx"

		# If there is "alt" anywhere in the prefix, then set the
		# pegas flag.
		[[ "$pfx" = *"ALT"* ]] && b_pegas=true

		# If it exists, remove the "ALT" string to get the basic distro.
		$b_pegas && dist="${pfx//ALT/}" || dist="$pfx"

		# Replace hyphens with spaces and remove any extraneous spaces.
		dist="$(tr -s "-" " " <<< "$dist")"

		# Tokenize the dist so we can extract just the RHEL and its
		# version numbers.
		ui_strtok "$dist" " " ary
		# echo "dist: \"$dist\" ary: ${ary[@]}"

		# If the first token in the array only has 4 chars, then it is
		# "RHEL" without the version numbers. In this case, the second
		# token will have the version.
		[ ${#ary[0]} -eq 4 ] && dist=${ary[0]}${ary[1]} || dist=${ary[0]}

		# echo "dist: $dist"
		case "${dist:0:5}" in
			"RHEL6" ) elstr="$el6" ; distname="$dist" ;;
			"RHEL7" ) elstr="$el7" ; distname="$dist" ;;
			"RHEL8" ) elstr="$el8" ; distname="$dist" ;;
			"RHEL9" ) elstr="$el9" ; distname="$dist" ;;
			      * ) elstr=""     ; distname="NOT RHEL" ;;
		esac

		$b_pegas && distname="${distname}-ALT" && elstr="${elstr}a"
	fi

	# Tokenize the current kernel branch tag.
	#
	ui_strtok "$lasttag" ".-" tag

	# 2020-10-05
	# Cycle through the tag array looking for elstr. It is not
	# necessarily the last token anymore.
	#
	for ((i = 0; i < ${#tag[@]}; ++i)); do
		[ "${tag[i]}" == "$elstr" ] && break
	done

	# If we went through the loop and didn't find the elstr, then the
	# script thinks that we do not have a match between the patches and
	# the current branch. In that case, see whether the user wants to
	# choose a different branch or apply the patches to the current
	# branch, regardless.
	#
	(( i < ${#tag[@]} )) ||  show_branch_mismatch "$distname" yn

	# If user did not opt to switch branches, then user wants to apply
	# patches to current branch, even when they appear to the script
	# to be mismatched.
	# If the user did switch branches, call this routine recursively to
	# see if s/he chose the correct branch.
	#
	$yn && check_patchvbranch

	return 0
}

# get_current_head_trunc() - returns the current head truncated
#
#  Truncation is the difference between the global tcols, which is the number
#  of columns of the current terminal declared in ui.source, and the number
#  passed in $1
#
#  $1 - number of columns already used (offset columns to where the current
#       head will be displayed on the terminal)
#
get_current_head_trunc() {
	local used=$1
	local cols=$((tcols-used))
	local current_head=$(git log --oneline -n1)
	local current_head_trunc=${current_head:0:$cols}
	echo $current_head_trunc
}

# create_branch - creates a branch at the current head
#
create_branch() {
	local bname=
	local tagname=
	local current_head_trunc=$(get_current_head_trunc 23)
	local brstr=$(
cat <<EOF

Create new branch at: $BLD$current_head_trunc$OFF
Press ${BLD}ENTER$OFF or $qstr at the naming prompts to \
quit without applying the change.
\0
EOF
)
	echo -e "$brstr"
	getuser "Name of the new branch: " bname
	[[ "qQ" == *"$bname"* ]]  && return
	git branch $bname
	echo -e "Created branch $BLD$bname$OFF"
	getuser "New tag name: " tagname
	[[ "qQ" == *"$tagname"* ]] || git tag "$tagname"
}

# format_upstream_patches
#
# Create a list of commits and use that to format the patches.
#
# Globals:
# 	indir
# 	outdir
# 	us_commits
# 	b_fmt_upstream
# 	remote_dir
#
# Returns
# 	0 - all good
# 	1 - no patch files to review
#
format_upstream_patches() {
	$ui_b_debug && echo -e "${STA}format_upstream_patches$OFF"
	local fc=	# $(find $outdir -maxdepth 1 -not -type d -name "*.patch" -print -quit)
	local b_yup
	local banner=
	local pad=
	local escnt=
	local stat=0
	local quiet=

	$b_verbose || quiet="-q"

	fc=$(find $outdir -maxdepth 1 -not -type d -name "*.patch" -print -quit)

	[ "$fc" ] && {
		echo
		echo -e ""$INF"There are already upstream patch files in $STA$outdir$OFF"
		getyn "Do you want to replace them? " b_yup

		if $b_yup; then
			rm -f $outdir/* > /dev/null 2>&1
			> $missing_fixes
		else
			return 1
		fi
	}

	ls $indir/*.patch > /dev/null 2>&1
	[ $? -ne 0 ] && {
		echo
		echo -e ""$INF"There are no patch files to review in $STA$indir$OFF"
		return 1
	}

	rm -vf "$outdir"/* > /dev/null 2>&1
	> "$us_commits"
	echo

	git_comment2commitsfile \
		-r "$remote_dir" -i $indir -o "$us_commits" -f $patchvalfuzz $quiet
	stat=$?
	echo
	[ $stat -eq 0 ] || {
		echo -en "$WRN${ui_err_msg[$stat]}"
		case $stat in
			$ui_err_invdir )  echo -e " : $STA$indir$OFF";;
			$ui_err_invfile ) echo -e " : $STA$us_commits$OFF";;
		esac
		return 1
	}

	if $b_verbose; then
		banner=""$INF"Upstream commits extracted from the patches in $STA$us_commits$INF"
		escnt=$((${#INF} + ${#STA} + ${#INF}))
		pad=$(ui_putnchar '=' $(( ${#banner} - $escnt)))
		echo -e "$banner\n$pad$OFF"

		cat "$us_commits"
		echo
	fi

	cd $remote_dir
	exec_boolean b_fmt_upstream false \
		"git_file2patchset ${us_commits} ${outdir} ${b_verbose}"
	cd - > /dev/null 2>&1
	return 0
}

# check_already_applied - see if the commits have already been applied
#
# GLOBALS
# 	us_commits
# 	usvbp_commits
#
check_already_applied() {
	local usline
	local usvbpline
	local uscommit
	local bpcommit
	local linecnt=20	# just a guess for now.
	local promptresp
	local b_done=false
	local b_header=true
	local header=$(
cat <<EOF
$INF
The backported commits log $STA$bp_commits$OFF$INF is not empty.
It's possible that some of them have already been applied.
Press "$MNU"'i' (init)$INF at the main menu to remove the commits log.$OFF

Upstream       RHEL commit
------------   ------------
EOF
)
	local moreprompt=\
"${INF}If you've seen enough press$OFF $qstr$INF, else any other key to see more: $OFF"

	# if there's nothing in the us v bp commit map, just return
	#
	[ -s "$usvbp_commits" ] || return 0

	exec 5<"$us_commits"

	until $b_done; do
		read -u 5 usline || b_done=true
		uscommit="$(echo "$usline" | cut -d' ' -f1)"
		(( 16#$uscommit )) || continue
		echo -n "$uscommit"
		usvbpline="$(grep -m1 "$uscommit" "$usvbp_commits")"

		if [ -n "$usvbpline" ]; then
			ui_clearline

			if [ $linecnt -ge $((tlines - 2)) ]; then
				linecnt=1
				promptgetchar "$moreprompt" promptresp
				if [ "$promptresp" == "q" ]; then
					b_done=true
					continue
				fi

			fi

			bpcommit="$(echo "$usvbpline" | cut -d' ' -f2-)"

			if $b_header; then
				b_header=false
				echo -e "$header"
			fi

			echo "${uscommit:0:12}""   ""$bpcommit"
			let ++linecnt
		else
			ui_clearline
		fi
	done

	exec 5<&-
	echo
	return 1
}

# exec_apply_patches
#
# Do all the front-end housekeeping and apply the patches in the indir.
#
# Globals:
# 	patchcount
# 	applymode
# 	applyfailmode
# 	applyfailmode_menu
#
# returns nonzero if patches fail to apply
#
exec_apply_patches(){
	local stat

	git am --abort 2>/dev/null
	patchcount=0

	check_patchvbranch
	[ $? -eq 0 ] || return 1

	apply_patches
	stat=$?
	[ $stat -ne 0 ] && [ $applyfailmode -eq $applyfailmode_menu ] \
		&& return $stat

	applymode=$applymode_off
	set_cfg_item "applymode" $applymode

	return 0
}

# check_mismatch_file - see that it has the correct number of patches
#
# Globals
#	mmfile
#	infilecount
#
# Returns
# 	0 if number of patches in the mismatch file is the same as infilecount
# 	1 if not
#
check_mismatch_file() {
	# echo -e "\n$BLD\0patch-common::check_mismatch_file$OFF"
	declare b_found=false
	declare -i num=0


	[ -f $mmfile ] || return 1

	num=$(tac $mmfile | while read line; do
		echo "$line" | grep '^PATCH:' > /dev/null
		if [ $? -eq 0 ]; then
			echo "$line" | cut -d':' -f2;
			break
		fi
	done)
	[ $num -eq $infilecount ] && return 0 || return 1
}

# exec_patcmp - execute the comparison of the patches
#
#  $1 - Contains "-X" to execute in patbatcmpmgr in batch mode.
#       If this parameter is not passed, then patbatcmpmgr operates in
#       setup mode.
#
# Globals:
# 	indir
# 	outdir
# 	mmfile
# 	us_commits
# 	editor
# 	patchtotal
# 	terminal_background
#
exec_patcmp() {
	$ui_b_debug && echo -e "${STA}patch-common::exec_patcmp$OFF"
	local xval="$1"
	local patchlist="$(ls -1 "$indir"/*.patch)"
	local tb=$terminal_background
	local quiet=

	$b_verbose || quiet="-q"

	# If we don't have a valid patch list, create one now.
	#
	[ "$valpatchlist" ] || create_patchlist "$patchlist" valpatchlist
	patchtotal=$(wc -w <<< "$valpatchlist")

# echo "indir: $indir  outdir: $outdir"
# echo "patchtotal: $patchtotal"
# echo "patchlist:"
# echo "${patchlist[@]}"
# echo
# echo "valpatchlist:"
# echo "${valpatchlist[@]}"
# ui_press_any

	# If the mmfile does not contain the same number of patches
	# as the infilecount, then go make the mmfile.
	#
	if [ "$xval" ]; then
		check_mismatch_file
		if [ $? -ne 0 ]; then
			# echo -e "${BLD}Rebuild the conflicts log:$OFF $mmfile"
			patbatcmpmgr -P "$valpatchlist" -R $indir -U $outdir \
				     -o $mmfile "$xval"
		fi
	else
		patbatcmpmgr -x -P $valpatchlist -R $indir -U $outdir -o $mmfile
	fi
	patcmp $quiet -b $tb -m $mmfile -u $remote_dir $indir $outdir $editor "$us_commits"
	return $?
}

# compare_patches - compare the downstream with the upstream
#
# Globals
#	cmpmode*
#	terminal_background
#
compare_patches() {
	local tb=$terminal_background
	local stat=

	local quiet=

	$b_verbose || quiet="-q"

	case $cmpmode in
		$cmpmode_batch ) exec_patcmp "-X"; stat=$? ;;
		$cmpmode_setup ) exec_patcmp; stat=$? ;;
		$cmpmode_inter ) patcmp $quiet -b $tb $indir $outdir $editor $us_commits
				 stat=$? ;;
			     * ) cmpmode=$cmpmode_off
	esac

	return $stat
}

# init_menu - initialize the menu loop with default global values
#
init_menu() {
	init_booleans
	get_booleans
	applymode=$applymode_norm
	set_cfg_item applymode $applymode
	patchcount=0
	startpat=1
	b_fmt_upstream=true
	b_allapplied=false
	[ $opmode -eq $opmode_mr ] && b_mrflag=true || b_mrflag=false
	[ -f "$usvbp_commits" ] && rm -f "$usvbp_commits"
	if $b_mrflag; then
		current_mr=
		rm -f $indir/* 2>/dev/null
		rm -f $outdir/* 2>/dev/null
	fi
}

# check_patch_count
#
# Check to see that the number of .patch files matches the denominator of
# the series.
#
# Globals
# 	rensetcnt
# 	renpatcnt
#
check_patch_count() {
	local b_cont
	local miscntmsg=$(
cat <<EOF

There are $BLD$renpatcnt$OFF patch files, but the series claims
to have $BLD$rensetcnt$OFF patches.
EOF
)
	( [ $renpatcnt -gt 1 ] && [ $rensetcnt -gt 0 ] ) || return 0

	if [ $renpatcnt -eq $rensetcnt ]; then
		return 0
	else
		echo -e "$miscntmsg"
		getyn "Do you want to continue anyway? " b_cont
		$b_cont && return 0 || return 1
	fi
}

# renpatfiles - renames the files in a given directory
#
# Globals:
# 	indir     - directory containing the emailed patches
# 	renpatcnt - the number of patch files counted by the routine
# 	rensetcnt - the number of patch files purported to be in the set
# 	            as determined by the denominator of the set, if it
# 	            exists.
#
# Returns ui_err_nofiles or return value of call to check_patch_count
#
renpatfiles() {

    declare -i total
    declare -i windex	# index of word in subj prefix having '/' in it
    declare -i fldwid=0	# width of the field having total number of patches
    declare -a pfxary	# tokenized subject line
    declare -a wary	# word having '/' in it tokenized
    declare subject
    declare word
    declare iszero=false
    declare patnum
    declare pfx		# subject prefix, stuff between the [ and ]
    declare isaset	# true if this is a patch series

    rensetcnt=0		# globally declared in this file
    renpatcnt=0		# :

    cd $indir
    echo -e ""$INF"Changing directory to $STA$PWD$OFF"
    total=$(find -maxdepth 1 -not -type d | wc -l)
    echo -e "$STA$PWD$INF has $STA$total$INF files.$OFF"

    if [ $total -eq 0 ]; then
	echo -e "$STA$indir$INF has no files to rename.$OFF"
	echo -en ""$INF"Returning to main menu. and repo directory: $STA"
	cd - > /dev/null 2>&1
	echo -en "$OFF"
	return $ui_err_nofiles
    fi

    # remove spaces from filenames
    #
    ui_remove_spaces

    # Don't try to rename files that have ".patch" endings, because
    # these have already been renamed.
    #
    for filename in $(find -maxdepth 1 -not -type d -not -name "*.patch");
    do
	iszero=false
	word=""
	windex=0

	# Extract the subject line.
	#
	subject=$(grep -m1 "Subject: " "$filename")

	# Remove any asterisks from the subject line.
	#
	subject=$(sed 's/\*//g' <<< "$subject")

	# Remove the word "Subject: " from the line
	#
	subject=$(echo "$subject" | cut -d' ' -f2-)

	# If the next character is not '[', then it is not a patch.
	#
	[ "${subject:0:1}" == "[" ] || continue

	# Remove any version numbers from within the brackets. There is no
	# standard on where the patch version number appears, so the patch
	# can be out of order.
	#
	# Find the right bracket to isolate the text within the brackets.
	# If we don't find a right bracket in the subject line, then continue
	# to the next file.
	#
	rb_pos=$(ui_strindex "$subject" "]")
	[ $rb_pos -lt 0 ] && continue

	# extract the bracketed prefix substring and remove any version numbers
	#
	pfx="${subject:1:$((rb_pos-1))}"
	new="$(echo $pfx | sed 's/v\w//i')"

	# Substitute the new prefix for the old in the subject string.
	#
	subject="$(echo ${subject/"$pfx"/"$new"})"

	# If there is no / in the subject prefix, then it is not a series.
	#
	if [[ $new == *"/"* ]]; then

	    # Tokenize the subject prefix.
	    # Look for the first token with a '/' in it.  If all the
	    # characters leading up to the '/' are zero, then it is a
	    # prologue, not a patch.
	    #
	    ui_strtok "$new" " " pfxary
	    for ((i = 0; i < ${#pfxary[@]}; i++)); do
		    word=${pfxary[$i]}
		    [[ $word == *"/"* ]] && windex=$i && break
	    done

	    # The zeroth patch is the prologue, so skip it.
	    #
	    for ((i = 0; i < ${#word}; i++)); do
		    [[ ${word:$i:1} == "/" ]] && break
		    [[ ${word:$i:1} != "0" ]] && iszero=false && break
		    [[ ${word:$i:1} == "0" ]] && iszero=true
	    done

	    $iszero && continue

	    # Some posters do not provide padding zeroes in their PATCH
	    # n/m subject lines. This will cause out-of-order
	    # processing, since 1/n will be immediately followed by
	    # 10/n, 11/n, etc. Padding the first number with leading
	    # zeroes will preclude this.
	    #
	    # If we found a "/" in the subject string, then windex is
	    # nonzero.  In that case, we need to determine the correct
	    # number of padding zeroes required in the first number.
	    #
	    if [ $windex -gt 0 ]; then

		# Tokenize the word with the "/" in it. We need to
		# pad the leading number with zeroes to make it the
		# same width as the number of patches in the set.
		# Including the brackets in the delimiter will strip
		# them from the word.
		#
		ui_strtok "$word" "[/]" wary

		# We only need to do this once per patchset
		#
		if [ $fldwid -eq 0 ]; then

		    # The total number of patches is in the
		    # second word of the wary stripped of any
		    # non-alphanumeric chars.
		    #
		    rensetcnt="${wary[1]}" # | sed 's/:[][<>(),"//g')"

		    # Determine the fieldwidth of the total
		    # number of patches.
		    #
		    fldwid=${#rensetcnt}
		fi

		# Determine the fieldwidth of the patch number and pad it
		# with leading zeroes if necessary.
		#
		patnum="${wary[0]}"
		for ((j = $fldwid - ${#patnum}; j > 0; --j )); do
		    wary[0]="0${wary[0]}"
		done

		# Replace the patch's n/m with the new padded n/m word.
		# The new word will have a space where there was a '/', but
		# that will be handled when we strip the non-alphanumeric
		# characters from the subject string.
		#
		pfxary[$windex]="${wary[@]}"
		subject="${pfxary[@]}""-""${subject:$rb_pos}"
	    fi
	fi

	# Replace non-alphanumerics with a hyphen, then delete any leading
	# hyphen.
	#
	subject=$(echo "$subject" | sed 's/[^[:alnum:]]\+/-/g')
	subject=$(echo "$subject" | sed 's/^-//')

	# If the last character is a hyphen, remove it.
	#
	[ "${subject:(-1)}" = "-" ] && subject=${subject%?}

	newname=$(echo "$subject"".patch")

	# See if we already have one of these, if so, skip it.
	#
	[ -f "$newname" ] && continue

	echo "mv "$filename" -> "$newname""
	mv "$filename" "$newname"
	renpatcnt=$((renpatcnt+1))
    done
    cd - > /dev/null 2>&1
    check_patch_count
    return $?
}

# find_filebynumber - echo a filename with a leading %04d
#
# This is only useful for finding a filename that begins with a
# number padded with zeroes to four digits. It's useful when trying
# to find a patch in a directory when you have only the patch number.
#
# $1 - file number
# $2 - directory to search
#
find_filebynumber() {
	local num="$1"
	local dir="$2"

	# If the number is expressed as num/total, then extract just
	# the number. This will still work, even if the number is not
	# expressed as a fraction.
	num=$(echo "$num" | cut -d'/' -f1)

	# pad the number out to four digits with leading zeroes.
	num=$(printf "%04d" $num)

	# find and echo the filename.
	ls -1 "$dir" | grep -m1 "$num"
}
