#!/bin/bash
#
# ui.source - User interface library for bash scripts
#
# This file uses shdoc-style documentation annotations.
# See: https://github.com/reconquest/shdoc
#
# Common annotations:
#   @description  - Function/script description
#   @arg          - Function argument: @arg $1 type description
#   @set          - Global variable set: @set varname type description
#   @exitcode     - Exit code: @exitcode 0 description
#   @stdout       - Standard output description
#   @example      - Usage example
#
# Use 'docscript -f funcname lib/ui.source' to view function documentation.
#

##############################
# Global Variables and Consts
##############################

declare ui_loaded=true
declare ui_b_debug=false

# Text Attributes
#
# $BLD - bold
# $UND - underline
# $OFF - turn all attributes and colors off
unset BLD && declare BLD="\e[1m"
unset UND && declare UND="\e[4m"
unset OFF && declare OFF="\e[m"
#
# Color Attributes
#
# Plain colors
# $BLK, $RED, $GRN, $YEL, $BLU, $MGT, $CYN, $WHT
#
# Bold or bright colors
# $BBLK, $BRED, $BGRN, $BYEL, $BBLU, $BMGT, $BCYN, $BWHT
unset BLK && declare BLK="\e[0;90m"
unset RED && declare RED="\e[0;91m"
unset GRN && declare GRN="\e[0;92m"
unset YEL && declare YEL="\e[0;93m"
unset BLU && declare BLU="\e[0;94m"
unset MGT && declare MGT="\e[0;95m"
unset CYN && declare CYN="\e[0;96m"
unset WHT && declare WHT="\e[0;97m"
unset LIL && declare LIL="$CYN"
unset LNK && declare LNK="$UND\e[1;96m"

#
# Bold colors
#
unset BBLK && declare BBLK="\e[1;90m"
unset BRED && declare BRED="\e[1;91m"
unset BGRN && declare BGRN="\e[1;92m"
unset BYEL && declare BYEL="\e[1;93m"
unset BBLU && declare BBLU="\e[1;94m"
unset BMGT && declare BMGT="\e[1;95m"
unset BCYN && declare BCYN="\e[1;96m"
unset BWHT && declare BWHT="\e[1;97m"
unset BLIL && declare BLIL="\e[1m$LIL"
unset BWOR && declare BWOR='\e[1;37;41m'

declare b_256color=false
if (($(tput -T "$TERM" colors) >= 256)); then
	b_256color=true
	unset LIL && declare LIL="\e[38;2;$((16#FF));$((16#99));$((16#FF))m"
	unset BLIL && declare BLIL="$BLD$LIL"
	unset LNK && declare LNK="$UND\e[1;38;5;39m"
fi

declare -i tb_lite=1
declare -i tb_dark=2
declare -i terminal_background=$tb_dark # default is dark terminal
declare b_color=true                    # default is colors on

# Terminal magic
#
declare -i tlines=$(tput lines)	# number of lines in the terminal
declare -i tcols=$(tput cols)	# number of columns in the terminal
declare CL1="\e["$tcols"D"	# column 1 of the current line
declare CCR="\e[K"    		# clear line and carriage return
declare UP1="\e[1A"		# move cursor up one line

declare punctset="#$%&'()*+,-./:;<=>?@[\\]^\`{|}~!\""
declare qstr="${MNU}'q'$OFF"
declare msgretry="${INF}Retry or type $qstr$INF to quit: $OFF"

# Exit codes and messages
declare -i ui_exit_ok=0
declare -i ui_err_invargc=1
declare -i ui_err_invfile=2
declare -i ui_err_invdir=3
declare -i ui_err_invlinec=4
declare -i ui_err_nofiles=5
declare -i ui_err_notdigit=6
declare -i ui_err_missing_arg=7
declare -i ui_err_bashver=8
declare -i ui_err_norepo=9
declare -i ui_err_invcmd=10
declare -i ui_err_invcmd_arg=11
declare -i ui_err_missing_exec=12
declare -i ui_err_invargval=13
declare -i ui_err_missingarg=14
declare -i ui_err_boundary="$ui_err_missingarg"

declare -a ui_err_msg=(
""
"Invalid argument count"
"Invalid file"
"Invalid directory"
"Invalid line count"
"No files found"
"not a didgit"
"missing argument"
"wrong bash version"
"not a valid git repo"
"not a valid command"
"not a valid command argument"
"missing executable"
"invalid argument value"
"Argument missing."
""
)

# Control-C exit code
# see http://www.tldp.org/LDP/abs/html/exitcodes.html
#
# If it hasn't been defined in the environment, then define it here.
#
declare -p CTLC_EXIT > /dev/null 2>&1 || declare -i CTLC_EXIT=130

declare ui_tempfile="/dev/shm/ui_temp_file"

# FUNCTIONS

# ui_exit
# @description Exit with exit code and corresponding message
#
# Arguments:
# @arg $1 int Exit code index into ui_err_msg array
# @arg $2 string Optional artifact to precede error message
#
# Returns:
# @exitcode * Exits with the provided exit code
#
ui_exit() {
	local -i msgindex="$1"
	local artifact="$2"
	local msg

	msg="$WRN${ui_err_msg[msgindex]}$OFF"
	[ -n "$artifact" ] && msg="$MNU$artifact $msg"
	echo -e "$msg"
	exit "$msgindex"
}

# ui_print_climsg
# @description Print command line interface error message
#
# Arguments:
# @arg $1 int ui_err* index into the error messages
# @arg $2 string Optional string to precede error message
#
# Globals:
# @set ui_err_msg array Array of exit messages
#
# Effects:
# @stdout Formatted error message
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_print_climsg() {
	local -i msgindex="$1"
	local str="$2"
	local msg
	echo
	msg="$CAU${ui_err_msg[msgindex]}$OFF"
	[ -n "$str" ] && msg="$msg$INF : $str"
	echo -e "$msg"
	return 0
}

# ui_testbash
# @description Test for bash 4.0 or higher
#   Exits with error if bash version is less than 4.0
#
# Returns:
# @exitcode 0 Bash version is 4.0+
# @exitcode * Exits via ui_exit if version too low
#
ui_testbash() {
	local verstr
	local warnstr

	warnstr=$(
cat <<EOF
$WRN
GNU bash version less than 4.0!$MNU
You must be using GNU bash 4.0 or higher.$OFF
\0
EOF
)
	verstr=$(bash --version | grep -m1 -o '[0-9].*')
	((${verstr:0:1} >= 4)) && return 0
	echo -e "$warnstr"
	ui_exit $ui_err_bashver
}

# ui_popterm
# @description Pop up a default user terminal, optionally executing a command
#
# Arguments:
# @arg $1 string Optional command to execute in the popup terminal (must be quoted)
#
# Example:
# @example ui_popterm 'less ~/bin/lib/ui.source'
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_popterm() {
	cmd="$1"
	if [ -n "$cmd" ]; then
		x-terminal-emulator -e "$cmd"
	else
		x-terminal-emulator
	fi
	return 0
}

# ui_get_screenbackground
# @description Query user for terminal background color preference
#   If not running in an interactive terminal (no TTY), defaults to dark.
#
# Globals:
# @set terminal_background int tb_lite or tb_dark
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_get_screenbackground() {
	# If not running in an interactive terminal, default to dark
	if [[ ! -t 0 ]]; then
		terminal_background=$tb_dark
		return 0
	fi

	echo
	echo "Is your terminal background best described as:"
	echo "1. light"
	echo "2. dark"

	loop_range 1 2 terminal_background
	return 0
}

# ui_set_colors
# @description Set color variables based on terminal background
#   Sets INF, MNU, STA, WRN, CAU, URL colors appropriate for light or dark background
#
# Globals:
# @set terminal_background int Must be set before calling
# @set b_color bool Whether colors are enabled
# @set INF string Info color
# @set MNU string Menu/heading color
# @set STA string Status/value color
# @set WRN string Warning color
# @set CAU string Caution color
# @set URL string URL/link color
#
# Returns:
# @exitcode 0 Colors set successfully
# @exitcode 1 Colors disabled (b_color=false)
#
ui_set_colors() {
	$b_color || {
		b_color=false
		INF=
		MNU="$BLD"
		STA="$BLD"
		WRN="$BLD"
		CAU="$BLD"
		URL="$UND"
		qstr="${STA}q${OFF}"
		return 1
	}

	case "$terminal_background" in
		"$tb_lite" ) INF="\033[38;5;90m"
			     MNU="\033[1;38;5;21m"
			     STA="\033[1;38;5;28m"
			     WRN="$BRED"
			     CAU="$BMGT"
			     URL="$BLU"
			     ;;
		"$tb_dark" ) INF="$YEL"
			     MNU="$BYEL"
			     STA="$BGRN"
			     # WRN="$BWOR"
			     WRN="$BRED"
			     CAU="$BLIL"
			     URL="$CYN"
			     ;;
	esac

	qstr="${STA}q${OFF}"

	return 0
}

# ui_isdarkbg
# @description Detect if terminal has dark background using OSC 11 query
#   Sends xterm OSC 11 escape sequence to query background RGB color.
#   Sums RGB components; if < 300 (~40% brightness), considers it dark.
#   Times out after 1 second if terminal doesn't respond.
#
# See:
# @see https://stackoverflow.com/questions/2507337/how-to-determine-a-terminals-background-color
#
# Returns:
# @exitcode 0 Dark background (or timeout - defaults to dark)
# @exitcode 1 Light background
#
ui_isdarkbg() {
	local bgraw
	local bg
	local -a bga=()
	local -i sum=0

	# Query terminal with 1 second timeout; default to dark if no response
	if ! read -rs -t 1 -d \\ -p $'\e]11;?\e\\' bgraw; then
		return 0  # timeout or error - assume dark
	fi

	bg=$(echo "$bgraw" | xxd -c 32 | cut -d':' -f3)
	ui_strtok "$bg" "/." bga

	for n in "${bga[@]}"; do ((sum += 0x${n:0:2})); done

	if ((sum < 300)); then
		return 0
	else
		return 1
	fi
}

# ui_setbg
# @description Automatically set colors for xterm, query for others
#   For xterm terminals, auto-detects background color.
#   For other terminals, queries user for preference.
#
# Arguments:
# @arg $1 int-ref Variable to receive background setting (tb_lite or tb_dark)
#
# Globals:
# @set b_color bool Set to true
# @set terminal_background int tb_lite or tb_dark
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_setbg() {
	local -n uibg="$1"

	b_color=true

	# If this is an xterm, we can automatically determine the
	# background color
	if [[ $TERM =~ "xterm" ]]; then
		if ui_isdarkbg; then
			uibg=$tb_dark
			terminal_background=$tb_dark
		else
			uibg=$tb_lite
			terminal_background=$tb_lite
		fi
		ui_set_colors
	else
		ui_use_colors
		uibg="$terminal_background"
	fi
	return 0
}

# ui_query_colors
# @description Query user for color preference and set colors
#
# Globals:
# @set b_color bool Whether colors are enabled
#
# Returns:
# @exitcode 0 Colors enabled and set
# @exitcode 1 Colors disabled by user
#
ui_query_colors() {
	[ -z $b_color ] && loop_yn "Do you want color text? y/n : " b_color
	$b_color || return 1
	ui_get_screenbackground
	ui_set_colors
	return 0
}

# ui_use_colors
# @description Enable colors and query for background preference
#
# Globals:
# @set b_color bool Set to true
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_use_colors() {
	b_color=true
	ui_get_screenbackground
	ui_set_colors
	return 0
}

# ui_do_colors
# @description Set colors with specified background preference
#
# Arguments:
# @arg $1 int Background setting (tb_lite or tb_dark)
#
# Globals:
# @set terminal_background int Set to provided value
# @set b_color bool Set to true
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_do_colors() {
	terminal_background="$1"
	b_color=true
	ui_set_colors
	return 0
}

# ui_putnchar
# @description Repeat print a character n times
#
# Arguments:
# @arg $1 string The character to repeat
# @arg $2 int The number of times to repeat it
#
# Effects:
# @stdout The repeated character string
#
# Example:
# @example 24_A=$(ui_putnchar "A" 24)  # creates "AAAAAAAAAAAAAAAAAAAAAAAA"
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_putnchar() {
	local ch="$1"
	local -i num="$2"
	local -i i

	((num <= 0)) && return 0
	eval printf -- "${ch}%.0s" {1..$num}
	return 0
}

# ui_rptchr
# @description Put a character repeatedly n times
#
# Arguments:
# @arg $1 string Character to repeat
# @arg $2 int Number of times to repeat
#
# Effects:
# @stdout The repeated character string
#
# Example:
# @example pad=$(ui_rptchr "-" 5)  # prints "-----"
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_rptchr() {
	local chr="$1"
	local -i num=$2
	local tstr=

	((num <= 0)) && return 0
	tstr="$(printf "%*c" $num "$chr")"
	echo "${tstr// /"$chr"}"
	return 0
}

# ui_padfield
# @description Pad a string with a character to fill a field (pad before)
#
# Arguments:
# @arg $1 string The string to pad
# @arg $2 string The pad character
# @arg $3 int The field width
#
# Effects:
# @stdout Padded string with padding before the content
#
# Example:
# @example paddedstr=$(ui_padfield "foo" "." 6)  # returns "...foo"
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_padfield() {
	local str="$1"
	local padch="$2"
	local -i fldw="$3"
	local -i padn
	local padstr

	((${#str} >= fldw)) && echo -n "$str" && return 0
	padn=$((fldw - ${#str}))
	padstr=$(ui_putnchar "$padch" "$padn")
	echo -n "$padstr$str"
	return 0
}

# ui_padfield_aft
# @description Pad a string with a character to fill a field (pad after)
#
# Arguments:
# @arg $1 string The string to pad
# @arg $2 string The pad character
# @arg $3 int The field width
#
# Effects:
# @stdout Padded string with padding after the content
#
# Example:
# @example paddedstr=$(ui_padfield_aft "foo" "." 6)  # returns "foo..."
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_padfield_aft() {
	local str="$1"
	local padch="$2"
	local -i fldw="$3"
	local -i padn
	local padstr

	((${#str} >= fldw)) && echo -n "$str" && return 0
	padn=$((fldw - ${#str}))
	padstr=$(ui_putnchar "$padch" "$padn")
	echo -n "$str$padstr"
	return 0
}

# ui_clearline
# @description Clear the current terminal line
#
# Globals:
# @set CL1 string Cursor to column 1 escape sequence
# @set CCR string Clear line and carriage return escape sequence
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_clearline() {
	# Erase the line and put the cursor back in the first column of the
	# line. Leave the TTY calls as discrete echos for the sake of
	# clarity. The bash interpreter will merge them anyway.
	#
	echo -en "$CL1"
	echo -en "$CCR"
	echo -en "$CL1"
	echo -en "$CCR"
	return 0
}

# ui_nclearline
# @description Clear the current line and move cursor up by n lines
#
# Arguments:
# @arg $1 int Number of lines to move cursor up
#
# Globals:
# @set CL1 string Cursor to column 1 escape sequence
# @set CCR string Clear line and carriage return escape sequence
# @set UP1 string Move cursor up one line escape sequence
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_nclearline() {
	local up="$1"
	local -i i
	# Erase the line and put the cursor back in the first column of the
	# line. Leave the TTY calls as discrete echos for the sake of
	# clarity. The bash interpreter will merge them anyway.
	#
	echo -en "$CL1"
	echo -en "$CCR"
	while ((up--)); do
		echo -en "$UP1"
	done
	echo -en "$CL1"
	echo -en "$CCR"
	return 0
}

# ui_waitonproc
# @description Print dots while waiting for a process to complete
#
# Arguments:
# @arg $1 int PID of process to wait for
# @arg $2 string Optional time interval (default: 1 second, supports decimals)
#
# Effects:
# @stdout Dots printed at specified intervals
#
# Returns:
# @exitcode * Exit status of the waited process
#
ui_waitonproc () {
    local -i pid="$1"
    local time="${2:-1}"
    local stat=0

    while kill -0 "$pid" > /dev/null 2>&1; do
        echo -n '.'
        sleep "$time"
    done

    wait "$pid" || stat=$?
    return $stat
}

# ui_waitonproc_tty
# @description Print dots with line wrap while waiting for a process
#   Dots wrap at screen edge, line is cleared when process completes.
#
# Arguments:
# @arg $1 int PID of process to wait for
# @arg $2 string Time interval (supports decimal fractions)
# @arg $3 string Optional text message to display first
#
# Globals:
# @set tcols int Number of terminal columns (used for wrapping)
#
# Effects:
# @stdout Dots and optional text message
#
# Returns:
# @exitcode * Exit status of the waited process
#
ui_waitonproc_tty () {
    local -i pid="$1"
    local tmo="$2"
    local txt="$3"
    local -i tcnt=1
    local -i stat=0

    [ -z "$txt" ] || echo -e "$txt"
    while kill -0 "$pid" > /dev/null 2>&1; do
        echo -n '.'
        sleep "$tmo"
	((++tcnt))

	((tcnt >= tcols)) && {
            ui_clearline
	    tcnt=1
    	}
    done

    # Leave the TTY as it was before we were called.
    #
    ui_clearline
    wait "$pid" || stat=$?
    return $stat
}

#######################
# User Input Routines
#######################

# getyn
# @description Get user 'y' or 'n' response to a prompt
#   Prompts user with colored text (if enabled) and waits for y/n input.
#
# Arguments:
# @arg $1 string Prompt string to display
# @arg $2 bool-ref Optional variable to receive true/false value
#
# Returns:
# @exitcode 0 User answered 'y'
# @exitcode 1 User answered 'n'
#
getyn() {
	local promptstring="$1"
	local -i argc=$#
	local answer

	((argc == 2)) && local -n uip_retval="$2"

	while true; do

		echo -en "$INF$promptstring $MNU(y/n) : $OFF"
		read -r -n1 answer
		echo

		if [[ $answer =~ [yY] ]]; then
			((argc == 2)) && uip_retval=true
			return 0
		fi

		if [[ $answer =~ [nN] ]]; then
			((argc == 2)) && uip_retval=false
			return 1
		fi

		echo -e "${INF}Please enter$MNU y$INF or$MNU n$OFF."
	done
}

# doyn
# @description Execute commands based on y/n user response
#
# Arguments:
# @arg $1 string Prompt string for getyn()
# @arg $2 string Command to execute if user responds 'y'
# @arg $3 string Optional command to execute if user responds 'n'
# @arg $4 bool-ref Optional variable to receive user response
#
# Returns:
# @exitcode 0 Always succeeds
#
doyn() {
	local promptstring="$1"
	local y_command="$2"
	local n_command="$3"
	local -i argc=$#
	local response

	((argc == 4)) && local -n uip_response="$4"

	getyn "$promptstring" response
	((argc < 3)) && n_command=""

	if $response ; then
		$y_command
	fi

	if ! $response ; then
		$n_command
	fi

	((argc == 4)) && uip_response="$response"
}

# getuser
# @description Read multi-character user input with backslash continuation
#   Lines ending in backslash are continued. Command strings are expanded.
#
# Arguments:
# @arg $1 string Prompt string to display
# @arg $2 string-ref Variable to receive user input
#
# Returns:
# @exitcode 0 Always succeeds
#
getuser() {
    local promptstring="$1"
    local -n uigu_var="$2"
    local input_line

    uigu_var=
    echo -ne "$INF$promptstring$OFF"

    # Read lines until the input doesn't end with a backslash
    while read -e -r input_line && [[ $input_line == *\\ ]]; do
        input_line="$(echo "$input_line" | sed 's/\\$//')"  # Remove backslash
        uigu_var+="$(eval "echo $input_line")"
        uigu_var+=" "
        echo -ne "$INF> $OFF"  # Add a continuation prompt
    done

    # Add the last line without the backslash
    uigu_var+="$(eval "echo $input_line" | sed 's/\\$//')"
    return 0
}

# getuser_noslash
# @description Read multi-character user input (no backslash continuation)
#
# Arguments:
# @arg $1 string Prompt string to display
# @arg $2 string-ref Variable to receive user input
#
# Returns:
# @exitcode 0 Always succeeds
#
getuser_noslash() {
	local promptstring="$1"
	local -n uigu_var="$2"

	echo -ne "$INF$promptstring$OFF"
	read -e -r uigu_var
	eval "uigu_var=\"$uigu_var\""
	return 0
}

# getkey
# @description Get modifier key combinations (hot keys)
#   Uses external compiled tool 'keypress' (see keypress.c)
#
# Arguments:
# @arg $1 string-ref Variable to receive the character
#
# Returns:
# @exitcode 0 Normal key pressed
# @exitcode 1 Alt-key combination pressed
#
getkey() {
	local -n gkp_char="$1"
	local foo
	local -i sts

	foo=$(keypress)
	sts=$?
	gkp_char=${foo: -1}
	echo
	return $sts
}

# promptgetkey
# @description Print a prompt and get a key press
#   User does not need to press RETURN/ENTER
#
# Arguments:
# @arg $1 string Prompt string (may include escape chars)
# @arg $2 string-ref Variable to receive the character
#
# Returns:
# @exitcode 0 Normal key pressed
# @exitcode 1 Alt-key combination pressed
#
promptgetkey() {
	echo -en "$1"
	getkey "$2"
	return $?
}

# getch
# @description Read one character without echoing
#   User does not need to press RETURN/ENTER
#
# Arguments:
# @arg $1 string-ref Variable to receive the character
#
# Returns:
# @exitcode 0 Always succeeds
#
getch() {
	local -n uichar="$1"
	read -r -n1 uichar
	return 0
}

# getchar
# @description Read one character and echo it to screen
#   User does not need to press RETURN/ENTER
#
# Arguments:
# @arg $1 string-ref Variable to receive the character
#
# Returns:
# @exitcode 0 Always succeeds
#
getchar() {
	local -n uigc_char="$1"
	read -r -n1 uigc_char
	echo
	return 0
}

# promptgetchar
# @description Print a prompt and get a character (with echo)
#   User does not need to press RETURN/ENTER
#
# Arguments:
# @arg $1 string Prompt string (may include escape chars)
# @arg $2 string-ref Variable to receive the character
#
# Returns:
# @exitcode 0 Always succeeds
#
promptgetchar() {
	echo -en "$1"
	getchar "$2"
	return 0
}

# loop_yn
# @description Loop until user enters 'y' or 'n'
#
# Arguments:
# @arg $1 string Prompt string to display
# @arg $2 bool-ref Optional variable to receive true/false value
#
# Returns:
# @exitcode 0 User answered 'y'
# @exitcode 1 User answered 'n'
#
loop_yn() {
	if [ -n "$2" ]; then local -n uilyn_retval="$2"; else local uilyn_retval; fi
	local ans

	while true; do
		promptgetchar "$1" ans
		[ -z "$ans" ] && continue
		[[ $ans =~ [yY] ]] && uilyn_retval=true  && return 0
		[[ $ans =~ [nN] ]] && uilyn_retval=false && return 1
		echo -e "${MNU}Please enter 'y' or 'n'.$OFF"
	done
}

# loop_yn_ro
# @description Loop until user enters 'y' or 'n' (return-only version)
#
# Arguments:
# @arg $1 string Prompt string to display
#
# Returns:
# @exitcode 0 User answered 'y'
# @exitcode 1 User answered 'n'
#
loop_yn_ro() {
	local ans
	while true; do
		promptgetchar "$1" ans
		[ -z "$ans" ] && continue
		[[ $ans =~ [yY] ]] && return 0
		[[ $ans =~ [nN] ]] && return 1
		echo -e "${MNU}Please enter 'y' or 'n'.$OFF"
	done
}

# loop_range
# @description Loop until user enters a number within specified range
#
# Arguments:
# @arg $1 int Minimum value
# @arg $2 int Maximum value
# @arg $3 int-ref Variable to receive user's choice
#
# Returns:
# @exitcode 0 Valid number entered
#
loop_range() {
	local min=$1
	local max=$2
	local number
	local cmd
	local pstr=\
"$OFF${INF}Please enter a number between $MNU$min$INF and $MNU$max$OFF: "

	((max < 10)) && cmd=promptgetchar || cmd=getuser
	# echo "cmd: $cmd"

	while true; do
		$cmd "$pstr" number

		if [[ $number =~ ^-?[0-9]+$ ]]  && \
		   [[ $number -ge $min ]]       && \
		   [[ $number -le $max ]]; then
			eval "$3"="$number"
			echo
			return 0
		fi
	done
}

# loop_range_q
# @description Loop until user enters a number within range or 'q' to quit
#
# Arguments:
# @arg $1 int Minimum value
# @arg $2 int Maximum value
# @arg $3 int-ref Variable to receive user's choice
#
# Returns:
# @exitcode 0 Valid number entered
# @exitcode 1 User pressed 'q' to quit
#
loop_range_q() {
	local min="$1"
	local max="$2"
	local number
	local cmd
	local pstr=\
"$OFF${INF}Please enter a number between $MNU$min$INF and $MNU$max$OFF or $qstr: "

	echo -e "${INF}Press $qstr$INF to return without making a selection.$OFF"
	((max < 10)) && cmd=promptgetchar || cmd=getuser
	# echo "cmd: $cmd"

	while true; do
		$cmd "$pstr" number

		if [[ $number =~ ^-?[0-9]+$ ]]  && \
		   [[ $number -ge $min ]]       && \
		   [[ $number -le $max ]]; then
			eval "$3"="$number"
			echo
			return 0
		elif [ "$number" = "q" ]; then
			return 1
		fi
	done
}

# select_from_array
# @description Select an item from an enumerated array list
#   Displays numbered list and prompts user to select one.
#
# Arguments:
# @arg $1 string Array name (without leading '$')
# @arg $2 string Prompt string describing what to select
# @arg $3 int-ref Variable to receive selected number
# @arg $4 string Optional second line of prompt
#
# Returns:
# @exitcode 0 Valid selection made
# @exitcode 1 User pressed 'q' to quit
#
select_from_array() {
	local contents="$1[@]"
	local promptstr="$2"
	local -n uisfa_current="$3"

	local -a array=("${!contents}")
	local -i asize=asize=${#array[@]}
	local -i i
	local element
	local selection

	(($# == 4)) && addlprompt="$4"

	echo -en "\n${MNU}Choose one of the $STA$promptstr$OFF"
	echo -e "$MNU in the following list.$OFF"
	[ -n "$addlprompt" ] && echo -e "$addlprompt"
	[ -n "$uisfa_current" ] && echo -e "${INF}Current selection is :$STA $uisfa_current$OFF"

	for ((i = 0; i < asize; ++i)); do
		element="${array[i]}"
		if [ "$element" == "$uisfa_current" ]; then
			echo -e "$STA * $((i+1)). $element$OFF"
		else
			echo -e "   $MNU$((i+1)).$OFF $element"
		fi
	done

	echo

	while true; do
		if loop_range_q 1 "$asize" selection; then
			eval "$3=\"${array[$((selection-1))]}\""
		else
			return 1
		fi

		if is_array_member array "$uisfa_current"; then
			break
		else
			echo -e "${STA}$uisfa_current$WRN is not a valid selection$OFF"
			continue
		fi
	done

	return 0
}

# is_array_member
# @description Determine if an item is a member of an array
#
# Arguments:
# @arg $1 string Array name (without leading '$')
# @arg $2 string The item to find
#
# Returns:
# @exitcode 0 Item found in array
# @exitcode 1 Item not found
#
is_array_member() {
	local -n uiiam_array="$1"
	local member="$2"

	local -a array=("${!contents}")
	local -i asize=${#uiiam_array[@]}
	local -i i
	local mem

	for ((i = 0; i < asize; ++i)); do
		mem=${uiiam_array[i]}
		[ "$mem" == "$member" ] && return 0
	done

	return 1
}

# is_validnumber
# @description Check if argument is a valid decimal integer
#
# Arguments:
# @arg $1 string Value to check
#
# Returns:
# @exitcode 0 Valid decimal integer
# @exitcode 1 Not a valid integer
#
is_validnumber() {
	local ui_num="$1"

	[ -n "$ui_num" ] && [[ $ui_num =~ ^-?[0-9]+$ ]] && return 0
	return 1
}

############################
# Directory Routines
#############################

# ui_getfilespec
# @description Get a pathname to a file, looping until valid
#
# Arguments:
# @arg $1 string Prompt to display
# @arg $2 string-ref Variable to receive the filespec
#
# Returns:
# @exitcode 0 Valid file obtained
# @exitcode 1 User pressed 'q' to quit
#
ui_getfilespec() {
	local prompt="$1"
	local filespec
	local retval=0
	local msginvfilnam="${WRN}Invalid file name. $msgretry"

	while :; do
		getuser "$prompt" filespec
		[ "$filespec" ] || echo -e "$msginvfilnam"
		[ "$filespec" = "q" ] && return 1
		[ -f "$filespec" ] && break
		echo -e "$WRN$filespec is not a valid file.$OFF"
	done

	eval "$2"="$filespec"
	return $retval
}

# ui_chkdir
# @description Check if a string is a file, directory, or neither
#
# Arguments:
# @arg $1 string Path to check
#
# Returns:
# @exitcode 0 Valid directory
# @exitcode 1 Empty string
# @exitcode 2 Exists as a file
# @exitcode 3 Neither file nor directory
# @exitcode 4 String is 'q' (quit)
#
ui_chkdir() {
	[ "$1" = "q" ] && return 4
	[ "$1" ]       || return 1
	[ -f "$1" ]    && return 2
	[ -d "$1" ]    || return 3
	return 0
}

# ui_verifydir
# @description Verify that a path is a valid directory
#
# Arguments:
# @arg $1 string Directory path to verify
#
# Effects:
# @stdout Error message if invalid
#
# Returns:
# @exitcode 0 Valid directory
# @exitcode 1 Invalid directory
#
ui_verifydir() {
	local dir="$1"
	local stat

	ui_chkdir "$dir"
	stat=$?

	case $stat in
		4 )	;&
		1 )	;&
		3 )	echo "$MNU\"$dir\"$WRN does not exist.$OFF"
			return 1
			;;
		2 )	echo -e "$MNU\"$dir\"$WRN already exists as a file.$OFF"
			return 1
	esac
	return 0
}

# ui_getnewdir
# @description Prompt user for a new directory name
#   Validates input and creates directory if needed.
#   If directory exists, asks user to confirm using it.
#
# Arguments:
# @arg $1 string Prompt to display
# @arg $2 string-ref Variable to receive directory name
#
# Returns:
# @exitcode 0 Valid existing directory
# @exitcode 3 Newly created directory
# @exitcode 4 User quitting
#
ui_getnewdir() {
	local prompt="$1"
	local newdir
	local stat
	local ans=true
	local exists="$CAU\"$newdir\" already exists as a file. $msgretry"
	local noexist="${INF}: does not exist.$OFF"
	local fail="${CAU}Could not create directory: $newdir$OFF"

	while true; do
		getuser "$prompt" newdir

		ui_chkdir "$newdir"
		stat=$?

		case $stat in
		0 ) 	eval "$2"="$newdir"	# valid existing directory
			return $stat
			;;
		1 )	echo -e "${WRN}Nothing entered. $msgretry"
			;;
		2 )	echo -e "$exists"
			;;
		3 )	echo -e "$STA$newdir $noexist"
			if getyn "Want to create $newdir now?"; then
				mkdir -p "$newdir" || {
					echo -e "$fail"
					continue
				}
			else
				continue
			fi
			eval "$2"="$newdir"
			return $stat
			;;
		4 )	# echo "ui_getnewdir: newdir: $newdir"
			return $stat	# user wants to quit trying
		esac
	done
}

# ui_testdir
# @description Test for directory existence and poll user for action
#
# Arguments:
# @arg $1 string Directory name to test
# @arg $2 string-ref Variable to receive directory name
#
# Returns:
# @exitcode 0 Directory created or doesn't exist
# @exitcode 2 Directory exists
#
ui_testdir() {
	local tstdir="$1"
	local stat
	local createstr="${INF}Want to create it now?$OFF"

	while true; do

		ui_chkdir "$tstdir"
		stat=$?

		if ((stat == 0)); then
			echo -e "$STA$tstdir$INF does not exist."
			doyn "$createstr" "mkdir -p $tstdir"
			eval "$2"="$tstdir"
			return $stat
		fi

		if ((stat == 1)); then
			echo -e "$STA$tstdir$INF exists as a file. Try again."
			getuser "Gimme a valid directory: " tstdir
			continue;
		fi

		if ((stat == 2)); then
			eval "$2"="$tstdir"
			return $stat
		fi
	done
}

# ui_remove_spaces
# @description Remove spaces from filenames in current directory
#   Replaces spaces with underscores. Call after cd to target directory.
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_remove_spaces() {
    local sp=" "
    while IFS= read -r -d '' file
    do
	[[ $file == *$sp* ]] || continue
	mv -v "$file" "$(echo "$file" | tr ' ' '_' )"
    done < <(find . -maxdepth 1 -type f -print0)
}

# ui_cd
# @description Change directory with error handling
#   Exits with error message if cd fails to prevent subsequent errors.
#
# Arguments:
# @arg $1 string Directory to change to (or "-" for previous)
#
# Returns:
# @exitcode 0 Successfully changed directory
# @exitcode * Exits via ui_exit on failure
#
ui_cd() {
	local dir="$1"
	local dirstr

	if [ "$dir" == "-" ]; then dirstr="cd -"; else dirstr="$dir"; fi

	cd "$dir" > /dev/null || ui_exit "$ui_err_invdir" "$dirstr"
}

##########################
# Miscellaneous
##########################

# ui_catoneline
# @description Output the nth line of a file
#
# Arguments:
# @arg $1 string File path
# @arg $2 int Line number (1-based)
#
# Effects:
# @stdout The specified line
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_catoneline() {
	head -"$2" "$1" | tail -1
}

# ui_replaceline
# @description Replace a numbered line in a file
#   Uses line number instead of pattern matching.
#
# Arguments:
# @arg $1 int Line number to replace
# @arg $2 string New text for the line
# @arg $3 string File path
#
# Returns:
# @exitcode 0 Line replaced successfully
# @exitcode 1 Line number exceeds file length
# @exitcode * Invalid argument count
#
ui_replaceline() {
	local -i line
	local new_content

	(($# != 3)) && return "$ui_err_invargc"
	check_lineargs "$1" "$3" || return $?
	awk -v line="$1" -v new_content="$2" '{
		if (NR == line) {
			print new_content;
		} else {
			print $0;
		}
	}' "$3" > "$ui_tempfile"
	[ -f "$ui_tempfile" ] && mv -f "$ui_tempfile" "$3"

	return 0
}

# ui_replaceline_raw
# @description Replace a numbered line in a file (no validation)
#   Raw version - does not validate arguments. Use with caution.
#
# Arguments:
# @arg $1 int Line number to replace
# @arg $2 string New text for the line
# @arg $3 string File path
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_replaceline_raw() {
	local -i line
	local new_content

	awk -v linenum="$1" -v newtext="$2" \
		'NR==linenum {$0=newtext} {print}' \
		"$3" > "$ui_tempfile"
	[ -f "$ui_tempfile" ] && mv -f "$ui_tempfile" "$3"

	return 0
}

# check_lineargs
# @description Validate line number and file arguments
#
# Arguments:
# @arg $1 int Line number to validate
# @arg $2 string File path to validate
#
# Returns:
# @exitcode 0 Arguments are valid
# @exitcode * Various ui_err_* codes on failure
#
check_lineargs() {
	local -i number="$1"
	local file="$2"
	local -i lines
	local -i argc=$#

	((argc == 2)) || return "$ui_err_invargc"
	ui_isdigit "$number" return "$ui_err_notdigit"
	((number > 0)) || return "$ui_err_invargc"
	[ -f "$file" ] || return "$ui_err_invfile"
	lines=$(wc -l < "$file")
	((number > lines)) && return "$ui_err_invlinec"
	((number == 0)) && return "$ui_err_invlinec"
	return 0
}

# ui_readline
# @description Read a numbered line from a file
#
# Arguments:
# @arg $1 int Line number to read
# @arg $2 string File path
#
# Effects:
# @stdout The specified line
#
# Returns:
# @exitcode 0 Success
# @exitcode * Various ui_err_* codes on invalid input
#
ui_readline() {
	local -i line

	check_lineargs "$1" "$2" || return $?

	awk -v line="$1" '{
		if (NR == line) {
			print $0;
		}
	}' "$2"
	return 0
}

# ui_readline_raw
# @description Read a numbered line from a file (no validation)
#   Raw version - no input consistency checks.
#
# Arguments:
# @arg $1 int Line number to read
# @arg $2 string File path
#
# Effects:
# @stdout The specified line
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_readline_raw() {
	local -i line

	awk -v line="$1" '{
		if (NR == line) {
			print $0;
		}
	}' "$2"
	return 0
}

# ui_insertline
# @description Insert a line into a file at the given line number
#   If line number exceeds file length, line is appended.
#
# Arguments:
# @arg $1 int Line number for insertion
# @arg $2 string Text to insert
# @arg $3 string File path
#
# Returns:
# @exitcode 0 Success
# @exitcode * Various ui_err_* codes on invalid input
#
ui_insertline() {
	local -i lc
	local -i line
	local new_content

	lc=$(wc -l < "$3")

	(($# == 3)) || return "$ui_err_invargc"

	ui_isdigit "$1" || return "$ui_err_notdigit"

	[ -f "$3" ] || return "$ui_err_invfile"

	if (($1 > lc)); then
		echo "$2" >> "$3"
	else
		awk -v line="$1" -v new_content="$2" '{
			if (NR == line) {
				print new_content;
			}
			print $0;
		}' "$3" > "$ui_tempfile"
		mv -f "$ui_tempfile" "$3"
	fi
}

# ui_deleteline
# @description Delete a line from a file at the given line number
#
# Arguments:
# @arg $1 int Line number to delete
# @arg $2 string File path
#
# Returns:
# @exitcode 0 Success
# @exitcode * Various ui_err_* codes on invalid input
#
ui_deleteline() {
	local -i line

	check_lineargs "$1" "$2" || return $?

	awk -v line="$1" '{
		if (NR != line) {
			print $0;
		}
	}' "$2" > "$ui_tempfile"
	mv -f "$ui_tempfile" "$2"
}

# ui_toggle
# @description Toggle a boolean value
#
# Arguments:
# @arg $1 bool-ref Variable name to toggle (true <-> false)
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_toggle() {
	local boolean=${!1}
	if $boolean; then eval "$1"=false; else eval "$1"=true; fi
}

# ui_cycle_state_ofs
# @description Cycle through states of a variable with offset
#
# Arguments:
# @arg $1 int-ref Variable to cycle
# @arg $2 int Number of states
# @arg $3 int Minimum state value (offset)
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_cycle_state_ofs() {
	local -n uics_var=$1
	local states=$2
	local minstat=$3
	local maxstat=$((minstat + states))

	((++uics_var))
	((uics_var >= maxstat)) && uics_var=$minstat
}

# ui_cycle_state
# @description Cycle through states of a variable (0 to n-1)
#
# Arguments:
# @arg $1 int-ref Variable to cycle
# @arg $2 int Number of states
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_cycle_state() {
	local -n uics_var=$1
	local states=$2

	((++uics_var))
	((uics_var >= states)) && uics_var=0
}

# ui_digit2bool
# @description Convert 0/1 to false/true
#
# Arguments:
# @arg $1 bool-ref Variable containing 0 or 1 to convert
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_digit2bool() {
	local boolean=${!1}
	if $boolean; then eval "$1"=true; else eval "$1"=false; fi
}

# ui_strindex
# @description Find index of substring in string
#
# Arguments:
# @arg $1 string String to search
# @arg $2 string Substring to find
#
# Effects:
# @stdout Zero-based index, or -1 if not found
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_strindex() {
	local x="${1%%$2*}"
	[[ $x = "$1" ]] && echo -1 || echo ${#x}
}

# ui_getlastch
# @description Find position of last occurrence of character in string
#
# Arguments:
# @arg $1 string Character to find
# @arg $2 string String to search
#
# Effects:
# @stdout Zero-based position, or 0 if not found
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_getlastch() {
	ch="$1"
	str="$2"

	echo "$str" | awk -F"$ch" '{print length($0)-length($NF)}'
}

# ui_inarray
# @description Look for an integer in an integer array
#
# Arguments:
# @arg $1 int Value to find
# @arg $2 string Array reference (without '$', e.g., 'array[@]')
# @arg $3 int-ref Optional variable to receive found index
#
# Example:
# @example ui_inarray 12 array[@] index
#
# Returns:
# @exitcode 0 Value found
# @exitcode 1 Value not found
#
ui_inarray() {
	local -i index="$1"
	local -a ary=("${!2}")
	local -i i
	local -i j=0

	(($# == 3)) && local -i -n jdx="$3"

	for i in "${ary[@]}"; do
		if ((i == index)); then

			# If there is a third argument, then give it the value
			# of the current index, j.
			#
			(($# == 3)) && jdx="$j"
			return 0
		fi
		((j++))
	done

	return 1
}

# ui_nextinarray
# @description Find next highest integer in a sorted array
#   Array must be in ascending order.
#
# Arguments:
# @arg $1 int Input value
# @arg $2 string Array reference (without '$', e.g., 'array[@]')
# @arg $3 int-ref Variable to receive index of next higher value
#
# Example:
# @example ui_nextinarray 5 array[@] next
#
# Returns:
# @exitcode 0 Found next higher value
# @exitcode 1 Input is higher than all array values
#
ui_nextinarray() {
	local -i index="$1"
	local -a ary=("${!2}")
	local -i -n jdx="$3"
	local -i i

	jdx=0

	for i in "${ary[@]}"; do
		if ((i > index)); then
			return 0
		fi
		((jdx++))
	done

	jdx=$((${#ary[@]} - 1 ))
	return 1
}

# ui_aryindex
# @description Find index of exact matching string in array
#
# Arguments:
# @arg $1 array-ref Array name (without '$')
# @arg $2 string String to find
# @arg $3 int-ref Variable to receive index
#
# Returns:
# @exitcode 0 Match found
# @exitcode 1 No match found
#
ui_aryindex () {
    local -n ar=$1
    local fld="$2"
    local -n ix=$3

    for ((ix = 0; ix < ${#ar[@]}; ix++))
    do
        [ "${ar[ix]}" == "$fld" ] && break
    done

    ((ix < ${#ar[@]})) && return 0 || return 1
}

# ui_isdigit
# @description Check if argument is a decimal digit
#
# Arguments:
# @arg $1 string Value to check
#
# Returns:
# @exitcode 0 Is a decimal digit
# @exitcode 1 Not a decimal digit
#
ui_isdigit() {
	[[ $1 =~ ^-?[0-9]+$ ]] && return 0 || return 1
}

# ui_isxdigit
# @description Check if argument is a hexadecimal digit
#
# Arguments:
# @arg $1 string Value to check
#
# Returns:
# @exitcode 0 Is a hex digit
# @exitcode 1 Not a hex digit
#
ui_isxdigit() {
	[[ $1 =~ ^-?[0-9a-fA-F]+$ ]] && return 0 || return 1
}

# ui_strtok
# @description Tokenize a string into an array using delimiters
#
# Arguments:
# @arg $1 string String to tokenize
# @arg $2 string Delimiter characters
# @arg $3 array-ref Variable to receive token array
#
# Example:
# @example ui_strtok "kernel-pegas-4.11.0" ".-" array
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_strtok() {
	IFS="$2" read -r -a "$3" <<< "$1"
}

# ui_trunc_string
# @description Truncate string to fit terminal width minus padding
#
# Arguments:
# @arg $1 string String to truncate
# @arg $2 int Optional padding to subtract from terminal width
#
# Globals:
# @set tcols int Terminal column count
#
# Effects:
# @stdout Truncated string
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_trunc_string() {
	local str="$1"
	local pad=$2
	local strlen

	[ $# -lt 2 ] && pad=0

	strlen=$((tcols - pad))
	echo "${str:0:$strlen}"
}

# ui_call
# @description Call a function and save its exit status
#
# Arguments:
# @arg $1 string Function or command to execute
# @arg $2 int-ref Variable to receive exit status
#
# Returns:
# @exitcode * Returns the status of the called function
#
ui_call() {
	local uic_cmd="$1"
	local -n uic_stat=$2

	$uic_cmd
	uic_stat=$?
	return $uic_stat
}

##################
# Debug Routines
##################

# ui_press_any
# @description Prompt user to press any key to continue
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_press_any() {
	echo -en "${MNU}Press any key to continue ...$OFF "
	read -r -n1
	return 0
}

# ui_press_any_ctlc
# @description Prompt to press any key or ctrl-c to exit
#
# Returns:
# @exitcode 0 User pressed a key
#
ui_press_any_ctlc() {
	echo -en "
${MNU}Press any key to continue or$CAU ctrl-c$MNU to exit ...$OFF "
	read -r -n1
	echo
	return 0
}

# ui_callwstat
# @description Call a function, print its status, and pause
#
# Arguments:
# @arg $1 string Function or command to execute
#
# Returns:
# @exitcode * Returns the status of the called function
#
ui_callwstat() {
	local uicws_cmd="$1"
	local uicws_stat

	echo -e "${INF}Executing $MNU$uicws_cmd$OFF"
	ui_press_any
	$uicws_cmd
	uicws_stat=$?
	echo -e "${MNU}$uicws_cmd ${INF}return status: $MNU$uicws_stat$OFF"
	ui_press_any
	return $uicws_stat
}

declare b_ulog_inited=false

# ui_log
# @description Log activity to a log file
#   Requires $MYDATA and $MYNAME to be set by sourcing script.
#   Skips logging if set -x is active.
#
# Arguments:
# @arg $1 string Message to log
#
# Globals:
# @set b_ulog_inited bool Ensures log file init happens once
# @set MYDATA string Data directory path
# @set MYNAME string Script name
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_log() {
	# If set -x, then just return.
	[[ $- == *x* ]] && return

	[ -d "$MYDATA" ] || return
	[ -n "$MYNAME" ] || return

	local str="$1"
	local logfile="${MYDATA%/}"/"${MYNAME}.log"

	[ -d "$MYDATA" ] || mkdir -p "$MYDATA"

	$b_ulog_inited || echo -e "Start: $(date '+%Y-%m-%d %H:%M:%S')" > "$logfile"
	b_ulog_inited=true

	echo -e "$(date '+%M:%S'): $str" >> "$logfile"
}

# ui_trunclog
# @description Truncate the log file to specified number of lines
#
# Arguments:
# @arg $1 int Optional line count (default: 100)
#
# Globals:
# @set MYDATA string Data directory path
# @set MYNAME string Script name
#
# Returns:
# @exitcode 0 Always succeeds
#
ui_trunclog() {
	[ -d "$MYDATA" ] || return
	[ -n "$MYNAME" ] || return

	local logfile="${MYDATA%/}"/"${MYNAME}.log"
	[ -f "$logfile" ] || return

	local lines="${1:-100}"
	local tmpfil="$(mktemp)"
	[ -z "$lines" ] && lines=100
	tail -n "$lines" "$logfile" > "$tmpfil"
	mv -f "$tmpfil" "$logfile" > /dev/null 2>&1
}

# enum
# @description Create auto-incremented enum variables with boundary markers
#   Creates prefix_first, prefix_item1, prefix_item2, ..., prefix_boundary
#
# Arguments:
# @arg $1 string Prefix for enum variable names
# @arg $@ string List of enum item names
#
# Returns:
# @exitcode 0 Always succeeds
#
enum() {
	local prefix="$1"
	local indx=1
	shift

	eval "declare -g ${prefix}_lower=${indx}"
	for item in $@; do
		eval "declare -g ${prefix}_${item}=${indx}"
		((++indx))
	done
	eval "declare -g ${prefix}_upper=$((--indx))"
}
