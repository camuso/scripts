#!/bin/bash
#
# config-manager.source
#
# The configfile must be declared and defined globally and externally.
#

[ "$MYDIR" ] || declare MYDIR=$(dirname $(which $(basename $0)))
[ "$MYLIB" ] || declare MYLIB=$MYDIR/lib
[ "$ui_loaded" ] || source $MYLIB/ui.source

declare configmanager_loaded=true

declare -i cfg_err_nokey=1
declare -i cfg_err_invopt=2
declare -i cfg_err_invoper=3
declare -i cfg_err_notready=4
declare cfg_file=
declare cfg_template=
declare cfg_b_ready=false

cfg_manager_help() {
	local helpmsg=$(
cat <<EOF
	The config manager bash routines provide a means for maintaining
	a config file of global variables with each line formatted as ...

		key = value

	... where 'key' is the name of the variable that will be assigned
	the value.

	Scripts can then call these routines to obtain or update values
	in their respective config files.

	To use the config manager, you must first supply two files
	One is the template which will be updated when saved variables
	change. The other is the individual config file for the script
	using this config manager.

	The cfgtemplate file will be tested against the config file by
	cfg_init to see if there have been any changes in config variables
	If so, the existing configfile will be updated to match the
	contents of the cfgfile.

	Init sequence:
	cfg_set_template <template for the main script's config file>
	cfg_set_configfile <main script's config file>
	cfg_init - copies the contents of the configfile to the caller's
	           global variables stored in the configfile

EOF
)
	echo -e "$helpmsg"
}

cfg_set_configfile() {
	cfg_file="$1"
	[ -f $cfg_template ] && cfg_b_ready=true
}

cfg_get_configfile() {
	eval $1="$cfg_file"
}

cfg_set_template() {
	cfg_template="$1"
	[ -f $cfg_file ] && cfg_b_ready=true
}

cfg_err_msg=(
	""
	"Key not found"
	"Invalid option"
	"Invalid operation"
	"Config files missing: need config template and config file"
)

cfg_show_err() {
	local err=$1
	local val="$2"

	echo -e "\n$WRN${cfg_err_msg[$err]} $INF: $STA$val$OFF"
	return $err
}

cfg_test_ready() {
	$cfg_b_ready || {
		echo -e "\n$WRN${cfg_err_msg[$cfg_err_notready]}$OFF"
		return $cfg_err_notready
	}
}

cfg_read_key() {
	local key="$1"
	local keyline=
	local ary

	$cfg_test_ready || return $cfg_err_notready

	keyline=$(grep -w $key $cfg_file)
	[ $? -eq 0 ] || {
		cfg_show_err $cfg_err_nokey $key
		return $cfg_err_nokey
	}
	ui_strtok "$keyline" "= " ary
	echo ${ary[1]}
}

cfg_write_key() {
	local key="$1"
	local value="$2"
	local keyline=
	local linenumber=

	$cfg_test_ready || return $cfg_err_notready

	keyline=$(grep -nw "$key" "$cfg_file")
	[ $? -eq 0 ] || {
		cfg_show_err $cfg_err_nokey $key
		return $cfg_err_nokey
	}
	linenumber=$(echo "$keyline" | cut -d":" -f1)
	keyline=$(echo "$keyline" | cut -d":" -f2- | cut -d"=" -f1)
	keyline="$keyline""= $value"
	ui_replaceline_raw $linenumber "$keyline" "$cfg_file"
}

cfg_compare_configfiles() {
	local key1=
	local key2=
	local tmp=
	local stat=

	$cfg_test_ready || return $cfg_err_notready

	[ $(cat "$cfg_template" | wc -l) -ne $(cat "$cfg_file" | wc -l) ] && return 1

	exec 5<"$cfg_template"
	exec 6<"$cfg_file"

	while :; do
		read -r -u 5 key1 tmp || { stat=0; break; }
		read -r -u 6 key2 tmp
		[ "$key1" == "$key2" ] || { stat=1; break; }
	done

	exec 5<&-
	exec 6<&-
	return $stat
}

cfg_read_configfile() {
	local confline=
	local lary

	$cfg_test_ready || return $cfg_err_notready

	while read confline; do
		ui_strtok "$confline" "= " lary
		eval ${lary[0]}=${lary[1]}
	done < $cfg_file
}

cfg_update_configfile() {
	local key1=
	local tmp=
	local tmpfile=/dev/shm/cfg_temp
	local stat=

	$cfg_test_ready || return $cfg_err_notready

	exec 5<"$cfg_template"
	> $tmpfile

	while :; do
		read -r -u 5 key1 tmp || break
		cfgline=$(grep "^$key1" $cfg_file) \
			&& echo "$cfgline" >> $tmpfile \
			|| echo "$key1 $tmp" >> $tmpfile
	done

	cp -f $tmpfile $cfg_file
	rm -f $tmpfile

	exec 5<&-
}

cfg_init() {
	cfg_compare_configfiles || cfg_update_configfile
	cfg_read_configfile
}
