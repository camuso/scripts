#!/bin/bash
#
# config-manager.source
#
# The configfile must be declared and defined globally and externally.
#

[ "$MYDIR" ] || declare MYDIR=$(dirname $(which $(basename "$0")))
[ "$MYLIB" ] || declare MYLIB=$MYDIR/lib
[ "$ui_loaded" ] || source $MYLIB/ui.source

declare configmanager_loaded=true

declare -i cfg_err_nokey=1
declare -i cfg_err_invopt=2
declare -i cfg_err_invoper=3
declare -i cfg_err_notready=4
declare -i cfg_err_invdir=5
declare -i cfg_err_invtemplate=6
declare cfg_file=
declare cfg_template=
declare cfg_b_ready=false

cfg_manager_help() {
	local helpmsg=$(
cat <<EOF
	The config manager bash routines provide a means for maintaining
	a config file of global variables with each line formatted as ...

		key = value

	... where 'key' is the name of the variable that will be assigned
	the value.

	Scripts can then call these routines to obtain or update values
	in their respective config files.

	To use the config manager, you must first supply two files
	One is the template which will be updated when saved variables
	change. The other is the individual config file for the script
	using this config manager.

	The cfgtemplate file will be tested against the config file by
	cfg_init to see if there have been any changes in config variables
	If so, the existing configfile will be updated to match the
	contents of the cfgfile.

	Init sequence:
	cfg_set_template <template for the main script's config file>
	cfg_set_configfile <main script's config file>
	cfg_init - copies the contents of the configfile to the caller's
	           global variables stored in the configfile

EOF
)
	echo -e "$helpmsg"
}

cfg_err_msg=(
	""
	"Key not found"
	"Invalid option"
	"Invalid operation"
	"Config files missing: need config template and config file"
	"Invalid directory"
	"Invalid template file"
)

cfg_show_err() {
	local err=$1
	local val="$2"

	echo -e "\n$WRN${cfg_err_msg[$err]} $INF: $STA$val$OFF"
	return $err
}

cfg_set_configfile() {
	cfg_file="$1"
	[ -f $cfg_template ] && cfg_b_ready=true
}

cfg_get_configfile() {
	eval $1="$cfg_file"
}

cfg_set_template() {
	cfg_template="$1"
	[ -f "$cfg_file" ] && cfg_b_ready=true
}

cfg_start() {
	cfg_template="$1"
	cfg_file="$2"
	local cfgdir

	cfgdir=$(dirname "$cfg_file")

	[ -f "$cfg_template" ] || cfg_show_err "$cfg_err_invtemplate" "$cfg_template"
	[ -d "$cfgdir"   ]     || cfg_show_err "$cfg_err_invdir" "$cfgdir"

	cfg_set_template "$cfg_template"

	[ -f "$cfg_file" ] || {
		cp "$cfg_template" "$cfg_file" || {
			echo -e "${WRN}Cannot copy $MNU$cfg_template$WRN to $MNU$cfg_file!$OFF"
			exit 1
		}
	}

	cfg_b_ready=true
	cfg_init
}

cfg_test_ready() {
	$cfg_b_ready || {
		echo -e "\n$WRN${cfg_err_msg[$cfg_err_notready]}$OFF"
		return $cfg_err_notready
	}
}

cfg_read_key() {
	local key="$1"
	local keyline=
	local value

	$cfg_test_ready || return $cfg_err_notready

	keyline=$(grep -w $key $cfg_file) || {
		cfg_show_err $cfg_err_nokey $key
		return $cfg_err_nokey
	}

	shopt -s extglob # ON to enable trimming spaces
	value="$(echo "$keyline" | cut -d'=' -f2-)"
	value="${value##*( )}"
	shopt -u extglob # OFF
	echo "$value"
}

cfg_get_item() {
	local key="$1"
	local -n cfg_item="$2"

	cfg_item=$(cfg_read_key "$key")
}

cfg_write_key() {
	local key="$1"
	local value="$2"
	local keyline=
	local linenumber=

	$cfg_test_ready || return $cfg_err_notready

	keyline=$(grep -nw "$key" "$cfg_file") || {
		cfg_show_err $cfg_err_nokey $key
		return $cfg_err_nokey
	}
	linenumber=$(echo "$keyline" | cut -d":" -f1)
	keyline=$(echo "$keyline" | cut -d":" -f2- | cut -d"=" -f1)
	keyline="$keyline""= $value"
	ui_replaceline_raw $linenumber "$keyline" "$cfg_file"
}

cfg_set_item() {
	local key="$1"
	local item="$2"

	cfg_write_key "$key" "$item"
}

cfg_compare_configfiles() {
	local key1=
	local key2=
	local tmp=
	local stat=

	$cfg_test_ready || return $cfg_err_notready

	[ $(cat "$cfg_template" | wc -l) -ne $(cat "$cfg_file" | wc -l) ] && return 1

	exec 5<"$cfg_template"
	exec 6<"$cfg_file"

	while :; do
		read -r -u 5 key1 tmp || { stat=0; break; }
		read -r -u 6 key2 tmp
		[ "$key1" == "$key2" ] || { stat=1; break; }
	done

	exec 5<&-
	exec 6<&-
	return $stat
}

cfg_read_configfile() {
	local confline=
	local item
	local value

	$cfg_test_ready || return $cfg_err_notready

	shopt -s extglob # ON to enable trimming spaces
	while read confline; do
		# Find the first '='.
		item="$(echo "$confline" | cut -d'=' -f1)"
		# strip any trailing spaces
		item="${item%%*( )}"
		# extract the value string
		value="$(echo "$confline" | cut -d'=' -f2-)"
		# strip any leading spaces
		value="${value##*( )}"
		# Assign the value to the item
		eval "$item"="$value"
	done < "$cfg_file"
	shopt -u extglob # OFF
}

cfg_update_configfile() {
	local confline=
	local item

	shopt -s extglob # ON to enable trimming spaces
	while read confline; do
		item="$(echo "$confline" | cut -d'=' -f1)"
		item="${item%%*( )}"
		eval "$item"="${!item}"
	done < "$cfg_file"
	shopt -u extglob # OFF
}

cfg_refresh_configfile() {
	local key1=
	local tmp=
	local tmpfile=/dev/shm/cfg_temp
	local stat=

	$cfg_test_ready || return $cfg_err_notready

	exec 5<"$cfg_template"
	> $tmpfile

	while :; do
		read -r -u 5 key1 tmp || break
		cfgline=$(grep "^$key1" $cfg_file) \
			&& echo "$cfgline" >> $tmpfile \
			|| echo "$key1 $tmp" >> $tmpfile
	done

	cp -f $tmpfile $cfg_file
	rm -f $tmpfile

	exec 5<&-
}

cfg_init() {
	cfg_compare_configfiles || cfg_refresh_configfile
	cfg_read_configfile
}

# cfg_init_ready - init for rw access only
#
# This function inits the config manager for a config file that
# is ready for r/w access without a full init to compare with the
# template and read every key.
#
cfg_init_ready() {
	cfg_file="$1"
	cfg_b_ready=true
}
