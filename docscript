#!/bin/bash
#
# docscript - Extract and display documentation from shell scripts
#
# Supports two documentation formats:
#   1. Legacy format: #** to start, #* to end
#   2. shdoc format: # @description, # @arg, # @exitcode, etc.
#
# Script-level documentation uses: # scriptname - description
#
# This file uses shdoc-style annotations. See: https://github.com/reconquest/shdoc
#
# Common annotations:
#   @description  - Function/script description
#   @arg          - Function argument: @arg $1 type description
#   @set          - Global variable set: @set varname type description
#   @exitcode     - Exit code: @exitcode 0 description
#   @stdout       - Standard output description
#   @example      - Usage example
#
# Use 'docscript -f funcname <scriptname>' to view function documentation.
#
# Usage:
#   docscript myscript.sh           # List documented functions (concise)
#   docscript -s myscript.sh        # Include script description header
#   docscript -v myscript.sh        # Verbose (auto-includes script desc)
#   docscript -f funcname script.sh # Show specific function only

declare MYDIR=
declare MYLIB=
declare MYDATA=
declare usagestr=
declare optcount=0
declare b_verbose=false
declare b_script=false
declare file=
declare b_func=false
declare fname=

MYDIR="$(dirname "$(readlink -f "$0")")"
MYLIB="$MYDIR"/lib
MYDATA=$(realpath ./.data)
[ -d "$MYDATA" ] || mkdir -p "$MYDATA"

source "$MYLIB"/ui.source

# Universal colors that work on both dark and light backgrounds
# These override any colors from ui.source
MNU=$'\033[1;36m'   # Bright cyan - headings/menu items
STA=$'\033[1;32m'   # Bright green - status/values
WRN=$'\033[1;33m'   # Bright yellow - warnings
INF=$'\033[1;35m'   # Bright magenta - info
OFF=$'\033[0m'      # Reset

usagestr=$(
cat <<EOF

$(basename "$0") [options] file

Extract and display documentation from shell scripts.

Supports two documentation formats:
  1. Legacy: #** ... #* delimited blocks
  2. shdoc:  # @description, # @arg, # @exitcode, etc.

Script-level documentation uses the format:
  # scriptname - Brief description

Arguments
---------
   file : script with documentation comments

Options
-------
  -s      : show script description header (concise mode only)
  -v      : verbose output with full documentation blocks
            (automatically includes script description)
  -f func : show documentation for specific function only
            (does not show script description)
  -h      : this help text

Examples
--------
  $(basename "$0") myscript.sh           # List functions (concise)
  $(basename "$0") -s myscript.sh        # Include script description
  $(basename "$0") -v myscript.sh        # Full docs (includes script desc)
  $(basename "$0") -f parse myscript.sh  # Show only 'parse' function
\0
EOF
)

# control_c
# @description Handle Ctrl-C interrupt
#
# Returns:
# @exitcode 130 Always exits with SIGINT code
#
control_c() {
	echo -e "\nCtrl-c detected\nCleaning up and exiting."
	exit $CTLC_EXIT
}

# parseopts
# @description Parse command line options
#
# Globals:
# @set optcount int Number of options parsed
# @set b_verbose bool Whether to show verbose output
# @set b_script bool Whether to show script description
# @set b_func bool Whether filtering by function name
# @set fname string Function name to filter (if -f used)
#
# Returns:
# @exitcode 0 Always succeeds
#
parseopts() {
	local arg=
	local opt=

	for arg in $@; do

	    if [ "${arg:0:1}" == "-" ]; then
		opt="${arg:1}"
		shift
		((optcount++))

		case "$opt" in
		s ) b_script=true
		    ;;
		v ) b_verbose=true
		    ;;
		f ) fname="$1"
		    b_verbose=true
		    b_func=true
		    shift
		    ((optcount++))
		    ;;
		h ) echo -e "$usagestr"
		    exit 0
		esac
	    fi
	done

	return 0
}

# is_shdoc_start
# @description Check if line starts an shdoc documentation block
#
# Arguments:
# @arg $1 string Line to check
#
# Returns:
# @exitcode 0 Line starts shdoc block (# @description)
# @exitcode 1 Line does not start shdoc block
#
is_shdoc_start() {
	local line="$1"
	[[ "$line" =~ ^[[:space:]]*#[[:space:]]*@description ]]
}

# is_shdoc_comment
# @description Check if line is part of an shdoc documentation block
#
# Arguments:
# @arg $1 string Line to check
#
# Returns:
# @exitcode 0 Line is a comment (part of doc block)
# @exitcode 1 Line is not a comment (end of doc block)
#
is_shdoc_comment() {
	local line="$1"
	[[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]
}

# format_shdoc
# @description Format shdoc buffer into human-readable output
#   Converts @arg, @set, @exitcode, @stdout annotations into
#   grouped, formatted sections.
#
# Arguments:
# @arg $1 string The accumulated shdoc buffer
#
# Effects:
# @stdout Formatted documentation
#
# Returns:
# @exitcode 0 Always succeeds
#
format_shdoc() {
	local buffer="$1"
	local -a args=()
	local -a globals=()
	local -a exitcodes=()
	local -a stdout_lines=()
	local -a desc_lines=()
	local line
	local content

	# Parse buffer into categories
	while IFS= read -r line; do
		# Remove leading # and whitespace
		line="${line#\#}"
		line="${line#"${line%%[![:space:]]*}"}"

		if [[ "$line" =~ ^@description[[:space:]]*(.*) ]]; then
			[[ -n "${BASH_REMATCH[1]}" ]] && desc_lines+=("${BASH_REMATCH[1]}")
		elif [[ "$line" =~ ^@arg[[:space:]]+(.*) ]]; then
			args+=("${BASH_REMATCH[1]}")
		elif [[ "$line" =~ ^@set[[:space:]]+(.*) ]]; then
			globals+=("${BASH_REMATCH[1]}")
		elif [[ "$line" =~ ^@exitcode[[:space:]]+(.*) ]]; then
			exitcodes+=("${BASH_REMATCH[1]}")
		elif [[ "$line" =~ ^@stdout[[:space:]]+(.*) ]]; then
			stdout_lines+=("${BASH_REMATCH[1]}")
		elif [[ -n "$line" ]] && [[ ! "$line" =~ ^@ ]]; then
			# Continuation line (part of description or previous annotation)
			desc_lines+=("$line")
		fi
	done <<< "$buffer"

	# Print additional description lines
	for line in "${desc_lines[@]}"; do
		echo "  $line"
	done
	((${#desc_lines[@]} > 0)) && echo

	# Print Arguments
	if ((${#args[@]} > 0)); then
		echo -e "${MNU}Arguments:${OFF}"
		for line in "${args[@]}"; do
			# Parse: $1 type description
			local arg_name arg_type arg_desc type_display
			read -r arg_name arg_type arg_desc <<< "$line"
			# Handle reference types (e.g., string-ref -> string, by ref)
			if [[ "$arg_type" =~ ^(.+)-ref$ ]]; then
				type_display="${BASH_REMATCH[1]}, by ref"
			else
				type_display="$arg_type"
			fi
			echo -e "  ${STA}${arg_name}${OFF} (${type_display}) - ${arg_desc}"
		done
		echo
	fi

	# Print Globals (from @set)
	if ((${#globals[@]} > 0)); then
		echo -e "${MNU}Globals:${OFF}"
		for line in "${globals[@]}"; do
			# Parse: varname type description
			local var_name var_type var_desc
			read -r var_name var_type var_desc <<< "$line"
			echo -e "  ${STA}${var_name}${OFF} (${var_type}) - ${var_desc}"
		done
		echo
	fi

	# Print Output (from @stdout)
	if ((${#stdout_lines[@]} > 0)); then
		echo -e "${MNU}Output:${OFF}"
		for line in "${stdout_lines[@]}"; do
			echo "  $line"
		done
		echo
	fi

	# Print Exit Codes
	if ((${#exitcodes[@]} > 0)); then
		echo -e "${MNU}Exit Codes:${OFF}"
		for line in "${exitcodes[@]}"; do
			# Parse: code description
			local code desc
			read -r code desc <<< "$line"
			echo -e "  ${STA}${code}${OFF} - ${desc}"
		done
	fi

	return 0
}

# get_func_name
# @description Extract function name from declaration line
#
# Arguments:
# @arg $1 string Line containing function declaration
#
# Effects:
# @stdout Function name or "unknown"
#
get_func_name() {
	local line="$1"
	local name

	# Match: funcname() or function funcname
	if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*\(\) ]]; then
		name="${BASH_REMATCH[1]}"
	elif [[ "$line" =~ ^[[:space:]]*function[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*) ]]; then
		name="${BASH_REMATCH[1]}"
	else
		name="unknown"
	fi
	echo "$name"
}

# show_script_description
# @description Display script header documentation
#   Extracts and displays the script-level comments from the file header.
#   Looks for the pattern "# scriptname - description" and subsequent comments.
#
# Arguments:
# @arg $1 string Path to script file
#
# Effects:
# @stdout Script name, description, and usage information
#
# Returns:
# @exitcode 0 Always succeeds
#
show_script_description() {
	local file="$1"
	local line
	local -i lnum=0
	local in_header=false
	local script_name=""
	local script_desc=""
	local bar
	local dash

	bar="$(printf '=%.0s' {1..75})"
	dash="$(printf -- "-%.0s" {1..75})"

	echo -e "\n${bar}"

	while IFS= read -r line || [[ -n "$line" ]]; do
		((++lnum))

		# Skip shebang
		[[ "$line" =~ ^#! ]] && continue

		# Skip empty comment lines at start
		[[ "$line" == "#" ]] && continue

		# Look for "# scriptname - description" pattern
		if [[ "$line" =~ ^#[[:space:]]+([^[:space:]]+)[[:space:]]+-[[:space:]]+(.+)$ ]]; then
			script_name="${BASH_REMATCH[1]}"
			script_desc="${BASH_REMATCH[2]}"
			echo -e "${STA}Script: $MNU${script_name}$OFF - $script_desc"
			echo "$dash"
			in_header=true
			continue
		fi

		# If we're in the header, print comment lines
		if $in_header; then
			if [[ "$line" =~ ^#[[:space:]]?(.*)$ ]]; then
				echo "${BASH_REMATCH[1]}"
			elif [[ -z "$line" ]] || [[ ! "$line" =~ ^# ]]; then
				# End of header comments
				break
			fi
		fi

		# Stop if we hit non-comment code
		[[ ! "$line" =~ ^# ]] && [[ -n "$line" ]] && break

	done < "$file"

	echo -e "${bar}\n"
	return 0
}

# main
# @description Parse and display documentation from a script file
#   Handles both legacy (#**/#*) and shdoc (# @description) formats.
#   In non-verbose mode, shows one-line summaries.
#   In verbose mode, shows full documentation blocks.
#
# Arguments:
# @arg $1 string Path to script file
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 File not found or no arguments
#
main() {
	local b_doc=false
	local b_shdoc=false
	local line=
	local -i fnamsiz
	local -a lary=()
	local -i lnum=0
	local -i doc_start_line=0
	local bar
	local dash
	local shdoc_buffer=""
	local description=""

	parseopts "$@"
	shift "$optcount"

	(($# > 0)) || { echo -e "$usagestr"; exit 1; }

	bar="$(printf '=%.0s' {1..75})"
	dash="$(printf -- "-%.0s" {1..75})"

	file="$1"

	[ -f "$file" ] || { echo -e "$usagestr"; exit 1; }

	# Show script description:
	#   - Always in verbose mode (unless -f is used)
	#   - In concise mode only if -s is specified
	if ! $b_func; then
		if $b_verbose || $b_script; then
			show_script_description "$file"
		fi
	fi

	while IFS= read -r line || [[ -n "$line" ]]; do
		((++lnum))
		read -ra lary <<< "$line"

		# === SHDOC FORMAT DETECTION ===
		if is_shdoc_start "$line"; then
			b_shdoc=true
			doc_start_line=$lnum
			# Extract description text after @description
			description="${line#*@description}"
			description="${description#"${description%%[![:space:]]*}"}"  # trim leading space
			shdoc_buffer="$line"
			continue
		fi

		# === SHDOC FORMAT PROCESSING ===
		if $b_shdoc; then
			if is_shdoc_comment "$line"; then
				# Accumulate doc lines
				shdoc_buffer+=$'\n'"$line"
			else
				# End of shdoc block - this line should be the function
				local func_name
				func_name=$(get_func_name "$line")

				# Apply function filter if specified
				if $b_func; then
					if [[ "$func_name" != *"$fname"* ]]; then
						b_shdoc=false
						shdoc_buffer=""
						description=""
						continue
					fi
				fi

				# Display the documentation
				$b_verbose && echo -e "\n${bar}"
				echo -e "${STA}$doc_start_line: $MNU${func_name}$OFF $description"

				if $b_verbose; then
					echo "$dash"
					format_shdoc "$shdoc_buffer"
				fi

				b_shdoc=false
				shdoc_buffer=""
				description=""
			fi
			continue
		fi

		# === LEGACY FORMAT (#**/#*) ===
		($b_doc || [ "${line:0:1}" == "#" ]) || continue

		if [ "${lary[0]:0:3}" == "#**" ]; then

			if $b_func; then
				fnamsiz=${#fname}
				[[ "${lary[1]}" == *"$fname"* ]] || continue
			fi

			$b_verbose && echo -e "\n${bar}"
			echo -e "${STA}$lnum: $MNU${lary[1]}$OFF ${lary[@]:2}"
			b_doc=true
			$b_verbose && echo "$dash"
			continue
		fi
		$b_verbose || continue

		if [[ "${lary[0]:0:2}" != "#*" ]]; then
			if $b_doc; then
				[[ "${line:0:1}" == "#" ]] && echo "${line:1}" || echo "$line"
			fi
		else
			b_doc=false
		fi
	done < "$file"

	return 0
}

main "$@"
