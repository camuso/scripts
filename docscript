#!/bin/bash
#
# docscript - Extract and display documentation from shell scripts
#
# Supports two documentation formats:
#   1. Legacy format: #** to start, #* to end
#   2. shdoc format: # @description, # @arg, # @exitcode, etc.
#
# Script-level documentation uses: # scriptname - description
#
# Usage:
#   docscript myscript.sh           # List documented functions (concise)
#   docscript -s myscript.sh        # Include script description header
#   docscript -v myscript.sh        # Verbose (auto-includes script desc)
#   docscript -f funcname script.sh # Show specific function only

declare MYDIR=
declare MYLIB=
declare MYDATA=
declare background=
declare usagestr=
declare optcount=0
declare b_verbose=false
declare b_script=false
declare file=
declare b_func=false
declare fname=

MYDIR="$(dirname "$(readlink -f "$0")")"
MYLIB="$MYDIR"/lib
MYDATA=$(realpath ./.data)
[ -d "$MYDATA" ] || mkdir -p "$MYDATA"

source "$MYLIB"/ui.source

usagestr=$(
cat <<EOF

$(basename "$0") [options] file

Extract and display documentation from shell scripts.

Supports two documentation formats:
  1. Legacy: #** ... #* delimited blocks
  2. shdoc:  # @description, # @arg, # @exitcode, etc.

Script-level documentation uses the format:
  # scriptname - Brief description

Arguments
---------
   file : script with documentation comments

Options
-------
  -s      : show script description header (concise mode only)
  -v      : verbose output with full documentation blocks
            (automatically includes script description)
  -f func : show documentation for specific function only
            (does not show script description)
  -h      : this help text

Examples
--------
  $(basename "$0") myscript.sh           # List functions (concise)
  $(basename "$0") -s myscript.sh        # Include script description
  $(basename "$0") -v myscript.sh        # Full docs (includes script desc)
  $(basename "$0") -f parse myscript.sh  # Show only 'parse' function
\0
EOF
)

# @description Handle Ctrl-C interrupt
#
# @exitcode 130 Always exits with SIGINT code
control_c() {
	echo -e "\nCtrl-c detected\nCleaning up and exiting."
	exit $CTLC_EXIT
}

# @description Initialize script environment
#
# @set background string Terminal background color setting
#
# @exitcode 0 Always succeeds
init() {
	local bgtemp

	ui_setbg bgtemp
	background=$bgtemp
	return 0
}

# @description Parse command line options
#
# @set optcount int Number of options parsed
# @set b_verbose bool Whether to show verbose output
# @set b_script bool Whether to show script description
# @set b_func bool Whether filtering by function name
# @set fname string Function name to filter (if -f used)
#
# @exitcode 0 Always succeeds
parseopts() {
	local arg=
	local opt=

	for arg in $@; do

	    if [ "${arg:0:1}" == "-" ]; then
		opt="${arg:1}"
		shift
		((optcount++))

		case "$opt" in
		s ) b_script=true
		    ;;
		v ) b_verbose=true
		    ;;
		f ) fname="$1"
		    b_verbose=true
		    b_func=true
		    shift
		    ((optcount++))
		    ;;
		h ) echo -e "$usagestr"
		    exit 0
		esac
	    fi
	done

	return 0
}

# @description Check if line starts an shdoc documentation block
#
# @arg $1 string Line to check
#
# @exitcode 0 Line starts shdoc block (# @description)
# @exitcode 1 Line does not start shdoc block
is_shdoc_start() {
	local line="$1"
	[[ "$line" =~ ^[[:space:]]*#[[:space:]]*@description ]]
}

# @description Check if line is part of an shdoc documentation block
#
# @arg $1 string Line to check
#
# @exitcode 0 Line is a comment (part of doc block)
# @exitcode 1 Line is not a comment (end of doc block)
is_shdoc_comment() {
	local line="$1"
	[[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]
}

# @description Extract function name from declaration line
#
# @arg $1 string Line containing function declaration
#
# @stdout Function name or "unknown"
get_func_name() {
	local line="$1"
	local name

	# Match: funcname() or function funcname
	if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*\(\) ]]; then
		name="${BASH_REMATCH[1]}"
	elif [[ "$line" =~ ^[[:space:]]*function[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*) ]]; then
		name="${BASH_REMATCH[1]}"
	else
		name="unknown"
	fi
	echo "$name"
}

# @description Display script header documentation
#
# Extracts and displays the script-level comments from the file header.
# Looks for the pattern "# scriptname - description" and subsequent comments.
#
# @arg $1 string Path to script file
#
# @stdout Script name, description, and usage information
# @exitcode 0 Always succeeds
show_script_description() {
	local file="$1"
	local line
	local -i lnum=0
	local in_header=false
	local script_name=""
	local script_desc=""
	local bar
	local dash

	bar="$(printf '=%.0s' {1..75})"
	dash="$(printf -- "-%.0s" {1..75})"

	echo -e "\n${bar}"

	while IFS= read -r line || [[ -n "$line" ]]; do
		((++lnum))

		# Skip shebang
		[[ "$line" =~ ^#! ]] && continue

		# Skip empty comment lines at start
		[[ "$line" == "#" ]] && continue

		# Look for "# scriptname - description" pattern
		if [[ "$line" =~ ^#[[:space:]]+([^[:space:]]+)[[:space:]]+-[[:space:]]+(.+)$ ]]; then
			script_name="${BASH_REMATCH[1]}"
			script_desc="${BASH_REMATCH[2]}"
			echo -e "${STA}Script: $MNU${script_name}$OFF - $script_desc"
			echo "$dash"
			in_header=true
			continue
		fi

		# If we're in the header, print comment lines
		if $in_header; then
			if [[ "$line" =~ ^#[[:space:]]?(.*)$ ]]; then
				echo "${BASH_REMATCH[1]}"
			elif [[ -z "$line" ]] || [[ ! "$line" =~ ^# ]]; then
				# End of header comments
				break
			fi
		fi

		# Stop if we hit non-comment code
		[[ ! "$line" =~ ^# ]] && [[ -n "$line" ]] && break

	done < "$file"

	echo -e "${bar}\n"
	return 0
}

# @description Parse and display documentation from a script file
#
# Handles both legacy (#**/#*) and shdoc (# @description) formats.
# In non-verbose mode, shows one-line summaries.
# In verbose mode, shows full documentation blocks.
#
# @arg $1 string Path to script file
#
# @exitcode 0 Success
# @exitcode 1 File not found or no arguments
main() {
	local b_doc=false
	local b_shdoc=false
	local line=
	local -i fnamsiz
	local -a lary=()
	local -i lnum=0
	local -i doc_start_line=0
	local bar
	local dash
	local shdoc_buffer=""
	local description=""

	init
	parseopts "$@"
	shift "$optcount"

	(($# > 0)) || { echo -e "$usagestr"; exit 1; }

	bar="$(printf '=%.0s' {1..75})"
	dash="$(printf -- "-%.0s" {1..75})"

	file="$1"

	[ -f "$file" ] || { echo -e "$usagestr"; exit 1; }

	# Show script description:
	#   - Always in verbose mode (unless -f is used)
	#   - In concise mode only if -s is specified
	if ! $b_func; then
		if $b_verbose || $b_script; then
			show_script_description "$file"
		fi
	fi

	while IFS= read -r line || [[ -n "$line" ]]; do
		((++lnum))
		read -ra lary <<< "$line"

		# === SHDOC FORMAT DETECTION ===
		if is_shdoc_start "$line"; then
			b_shdoc=true
			doc_start_line=$lnum
			# Extract description text after @description
			description="${line#*@description}"
			description="${description#"${description%%[![:space:]]*}"}"  # trim leading space
			shdoc_buffer="$line"
			continue
		fi

		# === SHDOC FORMAT PROCESSING ===
		if $b_shdoc; then
			if is_shdoc_comment "$line"; then
				# Accumulate doc lines
				shdoc_buffer+=$'\n'"$line"
			else
				# End of shdoc block - this line should be the function
				local func_name
				func_name=$(get_func_name "$line")

				# Apply function filter if specified
				if $b_func; then
					if [[ "$func_name" != *"$fname"* ]]; then
						b_shdoc=false
						shdoc_buffer=""
						description=""
						continue
					fi
				fi

				# Display the documentation
				$b_verbose && echo -e "\n${bar}"
				echo -e "${STA}$doc_start_line: $MNU${func_name}$OFF $description"

				if $b_verbose; then
					echo "$dash"
					# Print buffer without the first line (already showed description)
					while IFS= read -r bufline; do
						[[ "$bufline" =~ @description ]] && continue
						# Remove leading # and space
						bufline="${bufline#\#}"
						bufline="${bufline# }"
						echo "$bufline"
					done <<< "$shdoc_buffer"
				fi

				b_shdoc=false
				shdoc_buffer=""
				description=""
			fi
			continue
		fi

		# === LEGACY FORMAT (#**/#*) ===
		($b_doc || [ "${line:0:1}" == "#" ]) || continue

		if [ "${lary[0]:0:3}" == "#**" ]; then

			if $b_func; then
				fnamsiz=${#fname}
				[[ "${lary[1]}" == *"$fname"* ]] || continue
			fi

			$b_verbose && echo -e "\n${bar}"
			echo -e "${STA}$lnum: $MNU${lary[1]}$OFF ${lary[@]:2}"
			b_doc=true
			$b_verbose && echo "$dash"
			continue
		fi
		$b_verbose || continue

		if [[ "${lary[0]:0:2}" != "#*" ]]; then
			if $b_doc; then
				[[ "${line:0:1}" == "#" ]] && echo "${line:1}" || echo "$line"
			fi
		else
			b_doc=false
		fi
	done < "$file"

	return 0
}

main "$@"
