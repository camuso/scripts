#!/bin/bash
#
# cherp
#
# Provide some automation for cherrypicking.
#

#######################################
# Default file locations
#######################################
#
# Whatever directory this script and its companions are located in
# must be in the executable path.
#
# export PATH=$PATH:MYDIR
#
# Where MYDIR is the directory in which this script and its companions
# are located.
#
[ "$MYDIR" ] || {
	declare MYDIR=
	MYDIR="$(dirname "$(which "$(basename "$0")")")"
}
[ "$MYLIB" ] || {
	declare MYLIB=
	MYLIB="$MYDIR"/lib
}
declare MYMAN="$MYDIR"/man
declare MYDATA=
MYDATA="$(realpath ./.data)"
declare MYHLP="$MYMAN"/cherp.pgman
declare MYNAME=
MYNAME="$(basename "$0")"

#######################################
# External Source Files
#######################################
[ "$ui_loaded" ]            || source "$MYLIB"/ui.source
[ "$configmanager_loaded" ] || source "$MYLIB"/config-manager.source
[ "$ptversion_loaded" ]     || source "$MYLIB"/patchtools-version.source
[ "$keypsupport_loaded" ]   || source "$MYLIB"/keypress-support.source

########################################
# Return and Control Codes
########################################
declare rc_continue=0	# Continue for another pass

declare exit_good=0	# Normal exit
declare exit_conflict=2	# Exit with a conflict
declare exit_reset=3	# Exit after resetting the world
declare exit_bogus=4	# Exit because of bogus commit
declare exit_pending=6	# There are changes pending, so action can't complete
declare exit_nothing=7	# There is nothing to do
declare exit_bad=10	# Exiting from command line call with bad status

declare b_session_inited=false	# boolean to indicate session is inited
declare b_cmdline=false		# boolean indicating a comman line call

#########################################
# Config Variables
#########################################
#** These variables will be initialized by the call to cfg_start
declare configfile=
declare upcmtstartline=		# Line in upcommitsfile to start cherrypick
declare dnorighead=		# original downstream head at session start
declare lastuphash=		# most recently applied upstream commit hash
declare workdir=		# scratch directory for the session
declare upcommitsfile=		# File of upstream commits to cherry-pick
declare b_conflict=		# last attempt generated a conflict
declare str_jira=		# Options: JIRA link
declare str_cve			# Options: CVE
declare str_upstream=		# Options: upstream version, e.g, v6.7
declare str_brew=		# Options: brew link
declare str_test=		# Options: string containing test info
declare stophash=		# stop backporting when this currentuphash
declare tbackground=		# terminal background, light(1) or dark(2)
declare patchdir=		# directory that gets the patches
declare backport_mode=          # user's choice of backport mode
declare conflicthash=		# upstream hash that introduced a conflict
#*

#########################################
# Global Variables
#########################################

# backport modes
declare -i bm_lower=1	# lower boundary of backport modes
declare -i bm_cherry=1	# git cherry-pick
declare -i bm_patch=2	# git apply
declare -i bm_upper=2	# upper boundary of backport modes

declare finaluphash
declare -i menupad=30
declare cmtmsgfile=/dev/shm/gcpcmtmsgfile
declare b_lasthashvalid=false
declare lasttagfile="/dev/shm/gcplasttag"

declare b_new=false		# new session
declare b_single=false		# only perform single cherrypick
declare b_nit=false		# selective cherrypick

declare gitbranch		# current downstream branch

declare currentuphash	# next hash in the upcommitsfile
declare currentupcommit # oneline gitlog of next hash in the upcommitsfile
declare lastuplog	# oneline gitlog of last committed upstream hash
declare dncurrenthead	# hash of current downstread head

# Default upstream repo
declare upurl=			# url of upstream repo
declare upname="cp_upstream"	# Name of remote upstream repo

# Lines starting with any of these chars will be ignored.
# The '#' indicates a comment, and the '+' indicates already committed.
declare ignore_str="#+"

########################################
# Global Strings
########################################
declare str_herald=
declare str_conflicts=

init_global_strings() {
str_herald="\n$MNU${UND}Patchtools v$version$OFF\n\n${MNU}cherp - Automates \
Backporting$OFF"
str_conflicts="Conflicts:\n"
}

#########################################
# Functions
#########################################

#** print_herald: print the script's herald defined above
#===============================================================================
#     ARGUMENTS:  Implicit global, str_herald
#       RETURNS:  None
#*==============================================================================
print_herald() {
	echo -e "$str_herald"
}

#** exit_cherp: exit in an orderly manner
#===============================================================================
#     ARGUMENTS:  1 - exit code
#                 2 - optional exit message
#       RETURNS:  None
#===============================================================================
exit_cherp() {
	# echo -e "$UND\0exit_cherp $1$OFF"
	[ -n "$2" ] && echo -e "\n$2\n"
	$b_session_inited && save_session
	exit "$1"
}

#** get_gitbranch: prints the name of the current git branch
#===============================================================================
#     ARGUMENTS:  None
#       RETURNS:  None
#*==============================================================================
get_gitbranch() {
	git branch | grep '\*' | cut -d' ' -f2
}

#** set_gitbranch: list the available branches for the user to choose one
#===============================================================================
#     ARGUMENTS:  None
#       GLOBALS:  workdir
#                 gitbranch
#       RETURNS:  0 if new branch selected, 1 if user did not make a selection
#                 or if the selected branch could not be checked out.
#*==============================================================================
set_gitbranch() {
	local index=1
	local linenumber
	local line
	local outline
	local hilite=
	local branchlistfile="$workdir"/branchlist

	echo
	echo -e "${MNU}Select the Downstrean Branch or press $qstr$INF to leave" \
		"the current "
	echo -e "selection marked with the leading *.$OFF"

	git branch > "$branchlistfile"

	while read -r line; do
		[ "${line:0:1}" = "*" ] && hilite="$MNU" || hilite="$INF"
		outline=$(printf "%s %2d %s $line\n" "$hilite" $index "$OFF")
		echo -e "$outline"
		((++index))
	done < "$branchlistfile"

	# echo -e "$brmsg"
	loop_range_q 1 $((index - 1)) linenumber || return 0

	gitbranch="$(ui_readline "$linenumber" "$branchlistfile" | tr -d [\*" "])"
	echo -e "${MNU}git checkout $STA$gitbranch$OFF"
	git am --abort --quiet >/dev/null 2>&1
	git checkout "$gitbranch" || {
		$b_cmdline && exit_cherp $exit_pending;
		return 1
	}

	git log --oneline -1
	get_originhead
	$b_cmdline && exit_cherp $exit_good || return 0
}

#** git_set_subjectprefix: Set the subject prefix in .git/config
#===============================================================================
#     ARGUMENTS:  none
#       RETURNS:  none
#*==============================================================================
git_set_subjectprefix() {
	local newpfx
	newpfx="$(git config format.subjectprefix)"

	echo -e "$INF" \
"Just press ${STA}ENTER$INF to leave the current subject prefix unchanged.$OFF"
	getuser "${MNU}New subject prefix: $OFF" newpfx
	[ "$newpfx" ] || return
	git config format.subjectprefix "$newpfx"
}

#** set_dir - set a directory variable and save it in the config file
#
# Arguments
#   $1 - string to be used in the prompt describing the directory
#   $2 - the config file key for the directory variable name
#   $3 - the current value of the directory variable. Will be updated
#        if the user changes the directory name.
#*
set_dir() {
	local dirstr="$1"
	local dircfgkey="$2"
	local dir="${!3}"
	local b_msgshown=false
	local ndirmsg

	ndirmsg=$(
cat <<EOF
$INF
This directory has not yet been named.
You must provide a directory path for me to continue.
If the path does not exist, I will offer to create it
for you.
$OFF
EOF
)
	[ -n "$dir" ] && {
		echo -e "${INF}Current $STA$dirstr$INF directory : $STA$dir$OFF"
		echo -e "${INF}Type $qstr$INF to leave it as it is.$OFF"
	}

	# We can't accept a NULL directory name, so cycle until we get a name.
	#
	while :; do
		ui_getnewdir "${INF}New $STA$dirstr$INF directory : $OFF" dir

		if [ -n "$dir" ]; then
			[ -d "$dir" ] || mkdir -p "$dir"
			break
		else
			$b_msgshown || echo -e "$ndirmsg"
			b_msgshown=true
		fi
	done

	dir=$(realpath "$dir")
	set_cfg_item "$dircfgkey" "$dir"
	echo -e "$INF$dirstr directory is $STA$dir$OFF\n"
	eval "$3"="$dir"
}

#** set_working_directory: for the script's output
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  workdir
#       RETURNS:  none
#*==============================================================================
set_working_directory() {
	# echo -e "$UND\0set_working_directory$OFF"

	echo -e "${INF}The working directory is used for scratch by this script.$OFF"
	[ "$workdir" ] && echo -e "$STA$workdir$OFF"
	set_dir "working" "workdir" workdir
	cfg_set_item "workdir" "$workdir"
}

#** fetch_upstream_repo: spawn git fetch $upname $upurl and wait on proc
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  upurl
#                 upname
#       RETURNS:  none
#*==============================================================================
fetch_upstream_repo() {
	local mypid

	echo -e "${INF}Adding url: $UND$CYN$upurl$OFF"
	echo -e "${INF}as \"$STA$upname\""
	echo -e "${INF}Type: ${MNU}git branch -r | grep $upname$OFF" \
		"${INF}to see the $upname remote and its branches$OFF"
	echo -e "${INF}Fetching the upstream repo.$OFF"
	echo -e "${INF}This could take some time, so please be patient.$OFF"

	git fetch -p "$upname" & mypid=$!
	ui_waitonproc_tty $mypid 1
}

#** set_upstream_url: user inputs the url to use for upstream repo
#===============================================================================
#     ARGUMENTS:  $1="NEW" if there is no upurl stored in the .conf file
#       GLOBALS:  upurl
#                 upname
#       RETURNS:  none
#*==============================================================================
set_upstream_url() {
	local new="$1"	# if == "new", then there is no upurl yet, so ge it
	local temp=
	local b_new=
	local defurl="git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git"

	echo

	if [ "$new" == "NEW" ]; then
		b_new=true
		echo -e  "${UND}${MNU}Enter the upstream url$OFF"
		echo -e "${INF}The default upstream url is ..."
		echo -e "${LNK}$defurl$OFF"
		echo
		echo -e "${INF}Enter $qstr$inf to accept the default.$OFF"
	else
		b_new=false
		echo -e "${UND}${MNU}Change the upstream url$OFF"
		echo -e "${INF}The current upstream url is ...$OFF"
		echo -e "$LNK$upurl$OFF"
		echo
		echo -e "${INF}Enter $qstr$INF to leave it unchanged.$OFF"
	fi

	while :; do
		getuser "Upstream URL: " temp

		if [ -z "$temp" ]; then
			echo -en "${CAU}Enter an upstream url or $qstr$CAU to "
			if $b_new; then
				echo -e "accept the default.$OFF"
			else
				echo -e "leave the upstream url unchanged.$OFF"
			fi
			continue
		fi

		if [ "$temp" == "q" ]; then
			if $b_new; then
				upurl="$defurl"
				break;
			else
				return
			fi
		else
			$b_new || git remote remove "$upname"
			upurl="$temp"
			break;
		fi
	done

	git remote add "$upname" "$upurl"
	fetch_upstream_repo
}

#** set_upcommitsfile: user enters file containing commits to backport
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  upcommitsfile - file containing the commits to be backported
#       RETURNS:  status of call to ui_getfilespec()
#*==============================================================================
set_upcommitsfile() {
	local stat
	local prstr
	local commitsfilemsg
	local exitmsg
	local currentfile

	prstr=$(
cat <<EOF
${INF}Backports File$OFF
EOF
)
	commitsfilemsg=$(
cat <<EOF
${OFF}You can create a file containing the upstream commits to be backported
using the$INF mkbackportlog$OFF tool.
EOF
)
	exitmsg=$(
cat <<EOF
${INF}
You pressed $qstr$INF without providing a Backports File, so we must exit.$OFF
EOF
)
	currentfile=$(
cat <<EOF
${INF}The current file is $STA$upcommitsfile$INF.
Press $qstr$INF at the prompt to use this file.$OFF
EOF
)
	# echo -e "$UND\0set_upcommitsfile$OFF"

	[ "$upcommitsfile" ] && prstr="$prstr.\n$currentfile"
	ui_getfilespec "$prstr : " upcommitsfile
	stat=$?

	if [ $stat -ne 0 ]; then
		if [ "$upcommitsfile" ]; then
			echo -e "${INF}Keeping: $STA$upcommitsfile$OFF"
		else
			echo -e "$exitmsg"
			echo -e "$commitsfilemsg"
			exit 0
		fi
	fi

	upcommitsfile="$(realpath "$upcommitsfile")"
	set_cfg_item "upcommitsfile" "$upcommitsfile"
	return $stat
}

#** pr_nohash_msg: message for hash not among commits in backport file
#===============================================================================
#     ARGUMENTS:  $1 - hash
#       GLOBALS:  upcommitsfile - file of upstream commits to cherrypick
#       RETURNS:  none
#*==============================================================================
pr_nohash_msg () {
	local hash="$1"
	local nohash_msg

	nohash_msg=$(
cat <<EOF
$INF
  Cannot find $STA$hash$INF as a commit or valid line number in $STA$upcommitsfile$INF
  Lines having a '$STA\0#$INF' as their first character are not listed or considered.
  Try again or type $qstr$INF to return to main menu.$OFF
EOF
)
	echo -e "$nohash_msg"
}

#** lookup_hash: Find the given hash in the backport commits file
#===============================================================================
#     ARGUMENTS:  $1 - hash
#                 $2 - will return the number of the line in the commits file
#                      that has the hash.
#       GLOBALS:  upcommitsfile - file of upstream commits to cherrypick
#       RETURNS:  nonzero if lookup fails
#*==============================================================================
lookup_hash() {
	local hash=$1
	local counter
	local line

	[[ -f "$upcommitsfile" ]] || return 1

	counter=$(grep -m1 -n "^$hash" "$upcommitsfile" | cut -d':' -f1)

	[ -z "$counter" ] && return 1

	eval "$2"="$counter"
	return 0
}

#** set_next_cherrypick: Select the starting commit from the upcommitsfile
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  upcommitsfile - file of upstream commits to cherrypick
#                 upcmtstartline- starting line for upcommitsfile
#                 currentupcommit - global storage for current upstream commit
#                 currentuphash - global storage for current upstream cmt hash
#                 tlines        - number of lines in the terminal window
#                 tcols         - number of columns in the terminal window
#                 qstr          - string with a boldfaced 'q'
#                 ignore_str    - string of comment chars in commits log
#       RETURNS:  none
#*==============================================================================
set_next_cherrypick() {

	# echo -e "$UND\0set_next_cherrypick$OFF"
	$b_cmdline && init_cmdline_call

	local counter=0
	local line
	local linary
	local idx=0
	local stat
	local linecount
	local numwid=${#linecount}
	local cols=$((tcols - 2 - numwid))
	local selected

	[ -f "$upcommitsfile" ] || return
	linecount=$(wc -l "$upcommitsfile")
	echo -e "\n${INF}Contents of upstream commits file: $STA$upcommitsfile$OFF"
	echo -e "$MNU\0NOTE:$INF Not showing lines starting with any of these chars:"\
	        "$STA$ignore_str$OFF\n"

	# Dump the contents of the upcommitsfile
	#
	while read -r line; do
		((++counter))
		[ "$(ui_strindex "$ignore_str" "${line:0:1}")" -ge 0 ] && continue
		line=$(printf "%s %${numwid}d %s%s%s" "$MNU" $((idx+1)) "$OFF" "$line")
		echo -e "${line:0:cols}$OFF"
		linary[$idx]=$counter
		((++idx))
	done < "$upcommitsfile"

	echo
	loop_range_q 1 "$idx" selected
	[ "$selected" = "q" ] || upcmtstartline=${linary[$((selected - 1))]}
	currentupcommit="$(ui_readline "$upcmtstartline" "$upcommitsfile")"
	# echo "currentupcommit: $currentupcommit"
	currentuphash=$(echo "$currentupcommit" | cut -d' ' -f1)
	$b_cmdline && exit_cherp $exit_good
}

#** validate_last_upstream_hash: assure commit hash is valid
#===============================================================================
#   Validates whether the hash stored in the project file is valid for this
#   instance of cherp
#
#     ARGUMENTS:  none
#       GLOBALS:  upcommitsfile - the cherry-pick commits file containing the
#                                 hashes of the commits to be backported.
#                 b_lasthashvalid - boolean indicating last hash was valid
#       RETURNS:  nonzero if the last stored hash is not valid
#*==============================================================================
validate_last_upstream_hash() {
	$b_new && b_lasthashvalid=false || b_lasthashvalid=true

	# If we don't have a commits file, show nothing
	#
	[[ -f $upcommitsfile ]] || b_lasthashvalid=false

	# If there is no hash saved in the config file, then show nothing.
	#
	[[ "$lastuphash" ]] || b_lasthashvalid=false

	# If the commit stored in the config file is not in the commits file
	# then show nothing.
	#
	grep -m1 -n "$lastuphash" "$upcommitsfile" >/dev/null 2>&1 || b_lasthashvalid=false
	$b_lasthashvalid && lastuplog=$(git log -n1 --oneline "$lastuphash")
	$b_lasthashvalid && return 0 || return 1
}

#** getlasttag: show dots while obtaining the latest git tag
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  lasttagfile
#       RETURNS:  none
#*===============================================================================
getlasttag() {
	local _mypid_
	git describe --tags --abbrev=0 > "$lasttagfile" &
	_mypid_=$!
	ui_waitonproc $_mypid_ .05
	echo
}

#** get_lastuplog: gitnice of most recent, successfully applied upstream commit
#
#  Also inits the lastuphash
#
# Globals:
# 	lastuplog
# 	lastuphash
# 	upcommitsfile
#*
get_lastuplog() {
	local ch="+"
	lastuphash=

	[ -f "$upcommitsfile" ] || return
	lastuplog="$(grep "^$ch" $upcommitsfile | tail -n1)"

	if [ -n "$lastuplog" ]; then
		lastuphash="$(cut -d' ' -f2 <<< "$lastuplog")"
		lastuplog="$(gitnice "$lastuphash")"
	fi

	cfg_set_item "lastuphash" "$lastuphash"
}

#** get_finaluphash: find the last commit in the backport commits file
#
# Globals
#   upcommitsfile
#   finaluphash
#*
get_finaluphash() {
	local -a lary=()

	mapfile -t lary < <(grep -v "^[${ignore_str}]" "$upcommitsfile" | grep -v '^$')
	finaluphash="$(cut -d' ' -f1 <<< "${lary[-1]}")"
}

#** get_next_cherrypick: gets the next commit in the backport commits file
#===============================================================================
#
#  Ignores lines with leading *, indicating the commit is to be skipped, and
#  leading +, indicating the commit has already been applied to the downstream
#  branch.
#
#     ARGUMENTS:  none
#       GLOBALS:  upcommitsfile
#                 upcmtstartline
#                 currentuphash
#                 currentupcommit
#                 ignore_str
#                 menupad
#       OUTPUTS:  echoes the hash of next upstream commit in the commits file
#       RETURNS:  1 if there are no more cherries to pick, else 0
#*==============================================================================
get_next_cherrypick() {
	# local myname="get_next_cherrypick: "
	# echo -e "\n$UND$myname$OFF start line: $upcmtstartline"

	[[ -f "$upcommitsfile" ]] || return 1

	local idx
	local line
	local -a lary=()
	local sts=0

	# Find the first line that does NOT begin with one of the characters in the
	# string of characters indicating the line is to be ignored.
	#
	mapfile -t lary < <(grep -v "^[${ignore_str}]" "$upcommitsfile" | grep -v '^$')
	if ((${#lary} > 0)); then
		currentuphash="$(cut -d' ' -f1 <<< "${lary[0]}")"
		upcmtstartline="$(grep -n "$currentuphash" "$upcommitsfile" | cut -d: -f1)"
		currentupcommit="$(gitnice -1 "$currentuphash")"
		sts=0
	else
		currentuphash=
		upcmtstartline="$(($(wc -l < "$upcommitsfile") + 1))"
		sts=1
	fi

	set_cfg_item "upcmtstartline" "$upcmtstartline"
	return $sts
}

#** get_current_cherrypick: gets the current commit to backport
#===============================================================================
#
#  Gets the current commit in the commits file indicated by the current
#  upcmtstartline.
#
#  Because get_next_cherrypick always pre-increments the upcmtstartline, this
#  routine will decrement the upcmtstartline before calling get_next_cherrypick/
#
#     ARGUMENTS:  none
#       GLOBALS:  upcmtstartline
#       OUTPUTS:  echoes the hash of next upstream commit in the commits file
#       RETURNS:  status of call to get_next_cherrypick
#*===============================================================================
get_current_cherrypick() {
	# local myname="get_current_cherrypick:"
	# echo -e "$OFF\n$UND$myname upcmtstartline: $upcmtstartline$OFF"

	((--upcmtstartline))
	# echo "$myname startline: $upcmtstartline"
	get_next_cherrypick
	return $?
}

#** show_next_cherrypick: show the next upstream commit to backport
#===============================================================================
#     ARGUMENTS:  None
#       GLOBALS:  upcommitsfile
#                 currentupcommit
#                 currentuphash
#                 b_conflict
#                 b_cmdline
#                 menupad
#       RETURNS:  none
#*==============================================================================
show_next_cherrypick() {
	# echo "\n${UND}show_next_cherrypick$OFF"

	local linecount
	local prstr=
	local statstr
	local leadstr
	local cols=$((tcols - menupad))
	local show_next_cherrypick_str
	local padstr="$(printf "%*c" "$menupad" " ")"

	($b_cmdline || $b_conflict) && leadstr="    " || leadstr="$MNU c$OFF  "
	$b_conflict && statstr="${CAU}Current conflict         ${OFF}:" \
		    || statstr="Next backport commit     :$OFF"

	get_current_cherrypick	&& prstr="$STA${currentupcommit:0:$cols}$OFF"

	show_next_cherrypick_str=$(
cat <<EOF

$leadstr$statstr $prstr
EOF
)
	[ -n "$currentuphash" ] && echo -e "$show_next_cherrypick_str"
	return 0
}

#** show_select_next_cherrypick: let user select next commit to backport
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  upcommitsfile
#       RETURNS:  0
#*==============================================================================
show_select_next_cherrypick() {
	# echo -e "${UND}show_select_next_cherrypick$OFF"

	local selcmt_str

	selcmt_str=$(
cat <<EOF

$MNU S$INF  Select a different commit for next cherrypick$OFF
EOF
)
	[[ -f $upcommitsfile ]] || return 1
	echo -e "$selcmt_str"
	return 0
}

#** get_lastbackport: get the last successfully applied upstream commit
#
# Globals:
#   dnorighead
#
# Returns:
#   0 extracted upstream hash is not dnorighead and is an actual hash
#   1 extracted upstream hash is the same as the dnorighead
#   2 extracted upstream hash field is not a hash
#*
get_lastbackport() {
	local bp
	local hash="$( cut -d' ' -f1 <<< $(gitnice -1) )"

	[ "$hash" == "$dnorighead" ] && return 1

	extup -1 -m -b "$hash"
	[[ $hash =~ ^[0-9a-fA-F]+$ ]] && return 0 || return 2
}

#** show_most_recent_cherrypick: show the last upstream commit backported
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  lastuplog
#                 tcols
#                 menupad
#                 b_lasthashvalid
#       RETURNS:  none
#*==============================================================================
show_most_recent_cherrypick() {
	# echo -e "\n${UND}show_most_recent_cherrypick$OFF"

	local cols=$((tcols - menupad))
	local laststr
	local padstr="$(printf "%*c" "$menupad" " ")"
	local eofstr="$CAU$padstr was the last commit in Backports File$OFF"
	local lastbackport=

	lastbackport="$(get_lastbackport)" || { echo -n; return; }

	laststr="\n    Last backported commit   : $STA${lastbackport:0:$cols}$OFF"
	echo -e "$laststr"
	((upcmtstartline > $(wc -l < "$upcommitsfile"))) && echo -e "$eofstr"
}

#** show_upsteam_commits_file: print the filename of the upstream commmits file
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  upcommitsfile
#                 b_cmdline
#       RETURNS:  none
#*==============================================================================
show_upsteam_commits_file() {
	# echo -e "${UND}show_upsteam_commits_file$OFF"

	local cmtfilestr
	local dary	# array of backported commits
	local bary	# array of commits to be backported
	local -i nd	# number of commits to do
	local -i nb	# number of commits done
	local -i nc	# number of commits remaining to be done
	local lastupcmt	# last upstream commit backported in file
	local lastdncmt # last downstream commit in current downstream branch
	local lastdnup  # last upstream commit referenced in last downstream commit
	local padstr="$(printf "%*c" "$menupad" " ")"

	if $b_cmdline; then
		cmtfilestr="    Upstream Backports File  : $STA$upcommitsfile$OFF"
	else
		cmtfilestr="$MNU f$OFF  Upstream Backports File  : $STA$upcommitsfile$OFF"
	fi

	echo -e "$cmtfilestr"

	[ "$upcommitsfile" ] || return

	# Get the total backports in the file that have not been hashed out.
	mapfile -t dary < <(grep -v "^[#]" "$upcommitsfile" | grep -v '^$')
	nd="${#dary[@]}"

	# Get the backports in the file that indicate they have been committed.
	mapfile -t bary < <(grep "^[+]" "$upcommitsfile" | grep -v '^$')
	nb="${#bary[@]}"

	# If none of the upstream commits has been applied to downstream, and
	# the current head is same as the dnorighead, then just return, else
	# report an inconsistent state.
	lastdncmt="$(gitnice -1 | cut -d' ' -f1)"

	if ((${#bary[@]} == 0)); then
		if [ "$lastdncmt" == "$dnorighead" ]; then
			return
		else
			echo -e "$padstr$WRN Inconsistent State$OFF\n"\
			"$padstr$INF None of the commits in the Backports File\n"\
			"$padstr has been applied, but the current head is\n"\
			"$padstr not the same as \"$OFF${BLD}Head at Session Start\"$INF.\n"\
			"$padstr$CAU Alt-Shift-R$INF to reset to the original head\n"\
			"$padstr or press$MNU N$INF to start a new session.$OFF"
			return 1
		fi
	fi

	# If the last one in the file that indicates it was committed is not
	# at the top of the current downstream branch, then notify inconsistent
	# state.
	lastupcmt="$(cut -d' ' -f2 <<< "${bary[-1]}")"
	lastdncmt="$(extup -1 -m -b "$lastdncmt" | cut -d' ' -f1)"
	if [ "$lastdncmt" != "$lastupcmt" ]; then
		echo -e "$padstr$WRN Inconsistent State"
		echo -e "$padstr$CAU Last upstream commit in current downstream branch"
		echo -e "$padstr not same as last upstream commit in backports file."
		echo -e "$padstr$CAU Wrong branch or backport file?$OFF"
		return 1
	fi

	nc=$((nd - nb))
	if ((nc == 0)); then
		echo -e "$padstr$CAU It appears all upstream commits have been applied.$OFF"
	else
		echo -e "$padstr$INF Commits backported: $STA$nb$INF Commits remaining: $STA$nc$OFF"
	fi

	return 0
}

#** show_history: history of applied patches in downstream branch
#==============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#       RETURNS:  none
#*==============================================================================
show_history() {
	$b_cmdline && init_cmdline_call
	echo
	echo -en "$INF$(git log --oneline "$dnorighead"..HEAD)$OFF"
	echo
	$b_cmdline && exit 0
	return 0
}

#** show_status: prints the current status to the screen
#==============================================================================
#     ARGUMENTS:  $1 - If this argument is not empty, then forego the
#                      init_cmdline_call
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#       RETURNS:  none
#*==============================================================================
show_status() {
	# echo -e "$UND\0show_status$OFF"

	local cols=$((tcols - menupad))
	local subjectprefix
	local lastbrcmt
	local orighead
	local statstr
	local b_internal

	subjectprefix="$(git config format.subjectprefix)"
	[ "$1" ] && b_internal=true || b_internal=false

	$b_internal || init_cmdline_call

	lastbrcmt=$(git log -n1 --oneline)
	orighead=$(git log --oneline -n1 "$dnorighead")

	statstr=$(
cat <<EOF
$INF$(show_upsteam_commits_file)\
$INF$(show_most_recent_cherrypick)\
$INF$(show_next_cherrypick)
$INF    Current downstream branch: $STA$(get_gitbranch)
$INF    Current downstream head  : $STA${lastbrcmt:0:cols}
$INF    Original downstream head : $STA${orighead:0:cols}$OFF
\0
EOF
)
	echo -e "$statstr"
	git status
	$b_internal && ui_press_any || exit 0
}

#** get_patchdir: get the directory to receive the patches
#
# Globals
#   patchdir
#
# Returns:
#   0 if new patchdir
#   1 if user quit without entering a new patchdir
#*
get_patchdir() {
	local pdir=
	local prstr

	prstr="\n${MNU}Directory path for patchfiles. $OFF\n"
	prstr+="${INF}Enter $qstr$INF to leave it as it is.$MNU\n : $OFF"

	ui_getnewdir "$prstr" pdir || return 1
	patchdir="$pdir"
	set_cfg_item "patchdir" "$patchdir"
	return 0
}

#** create_patches: create a patch series from the backported commits
#
# Globals:
#  patchdir - directory for the patch series files
#  dnorighead - head when New session was started
#
#*
create_patches() {
	local dirstr="${MNU}Do you want to use$STA $patchdir$MNU y/n :$OFF "
	local findargs="-maxdepth 1 -type f -name "*.patch" -print -quit"

	cfg_get_item "patchdir" patchdir
	local pdir="$patchdir"

	echo -e "\n${INF}Create a patch series from the applied commits.$OFF"

	[ -d "$pdir" ] && {
		loop_yn "$dirstr" || pdir=
	}

	[ -d "$pdir" ] || {
		get_patchdir || return
	}

	local delprompt="$(
cat <<EOF
${CAU}There are .patch files in$STA $patchdir$CAU.
${INF}They will be erased if you continue.
Do you want to proceed?$MNU y/n : $OFF
EOF
)"
	[ -n "$(find "$patchdir" $findargs)" ] && {
		loop_yn "$delprompt" && rm -f "$patchdir"/*.patch || return
	}

	gitforpat -n "$patchdir" "$dnorighead"..
	return
}

#** show_tbackground
#
#  Globals:
#    tbackground
#    tb_light
#    tb_dark
#*
show_tbackground() {
	((tbackground == tb_dark)) && echo -n "Dark" ||
		                      echo -n "Light"
}

#** show_backport_mode: display the current backport mode
#
#  Globals:
#    backport_mode
#    bm_cherry
#    bm_patch
#*
show_backport_mode() {
	case "$backport_mode" in
	    "$bm_cherry" ) echo "git cherry-pick"
			  ;;
	    "$bm_patch" )  echo "patch --merge"
			  ;;
	esac
}

#** show_options: display the options menu
#
#  Globals:
#    str_upstream
#    str_brew
#    str_test
#    str_jira
#    str_cve
#*
show_options() {
	local options

	options=$(
cat <<EOF
$MNU
        ${UND}Options          $OFF
    $MNU u $OFF Upstream status          : $STA$str_upstream$OFF
    $MNU J $OFF JIRA link                : $STA$str_jira$OFF
    $MNU C $OFF CVE                      : $STA$str_cve
    $MNU b $OFF Brew or build info       : $STA$str_brew$OFF
    $MNU t $OFF Test information         : $STA$str_test$OFF
    $MNU p $OFF Patch subject prefix     : $STA$(git config format.subjectprefix)$OFF
    $MNU d $OFF Patch Directory          : $STA$patchdir$OFF
    $MNU B $OFF Backport Mode            : $STA$(show_backport_mode)$OFF
    $MNU c $OFF Change Terminal Colors   : $STA$(show_tbackground)$OFF
    $MNU q $OFF Quit to main menu
\0
EOF
)
	echo -e "$options"
}

#** get_oneopt: get one of the string options
#
# Arguments:
#   $1 - prompt string
#   $2 - option name by reference, so no leading $
#*
get_oneopt() {
	local prompt="$1"
	local -n getone_str="$2"
	local item="$2"
	local str
	local pstr

	pstr="\n${INF}Press $qstr$INF to leave unchanged.\n"
	pstr+="Press$STA RETURN$INF with nothing to blank.\n"
	pstr+="Current value:$STA $getone_str$OFF\n$prompt"
	getuser "$pstr" str
	[ "$str" == "q" ] && return 1
	set_cfg_item "$item" "$str"
	getone_str="$str"
	return 0
}

#** get_options: parse the user's option entry
#
#  Globals:
#    str_upstream
#    str_brew
#    str_test
#    str_jira
#    str_cve
#
#  Returns 1 when user types 'q', else returns 0
#*
get_options() {
	local opt=

	show_options
	"$promptgetkey_cmd" "${MNU}    Enter one of the above: $OFF" opt

	case $opt in
		J )	get_oneopt "${MNU}JIRA link: $OFF" "str_jira"
			;;
		C )	get_oneopt "${MNU}CVE: $OFF" "str_cve"
			;;
		u )     get_oneopt "${MNU}Upstream status: $OFF" "str_upstream"
			;;
		b )	get_oneopt "${MNU}Brew or build info: $OFF" "str_brew"
			;;
		t )	get_oneopt "${MNU}Testing info: $OFF" "str_test"
			;;
		p )	git_set_subjectprefix
			;;
		c )     ui_use_colors
			tbackground="$terminal_background"
			set_cfg_item "tbackground" "$tbackground"
			;;
		d )	get_patchdir
			;;
		B )	get_backport_mode
			;;
		q )	return 1
	esac

	return 0
}

#** options_looop: get the options until user types 'q'
#
#  Nothing complicated here. Basically an infinite loop with an
#  exit condition.
#*
options_loop() {
	while :; do
		get_options || return
	done
}

#** show_altopt: displays the Alt-Shift options
#
#  Arguments:
#    $1 - The option letter
#    $2 - The string that goes with it.
#*
show_altopt() {
	local opt="$1"
	local str="$2"
	$ui_b_keypress || return 1
	echo -e "$CAU Alt-Shift-$opt $OFF$str"
	return 0
}

#** show_settings: display current settings and the main menu
#==============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#       RETURNS:  none
#*==============================================================================
show_settings() {
	# echo -e "$UND\0show_settings$OFF"
	local cols=$((tcols - menupad))
	local subjectprefix
	local lasttag
	local lastbrcmt
	local orighead
	local settings
	local lgc=$(gitnice "$lastgoodcommit")

	subjectprefix="$(git config format.subjectprefix)"
	lastbrcmt="$(git log -n1 --oneline)"
	orighead="$(git log --oneline -n1 "$dnorighead")"
	dncurrenthead="$(cut -d' ' -f1 <<< "$lastbrcmt")"

	settings=$(
cat <<EOF
$MNU
    ${UND}Upstream Environment    $OFF
$(show_upsteam_commits_file)\
$(show_most_recent_cherrypick)\
$(show_next_cherrypick)
$MNU u $OFF Upstream url             : $LNK$upurl$OFF
$MNU
    ${UND}Downstream Environment  $OFF
    Current Head             : $STA${lastbrcmt:0:cols}$OFF
    Head at Session Start    : $STA${orighead:0:cols}$OFF
$MNU b $OFF Current git branch       : $STA$(get_gitbranch)$OFF
$MNU w $OFF Working directory        : $STA$workdir$OFF
$MNU O $OFF Options menu
$MNU
    ${UND}Control                $OFF
$MNU S $OFF Stop before              : $STA$stophash$OFF
$MNU P $OFF Create a patch series
$MNU N $OFF Start a New Session
$MNU H $OFF Show History
$MNU r $OFF Run all remaining commits
$MNU 1 $OFF Run the next commit and stop
$MNU s $OFF cherp status
$(show_altopt "R" "RESET to an earlier commit in this session ")
$MNU q $OFF Quit this tool
$MNU h $OFF Help
$OFF
EOF
)
# save for later
# $MNU V $OFF vim $STA$upcommitsfile$OFF in a popup window

	echo -e "$settings"
}
## Deprecated menu items
## $(show_altopt "I" "Init or restart session")

#** menu_parser: parse the user input at the main menu
#===============================================================================
#     ARGUMENTS:  none, but lots of side effects
#       GLOBALS:  dncurrenthead
#       RETURNS:  rc_continue, used by menu_loop to determine whether to
#       	  continue looping.
#*==============================================================================
menu_parser() {
	# echo -e "$UND\0menu_parser$OFF"

	local pops
	local setting=
	local -i retval

	validate_last_upstream_hash
	dncurrenthead="$(gitnice | cut -d' ' -f1)"
	show_settings

	"$promptgetkey_cmd" "${MNU}Enter one of the above: $OFF" setting
	retval=$?

	# keypress.c does not invoke SIGINT on ctrl-c, so test for it explicitly
	# when using keypress.
	$ui_b_keypress && [ "$setting" == $'\003' ] && ctrl_c

	case $setting in

		b )	set_gitbranch
			;;
		w )	set_working_directory
			;;
		f )	set_upcommitsfile
			;;
		u )	set_upstream_url
			;;
		c )	set_next_cherrypick
			;;
		N )	init_newsession
			;;
		H )	show_history
			;;
		h )	ptpage -b "$tbackground" "$MYHLP"
			;;
		q )	exit_cherp $exit_good
			;;
		r )	run_me
			b_new=false
			;;
		O )	options_loop
			;;
		S )	getuser "${MNU}Stop before this hash: $OFF" stophash
			cfg_set_item "stophash" "$stophash"
			;;
		P )	create_patches
			;;
		1 )	run_me 1
			;;
		s )	show_status i
			;;
#		V )	ui_popterm "vim $upcommitsfile"
#			;;
#		I )	((retval == 1)) || return $rc_continue
#			init_current_session
#			;;
		R )	((retval == 1)) || return $rc_continue
			reset_cherp
	esac
	return $rc_continue
}

#** menu_loop: present the menu until user quits
#===============================================================================
#     ARGUMENTS:  none, but lots of side effects
#       GLOBALS:  workdir
#                 cmtmsgfile
#                 upcommitsfile
#       RETURNS:  stat, which is the value returned by the call to menu_parser
#*==============================================================================
menu_loop() {

	local stat=0

	cmtmsgfile="$workdir/.gcpgitlog"

	cfg_update_configfile
	while :; do

		menu_parser
		stat=$?
		# echo "menu_parser_stat: $stat"
	done
	return $stat
}

#** edit_commit: Loop through process to edit commit message until done
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  cmtmsgfile
#       RETURNS:  none
#*==============================================================================
edit_commit() {
	local yup

	while :; do
		# Display the git log message and inquire if it needs more
		# editing.
		#
		git log -n1 > "$cmtmsgfile"
		cat "$cmtmsgfile"
		echo

		getyn "Edit this commit message?" yup

		if $yup; then git commit --amend; else break; fi
	done
}

#** abort_cherp: abort the current cherrypick/apply and exit
#===============================================================================
#
#  This will clear conflicts flag and abort the pending cherrypick
#
#     ARGUMENTS:  $1 - true if command line call
#       GLOBALS:  b_conflict
#                 upcmtstartline
#       RETURNS:  none
#*===============================================================================
abort_cherp() {
	local cmt

	init_cmdline_call
	git cherry-pick --abort 2>/dev/null
	# Get the last succesful commit and git reset to it.
	cmt="$(gitnice | cut -d' ' -f1)"
	git reset --hard "$cmt"

	b_conflict=false
	upcmtstartline=1
	cfg_set_item "b_conflict" "$b_conflict"
	cfg_set_item "upcmtstartline" "$upcmtstartline"
	get_current_cherrypick

	exit_cherp $exit_good
}

#** get_newhead: choose from the heads since dnorighead
#
# Globals:
#   dnorighead    - result of 'git merge-base HEAD <origin-branch-name>'
#   dncurrenthead - this will be modified if caller selects different head
#*
get_newhead() {
	local dncmtary=()
	local new
	local hashsize
	local addlprompt
	local tmp
	local spc

	mapfile -t dncmtary < <(extup -m "$dnorighead"^..)

	# Create space strings based on the sizes of the hashes.
	# These will be used to correctly align the column headings in the
	# selection menu.
	tmp="$(cut -d' ' -f1 <<< "${dncmtary[0]}")"
	hashsize="${#tmp}"
	spc="$(printf "%*c" $((hashsize - 7)) " ")"

	select_from_array dncmtary "Dn Cmts" new \
		"      $MNU${UND}Dn Cmts$spc$OFF $MNU${UND}Up Cmts$spc$OFF" || return 1

	# Set the new downstream current head global
	dncurrenthead="$(cut -d' ' -f1 <<< "$new")"
	return 0
}

#** reset_cherp: reset the current downstream HEAD to an earlier commit
#=============================================================================
# If the current downstream HEAD is not at the original downstream HEAD, then
# the user is presented with a list of downstream commits and corresponding
# upstream commits. If the user chooses an earlier commit from the list, the
# downstream commit will be reset to that point, and the upstreamcommitsfile
# will be updated. It will appear as if those later commits have not yet been
# made.
# This is useful if things go over the edge, and you need to backtrack.
#
#     ARGUMENTS:  $1 - exit code
#       GLOBALS:  dnorighead
#                 dncurrenthead
#                 currentuphash
#                 upcommitsfile
#                 lastuphash -  will be modified if caller selects new dncurrenthead
#       RETURNS:  none
#*==============================================================================
reset_cherp() {
	local cols=$((tcols - 12))
	local -a clrary=()
	local linenumber

	# Reset: Clear the leading "+ " from the lines in the upstreamcommitsfile to
	# indicate that the corresponding upstream commits are not applied.
	# We are backtracking.
	# If the user chose the original head, resetting it back to the beginning,
	# then clear all the done markers, else just clear the ones that we're
	# retreating from.
	get_newhead || return
	mapfile -t clrary < <(extup -m -b "$dncurrenthead".. | cut -d' ' -f1)
	linenumber=$(grep -n -m1 "${clrary[-1]}" "$upcommitsfile" | cut -d: -f1)

	sed -i "${linenumber},\$s|^+ ||" "$upcommitsfile"

	# Reset to the new head, and get the next cherrypick.
	git reset --hard "$dncurrenthead"
	b_conflict=false
	b_lasthashvalid=false
	upcmtstartline=0
	get_next_cherrypick
	$b_cmdline && exit_cherp $exit_reset || return
}

#** run_continue: continue backporting after resolving conflicts
#===============================================================================
#
#  Assumes that changes were made and committed externally to this script.
#
#     ARGUMENTS:  none
#       GLOBALS:  b_conflict
#       RETURNS:  none
#*==============================================================================
run_continue() {
	# echo -e "$UND\0run_continue$OFF"

	local statstr
	local gitstat

	statstr=$(
cat <<EOF
You have made changes that must be committed before using "cherp continue".
You can use "cherp commit" if you want cherp to make these commits for you.
EOF
)

	gitstat=$(git status --porcelain)
	[ "$gitstat" ] && { echo -e "$statstr"; git status; exit $exit_pending; }

	init_cmdline_call
	git cherry-pick --continue
	b_conflict=false
	get_next_cherrypick
	run_me
}

#** run_commit: return from resolving conflicts, but let the script commit
#===  FUNCTION  ================================================================
#
#  Script will commit and create the commit log from the conflicthash.
#
#     ARGUMENTS:  $1 if == "ONE" run one and exit
#       GLOBALS:  currentuphash
#                 conflicthash
#                 b_conflict
#                 exit_nothing
#                 exit_good
#       RETURNS:  none
#*==============================================================================
run_commit() {
	# echo -e "$UND\0run_commit$OFF"

	init_cmdline_call
	currentuphash="$conflicthash"	# get the stored conflict hash

	# If there was no conflict hash, let the user know there's nothing
	# to commit, else stage the commit and continue.
	if [ -z "$conflicthash" ]; then
		echo -e "\n${CAU}There is nothing to commit.$OFF"
	else
		conflicthash=		# null out the stored conflict hash
		set_cfg_item "conflicthash" "$conflicthash"
		b_conflict=true
		stage_commit
		mark_done $currentuphash
	fi

	b_conflict=false
	$b_one && exit_cherp $exit_good
	get_next_cherrypick
	b_cmdline=false
	menu_loop
}

#** run_single: just backport one commit
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  currentuphash
#                 b_single
#       RETURNS:  none
#*==============================================================================
run_single() {
	local stat

	echo -e "$UND\0run_single$OFF"
	b_single=true

	set_cfg_item "lastuphash" "$currentuphash"

	cherrypick
	stat=$?
	exit $stat
}

#** mark_done: mark the line with a leading +
#===  FUNCTION  ================================================================
#
#  Indicates the upstream hash in this line of the backport commits file has
#  been backported.
#
#     ARGUMENTS:  $1 - uphash
#    		  $2 - optional user supplied mark
#       GLOBALS:  upcommitsfile
#       RETURNS:  0 on success, nonzero on fail
#*==============================================================================
mark_done() {
	local uphash="$1"
	local mark='+'		# the default leading char
	local line
	local -i lnum
	local stat

	[ -f "$upcommitsfile" ] || return 1

	# If user passed a char in $2, then it means user wants to apply a
	# different leading mark.
	[ -n "$2" ] && mark="$2"

	line=$(grep -n -m1 "$uphash" "$upcommitsfile")
	(($? == 0)) || return 1
	lnum=$(cut -d: -f1 <<< "$line")
	line=$(cut -d: -f2- <<< "$line")
	line="$mark $line"
	ui_replaceline "$lnum" "$line" "$upcommitsfile"
	return 0
}

#** clear_done: clear "done" mark for line having given hash in upcommitsfile
#===  FUNCTION  ================================================================
#     ARGUMENTS:  $1 - uphash
#    		  $2 - optional user supplied mark
#       GLOBALS:  upcommitsfile
#       RETURNS:  0 on success, nonzero on fail
#*==============================================================================
clear_done() {
	local uphash="$1"
	local mark='+'		# the default leading char
	local line
	local -i lnum
	local stat

	[ -f "$upcommitsfile" ] || return 1

	# If user passed a char in $2, then it means user wants to apply a
	# different leading mark.
	[ -n "$2" ] && mark="$2"

	line=$(grep -n -m1 "$uphash" "$upcommitsfile")
	(($? == 0)) || return 1
	lnum=$(cut -d: -f1 <<< "$line")
	line=$(cut -d: -f2- <<< "$line")
	line="${line:2}"
	ui_replaceline "$lnum" "$line" "$upcommitsfile"
	return 0
}

#** clear_alldone: clear all the done marks in the upcommitsfile
#===============================================================================
#          NAME:  clear_alldone
#   DESCRIPTION:  Clear the "done" mark for the line in the upcommitsfile
#                 corresponding to the hash passed.
#     ARGUMENTS:  $1 - optional user supplied mark
#       GLOBALS:  upcommitsfile
#       RETURNS:  0 on success, nonzero on fail
#*==============================================================================
clear_alldone() {
	local mark='+'		# the default leading char
	local markstr=

	[ -f "$upcommitsfile" ] || return 1

	# If user passed a char in $1, then it means user wants to remove  a
	# different leading mark.
	[ -n "$1" ] && mark="$1"
	markstr="$mark "	# add the trailing space

	sed -i "s|^$markstr||g" "$upcommitsfile"

	return 0
}

#** cherrypick: backport the upstream commit in uphash
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  upcommitsfile
#                 commit
#                 tcols
#                 currentuphash
#                 lastuphash
#                 b_conflict
#                 b_single
#       RETURNS:  non-zero if something went wrong
#*==============================================================================
cherrypick() {
	# echo -e "$UND\0cherrypick$OFF"

	local uphash=$currentuphash
	local gitstat
	local wcols=$((tcols - 10))
	local untracked
	local b_setexit=false
	local conflictmsg
	local bogusmsg
	conflictmsg=$(
cat <<EOF

$UND$WRN\0You have conflicts to fix.$OFF$INF

After fixing the conflicts, you can reenter cherp with the following commands.

$MNU\0cherp commit$INF   : if you have fixed the conflicts and want the script to stage
                 the commit and create the commit log for you.

$MNU\0cherp continue$INF : if you have fixed the conflicts and made the commit externally
                 and wish to continue with the next cherrypick.$OFF
EOF
)
	bogusmsg=$(
cat <<EOF
$WRN
Upstream commit hash $STA$uphash$WRN appears to be bogus.$INF
Make sure the hashes in $STA$upcommitsfile$INF are all valid.$OFF
\0
EOF
)
	commit=$(git log --oneline -n1 "$uphash")
	echo -e "${INF}Processing : $STA${commit:0:$wcols}$OFF"

	case "$backport_mode" in
	    "$bm_cherry" )
		if $b_nit; then
			git cherry-pick -n "$uphash"
		else
			git -c merge.renameLimit=1 cherry-pick -x "$uphash"
		fi
		;;
	    "$bm_patch" )
		err="$(patch -p1 --merge < <(git show "$uphash"))"
		;;
	esac

	gitstat=$?

	# If cherry-pick or git-apply returns with 128, the commit was invalid
	# or ambiguous.
	#
	[ $gitstat -eq 128 ] && { echo -e "$bogusmsg"; exit_cherp $exit_bogus; }

	if $b_nit && $b_single; then
		git reset	# unstage changes.
		git add -p	# select the hunks you want.
		b_nit=false
	else
		# If the backport wants to add a new file to the index, or if the
		# backport exited with a nonzero status other than 128, then we
		# must report the conflict and stop.
		untracked="$(git ls-files --others --exclude-standard)"

		if [ -n "$untracked" ] || ((gitstat != 0)); then
			b_setexit=true
			b_conflict=true
			$b_single && git status && exit $exit_conflict
			echo -e "$conflictmsg"
			conflicthash=$uphash
			set_cfg_item "conflicthash" "$conflicthash"
			# echo -e "Saving: $BLD${commit:0:$wcols}$OFF"
			show_status internal
			[ -n "$err" ] && echo -e "$INF$err$OFF"
			exit_cherp $exit_conflict
		fi
	fi

	stage_commit
	mark_done "$uphash"
	set_cfg_item "lastuphash" "$lastuphash"
	get_lastuplog

	return 0;
}

#** stage_commit: process the commit that was backported
#===  FUNCTION  ================================================================
#
#  Create the git log for the backported commit, including JIRA number, upstream
#  and brew info, if any.
#  Query the user to see if editing the commit is warranted, for conflicts, etc.
#
#     ARGUMENTS:  none
#       GLOBALS:  b_conflict
#		  cmtmsgfile
#		  str_jira
#		  str_cve
#		  str_upstream
#		  str_conflicts
#       RETURNS:  none
#*==============================================================================
stage_commit() {

	local description
	local uphash=$currentuphash
	local commit

	commit=$(git log --oneline -n1 "$uphash")
	git commit -aC "$uphash"

	# Create the new commit message in a file consisting of ..
	#	The user of this script as author of the patch
	#	The current date
	#	Descriptor line, with leading whitespace trimmed
	#	Bugzilla and brew if available
	#	Upstream status if available
	#	Original commit message from cherry-picked commit
	#	Signed-off-by: line
	#
	echo -e "\n" > "$cmtmsgfile"

	set -f	# disable wildcard
	description=$(git log -n1 "$uphash" | head -5 | tail -1)

	# Trim leading whitespace from description line and append
	# it to the commit message. Also append the standard commit
	# message.
	#
	description=$(echo -e $description)
	echo -e "$description\n\n" >> "$cmtmsgfile"
	[ -n "$str_jira" ] && echo -e "JIRA: $str_jira" >> "$cmtmsgfile"
	[ -n "$str_cve" ] && echo -e "CVE: $str_cve" >> "$cmtmsgfile"
	[ -n "$str_upstream" ] && echo -e "Upstream status: $str_upstream" >> "$cmtmsgfile"
	echo -e "\n" >> "$cmtmsgfile"
	set +f	# re-enable wildcards

	$b_conflict && echo -e "$str_conflicts" >> "$cmtmsgfile"

	# Append the original commit message.
	#
	git log -n1 "$uphash" >> "$cmtmsgfile"

	# Amend the commit messsage with you as author, using the
	# commit message file we built in the previous few lines,
	# and a Signed-off-by: ("-s") line.
	#
	git commit -s --amend --reset-author --file="$cmtmsgfile"

	# If there are conflicts, give the user the option to edit
	# the commit log.
	#
	$b_conflict && edit_commit

	b_conflict=false
}

#** set_cfg_item key value: writes the value to the key in the .conf file
#
# Arguments:
#   $1 - key
#   $2 - value
#*
set_cfg_item() {
	cfg_write_key "$1" "$2"
}

#** get_cfg_item key: echoes the value at the key offset in the .conf file
#
# Arguments:
#   $1 - the key in the config file to read
#
get_cfg_item() {
	cfg_read_key "$1"
}

#** get_originhead: get the HEAD of the downstream origin
#
# Get the original head by getting the commit where the current
# branch diverged from main
#
# Globals
#   dnorighead
#*
get_originhead() {
	local br

	dnorighead="$(get_cfg_item dnorighead)"
}

#** get_backport_mode: choose which of the availiable backport modes to use
#
# Globals
#   backport_mode
#   bm_cherry
#   bm_patch
#*
get_backport_mode() {
	echo
	echo -e "    ${INF}Which backport mode do you want to use?$MNU"
	echo -e "      1.$OFF git cherry-pick$MNU"
	echo -e "      2.$OFF patch --merge"

	loop_range 1 2 backport_mode

	set_cfg_item "backport_mode" "$backport_mode"
}

#** save_session: save session's config variables to the .conf file
#===============================================================================
#          NAME:  save_session
#   DESCRIPTION:  Save session's project variables to the project file.
#     ARGUMENTS:  $1 is not empty if this is an status call
#       GLOBALS:  upcommitsfile
#                 upcmtstartline
#                 All the sticky project variables
#       RETURNS:  none
#*==============================================================================
save_session() {
	# echo -e "$UND\0save_session$OFF"
	local -a keys=()
	local fd

	exec {fd}< "$configfile"
	while IFS+="=" read -ru $fd key; do
		key="$(echo "$key" | cut -d' ' -f1)"
		set_cfg_item "$key" "${!key}"
	done
	exec {fd}<&-
}

#** read_session: read the config variables out of the .conf file
#===============================================================================
#
#  Read the variables stored in the .conf file Some project variables are
#  updated elsewhere, and only need to be retrieved at init time and saved at
#  exit time.
#
#     ARGUMENTS:  none
#       GLOBALS:  workdir
#                 upcommitsfile
#                 upurl
#                 upname
#                 tbackground
#       RETURNS:  1 if any of the important conf values are missing
#                 0 otherwise
#*==============================================================================
read_session() {
	# echo -e "$UND\0read_session$OFF"
	local cfgtemplate=

	# Initialize the paths for the current working directory
	#
	[ -d "$MYDATA" ] || mkdir -p "$MYDATA"
	configfile="$MYDATA/cherp.conf"
	cfgtemplate="$MYLIB/cherp.conf"

	# This call will init all the global variables with the values stored
	# in .data/cherp.conf
	cfg_start "$cfgtemplate" "$configfile"

	# If the background value saved in the conf file is not valid, then
	# call to determine the background color

	if ((tbackground < tb_lite || tbackground > tb_dark)); then
		ui_setbg tbackground
		cfg_set_item "tbackground" "$tbackground"
	else
		ui_do_colors "$tbackground"
	fi

	init_global_strings

	if grep -q "$upname" .git/config; then
		upurl=$(grep -A1 "$upname" .git/config | grep url | cut -d'=' -f2)
		# Trim spaces
		upurl="${upurl// /}"
	else
		set_upstream_url "NEW"
	fi

	((backport_mode >= bm_lower && backport_mode <= bm_upper)) || {
		get_backport_mode
	}

	get_originhead

	[ "$upcmtstartline" ] || return 1
	[ "$workdir" ]        || set_working_directory
	[ "$upcommitsfile" ]  || set_upcommitsfile

	return 0
}

#** init_common: common to all init calls
#==============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  upcmtstartline
#                 upcommitsfile
#                 upname
#       RETURNS:  none
#*==============================================================================
init_common() {
	# echo -e "$UND\0init_common$OFF"

	$b_new && upcmtstartline=1
	[ -f "$upcommitsfile" ] && get_current_cherrypick

	git branch -r | grep -q "$upname" || fetch_upstream_repo

	$b_conflict || get_lastuplog
	b_session_inited=true
}

#** init_cmdline_call: for command line invocations
#==============================================================================
#     ARGUMENTS:  none
#       RETURNS:  none
#*==============================================================================
init_cmdline_call() {
	# echo -e "$UND\0init_cmdline_call$OFF"

	local stat
	local newstr="${INF}Please type $MNU$MYNAME new$INF to start.$OFF\n"

	read_session || { echo -e "$newstr"; exit 1; }
	init_common
}

#** init_session: init config variables from the .conf file
#===============================================================================
#     ARGUMENTS:  none
#       GLOBALS:  All sesson variables are affected
#       RETURNS:  none
#*==============================================================================
init_session() {
	# echo -e "$UND\0init_session$OFF"

	read_session
	init_common
	# $b_cmdline && exit_cherp $exit_good
}

#** init_newsession: initialize a new session from scratch
#===============================================================================
#       GLOBALS:  All session variables are affected
#     ARGUMENTS:  none
#       RETURNS:  none
#*==============================================================================
init_newsession() {
	# echo -e "\n$UND\0init_newsession$OFF"

	read_session
	dnorighead="$(cut -d' ' -f1 <(git log --oneline -1 ))"
	set_cfg_item dnorighead "$dnorighead"

	b_conflict=false
	set_cfg_item b_conflict "$b_conflict"
	set_working_directory
	set_upcommitsfile
	set_gitbranch

	echo -e "\n${CAU}The following will be in the Options Menu.$OFF"
	get_oneopt "${MNU}JIRA link: $OFF" "str_jira"
	get_oneopt "${MNU}CVE: $OFF" "str_cve"
	get_oneopt "${MNU}Upstream status: $OFF" "str_upstream"
	b_lasthashvalid=false
	b_new=true
	init_common
	$b_cmdline && exit_cherp $exit_good
}

#* init_current_session: recover last good conf and internal variables
#===============================================================================
#       GLOBALS:  All session variables are affected
#     ARGUMENTS:  none
#       RETURNS:  none
#*==============================================================================
init_current_session() {
	upcmtstartline=1
	lastuphash=
	b_conflict=false
	set_cfg_item "upcmtstartline"	"$upcmtstartline"
	set_cfg_item "b_conflict"	"$b_conflict"
	set_cfg_item "lastuphash"	"$lastuphash"

	b_lasthashvalid=false
	git cherry-pick --abort 2>/dev/null
	init_session
}

#** run_me: main program loop
#===============================================================================
#       GLOBALS:  upcommitsfile
#                 currentuphash
#                 stophash
#                 exit_good
#                 b_cmdline
#                 b_conflict
#                 b_session_inited
#     ARGUMENTS:  $1 - if .eq to 1, then just run the very next commit and stop.
#       RETURNS:  None
#*==============================================================================
run_me() {
	# echo -e "$UND\0run_me$OFF"

	local uphash
	local stat
	local b_one=false
	local -i input="$1"

	[ -n "$upcommitsfile" ] || \
		exit_cherp $exit_nothing "${CAU}No Upstream Backports file.$OFF"

	[ -n "$workdir" ] ||
		exit_cherp $exit_nothing "${CAU}No Working Directory.$OFF"

	[ -n "$input" ] && (($input == 1)) && b_one=true

	$b_session_inited || { $b_cmdline && init_cmdline_call; }

	if $b_conflict; then
		echo -e "${CAU}There is an unresolved conflict" \
			"backporting: $STA$currentuphash$OFF"
		show_status
		ui_press_any
		return
	fi

	while :; do
		if [ "$currentuphash" == "$stophash" ]; then
			echo -e "${INF}Stopping before $MNU$stophash$OFF"
			break
		fi
		cherrypick
		get_next_cherrypick
		stat=$?

		if [ $stat -ne 0 ];then
			echo -e "${CAU}No more commits in $STA$upcommitsfile$OFF"
			break
		fi

		$b_one && break

	done

	save_session

	if $b_cmdline; then exit_cherp $exit_good; else menu_loop; fi
}

#** ctrl_c: handler for user interrupt
#
# run if user hits control-c
#*
ctrl_c() {
	set +x
	echo
	validate_last_upstream_hash
	exit_cherp $CTLC_EXIT         # defined in lib/ui.source
}

#** check_command: checks the command line command
#
# Arguments:
#   $1 - command from command line
#   $2 - receives the validated command from the command line
#*
check_command() {
	local cmd="$1"
	local lead="--"

	[ "${#cmd}" -eq 2 ] && eval "$2"="$cmd" && return 0
	[ "${cmd:0:2}" = "$lead" ] && eval "$2"="$cmd" && return 0

	[ "${cmd:0:1}" = "-" ] && cmd="-$cmd" || cmd="--$cmd"
	eval "$2"="$cmd"
	return 1
}

#**############################
# Start of Script Execution
#*#############################

# trap keyboard interrupt (control-c)
#
trap ctrl_c SIGINT
ui_testkeypress	# from lib/keypress_support.source: inits promptgetkey_cmd
init_session

# Determine if we're at the top of a git tree. If not, exit.
#
if ! [ -d .git ]; then
	echo -3 "$WRN"
	echo -e "The current directory... $STA$PWD$WRN"
	echo -e "\t ...is not the top of a git tree.$INF"
	echo "Please cd to the top of a git tree.$OFF"
	echo
	exit 1
fi

#########################################
# Command Line Options
#########################################

declare checked_cmd
declare infostr
infostr="Type \"$(basename "$0") -h\" for more info."
declare invoptstr="\nInvalid option.\n$infostr"
declare needcmtstr="\nMust supply commit hash with -p | pick\n$infostr"
declare shortopts="sp:h"
declare longopts="\
abort,\
branch,\
apply:,\
commit,\
directory,\
hashlist,\
help,\
history,\
new,\
nit,\
pick:,\
run,\
select,\
setup,\
status,\
version,\
"

# If there are no options, then just run the menu.
#
if [ $# -eq 0 ]; then
	b_cmdline=false
else
	b_cmdline=true

	check_command "$1" checked_cmd || shift

	# [ $# -gt 1 ] && checked_cmd="$checked_cmd ${@:2:$#}"

	opts=$(getopt --options $shortopts --long $longopts --name "$0" -- "$@")
	eval set -- "$opts"

	while :; do
	    case "$checked_cmd" in
		"--abort" )
			abort_cherp
			;;
		"--branch" )
			set_gitbranch
			;;
		"--commit" )
			[ "$2" == "1" ] && b_one=true || b_one=false
			run_commit
			;;
		-h | "--help" 	)
			ptpage -b "$tbackground" "$MYHLP"
			exit 0
			;;
		"--history" )
			show_history
			;;
		"--new" )
			init_newsession
			;;
		"--nit" )
			b_nit=true
			;& 		# fall through to pick
		-p | "--pick" )
			currentuphash=$2
			[ "$currentuphash" ] || { echo -e "$needcmtstr"; exit 1; }
			run_single
			;;
		"--reset" )
			reset_cherp
			;;
		-r | "--run" )
			run_me
			;;
		"--select" )
			set_next_cherrypick
			;;
		"--setup" )
			init_session
			menu_loop
			shift
			;;
		-s | "--status" )
			show_status
			;;
		"--version" )
			print_herald
			exit 0
			;;
		-- )	shift
			break
			;;
		* )	echo -e "$invoptstr"
			exit 1
			;;
	    esac
	done
fi

##############################################
# Main Program
##############################################

test_sanity() { echo -en "${CAU}SANITY$OFF  "; ui_press_any; }

# Print the herald
#
print_herald

# The following line will single step through this script.
# Use the # to comment it out.
# trap 'read -p "$(printf "%$((${#BASH_SOURCE[0]}+8))s" "")" \
#       line && eval "$line" || exit $?' DEBUG


# Present the ui and get the parameters for the cherry-picks.
#
menu_loop

echo
exit_cherp $exit_good

